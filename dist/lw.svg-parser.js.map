{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lw.svg-parser.js","webpack:///webpack/bootstrap a1c30d821b36694f4a69","webpack:///./path.js","webpack:///./parser.js","webpack:///./tag.js","webpack:///./tagparser.js","webpack:///./trace.js","webpack:///../~/clipper-lib/clipper.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","Point","x","y","parseFloat","isNaN","console","error","Error","point","Path","points","forEach","push","scaleUp","arguments","undefined","X","parseInt","Y","_this","scaleDown","addPoint","il","firstPoint","getPoint","isEqual","isClosed","matrix","map","default","Parser","_tag","_tagparser","settings","element","editor","document","defs","tags","traceSettings","assign","linear","step","resolution","segmentLength","supportedTags","parseTags","includes","skipTags","excludes","onTag","onTagContext","input","loadFromString","File","loadFromFile","XMLDocument","loadFromXMLDocument","Element","loadFromElement","Promise","reject","resolve","nodeName","textContent","getElementsByTagName","_this2","documentElement","then","catch","_this3","_parseEditor","parser","DOMParser","XMLDoc","parseFromString","name","version","fingerprint","match","_this4","reader","FileReader","onload","event","result","onerror","readAsText","_this5","load","parse","_parseElement","applyMatrix","tag","callback","context","_this6","_onTag","parent","_this7","Tag","indexOf","_skipTag","tagParser","TagParser","childTag","childNodes","childNode","addChild","children","message","warn","attr","_interopRequireDefault","obj","__esModule","_path","_clipperLib","_clipperLib2","DEG_TO_RAD","Math","PI","toLowerCase","layer","attrs","paths","path","shapes","setMatrix","keys","setAttr","defaultValue","getAttr","getLayerName","clearPath","close","relative","addMatrix","angle","cos","sin","tan","transform","shape","outer","holes","hole","fillRule","PolyFillType","pftNonZero","pftEvenOdd","cPolyTree","PolyTree","cClipper","Clipper","clipperScale","clipperPaths","getClipperPoints","AddPaths","PolyType","ptSubject","Execute","ClipType","ctUnion","PolyTreeToPaths","polygones","SimplifyPolygons","Clear","StrictlySimple","toPath","fromClipperPoints","exPolygons","JS","PolyTreeToExPolygons","exPolygon","_trace","_path2","currentCommand","lastCommand","pathData","handler","_parseTagAttrs","attributes","style","some","_normalizeTagAttr","replace","split","nodeValue","colorsAttrs","attrName","_parseViewBoxAttr","_parseTransformAttr","trim","_skipTagAttr","_normalizeTagAttrUnit","_normalizeTagAttrPoints","_normalizeTagAttrRange","_normalizeTagAttrPreserveAspectRatio","stringValue","floatValue","_parseNumbers","min","max","filter","params","defer","align","meet","slice","rawParams","substr","viewBox","width","height","scaleX","scaleY","translateX","translateY","preserveAspectRatio","newWidth","newHeight","translate","scale","transformAttr","transformations","pop","type","raw","func","tagTransform","apply","newPath","closePath","addPoints","title","description","useTag","setLayerName","shift","concat","_polyline","w","h","rx","ry","dx","dy","r","cx","cy","num","splice","join","dAttr","commands","parseError","toUpperCase","_clearPath","_newPath","_addPoints","_closePath","every","_paths","p1","rl","x1","y1","x2","y2","p2","p3","p4","tracer","CubicBezier","coords","trace","QuadricBezier","large","sweep","Arc","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","mod","clamp","val","distance","p0","sqrt","pow","v0","v1","n","acos","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","getPrototypeOf","getter","MATH_PI_2","TraceBase","arcLength","arcLengthMap","t","prevPoint","getPointAtT","nextPoint","u","targetDistanceFromStartingPoint","resultantT","prevArcLength","prevT","entry","endDiff","startDiff","linearFactor","_approximateLength","segments","round","_addPoint","_postTrace","getPath","_TraceBase","radians","abs","__addPoint","transformedPoint","radiiCheck","cSquareNumerator","cSquareRootDenom","cRadicand","cCoef","transformedCenter","center","startVector","endVector","startAngle","sweepAngle","init","_TraceBase2","_B1","_B2","_B3","_B4","_C1","unshift","_TraceBase3","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","BigInteger","a","b","ClipperLib","biginteger_used","fromInt","fromNumber","fromString","nbi","am1","j","v","floor","am2","xl","xh","l","am3","int2char","BI_RM","charAt","intAt","s","BI_RC","charCodeAt","bnpCopyTo","bnpFromInt","DV","nbv","bnpFromString","k","fromRadix","mi","sh","DB","ZERO","subTo","bnpClamp","DM","bnToString","negate","toString","toRadix","d","km","bnNegate","bnAbs","bnCompareTo","nbits","bnBitLength","bnpDLShiftTo","bnpDRShiftTo","bnpLShiftTo","bs","cbs","bm","ds","bnpRShiftTo","bnpSubTo","bnpMultiplyTo","am","bnpSquareTo","bnpDivRemTo","q","pm","pt","copyTo","ts","ms","nsh","lShiftTo","ys","y0","yt","F1","F2","d1","FV","d2","e","dlShiftTo","compareTo","ONE","qd","drShiftTo","rShiftTo","bnMod","divRemTo","Classic","cConvert","cRevert","cReduce","cMulTo","multiplyTo","reduce","cSqrTo","squareTo","bnpInvDigit","Montgomery","mp","invDigit","mpl","mph","um","mt2","montConvert","montRevert","montReduce","u0","montSqrTo","montMulTo","bnpIsEven","bnpExp","z","r2","g","convert","sqrTo","mulTo","revert","bnModPowInt","isEven","exp","bnClone","bnIntValue","bnByteValue","bnShortValue","bnpChunkSize","LN2","log","bnSigNum","bnpToRadix","signum","cs","chunkSize","intValue","bnpFromRadix","dMultiply","dAddOffset","bnpFromNumber","testBit","bitwiseTo","shiftLeft","op_or","isProbablePrime","bitLength","Array","nextBytes","bnToByteArray","bnEquals","bnMin","bnMax","bnpBitwiseTo","op","f","op_and","bnAnd","bnOr","op_xor","bnXor","op_andnot","bnAndNot","bnNot","bnShiftLeft","bnShiftRight","lbit","bnGetLowestSetBit","cbit","bnBitCount","bnTestBit","bnpChangeBit","bnSetBit","changeBit","bnClearBit","bnFlipBit","bnpAddTo","bnAdd","addTo","bnSubtract","bnMultiply","bnSquare","bnDivide","bnRemainder","bnDivideAndRemainder","bnpDMultiply","bnpDAddOffset","NullExp","nNop","nMulTo","nSqrTo","bnPow","bnpMultiplyLowerTo","bnpMultiplyUpperTo","Barrett","q3","mu","divide","barrettConvert","barrettRevert","barrettReduce","multiplyUpperTo","multiplyLowerTo","barrettSqrTo","barrettMulTo","bnModPow","k1","g2","is1","bnGCD","clone","getLowestSetBit","bnpModInt","bnModInverse","ac","subtract","add","bnIsProbablePrime","lowprimes","lplim","modInt","millerRabin","bnpMillerRabin","n1","shiftRight","random","modPow","modPowInt","use_int32","use_xyz","use_lines","isNode","window","navigator_appName","nav","navigator","userAgent","appName","browser","chrome","chromium","safari","firefox","firefox17","firefox15","firefox3","opera","msie10","msie9","msie8","msie7","msie","dbits","canary","j_lm","BI_FP","rr","vv","byteValue","shortValue","toByteArray","equals","and","or","xor","andNot","not","bitCount","setBit","clearBit","flipBit","multiply","remainder","divideAndRemainder","modInverse","gcd","square","Int128","IsNegative","op_Equality","val1","val2","op_Inequality","op_GreaterThan","op_LessThan","op_Addition","lhs","rhs","op_Subtraction","Int128Mul","op_Division","ToDouble","Inherit","ce","ce2","$baseCtor","getOwnPropertyNames","Paths","DoublePoint","DoublePoint0","DoublePoint1","dp","DoublePoint2","PolyNode","m_Parent","m_polygon","m_Index","m_jointype","m_endtype","m_Childs","IsOpen","IsHoleNode","node","ChildCount","Contour","AddChild","Child","cnt","GetNext","GetNextSiblingUp","Childs","Parent","IsHole","m_AllPolys","ilen","GetFirst","Total","Math_Abs_Int64","Math_Abs_Int32","Math_Abs_Double","Math_Max_Int32_Int32","Cast_Int32","Cast_Int64","ceil","Number","toInteger","PI2","IntPoint","alen","Z","Round","IntPoint0","IntPoint1","IntPoint1dp","IntPoint2","IntPoint3","IntRect","left","top","right","bottom","ir","IntRect0","IntRect1","IntRect4","ctIntersection","ctDifference","ctXor","ptClip","pftPositive","pftNegative","JoinType","jtSquare","jtRound","jtMiter","EndType","etOpenSquare","etOpenRound","etOpenButt","etClosedLine","etClosedPolygon","EdgeSide","esLeft","esRight","Direction","dRightToLeft","dLeftToRight","TEdge","Bot","Curr","Top","Delta","Dx","PolyTyp","Side","WindDelta","WindCnt","WindCnt2","OutIdx","Next","Prev","NextInLML","NextInAEL","PrevInAEL","NextInSEL","PrevInSEL","IntersectNode","Edge1","Edge2","Pt","MyIntersectNodeSort","Compare","node1","node2","LocalMinima","LeftBound","RightBound","Scanbeam","OutRec","Idx","FirstLeft","Pts","BottomPt","OutPt","Join","OutPt1","OutPt2","OffPt","ClipperBase","m_MinimaList","m_CurrentLM","m_edges","m_UseFullRange","m_HasOpenPaths","PreserveCollinear","horizontal","Skip","Unassigned","tolerance","loRange","hiRange","near_zero","IsHorizontal","PointIsVertex","pp","pp2","PointOnLineSegment","linePt1","linePt2","UseFullRange","PointOnPolygon","SlopesEqual","e1","e2","pt1","pt2","pt3","pt4","SlopesEqual3","SlopesEqual4","SlopesEqual5","DisposeLocalMinimaList","jlen","tmpLm","RangeTest","useFullRange","Value","InitEdge","eNext","ePrev","InitEdge2","polyType","SetDx","FindNextLocMin","E","E2","ProcessBound","LeftBoundIsForward","EStart","Horz","Result","locMin","InsertLocalMinima","ReverseHorizontal","AddPath","pg","Closed","highI","edges","IsFlat","$1","eStart","eLoopStop","Pt2IsBetweenPt1AndPt3","RemoveEdge","leftBoundIsForward","EMin","ppg","closed","newLm","PopLocalMinima","tmp","Reset","lm","InitOptions","m_PolyOuts","m_ClipType","m_Scanbeam","m_ActiveEdges","m_SortedEdges","m_IntersectList","m_IntersectNodeComparer","m_ExecuteLocked","m_ClipFillType","m_SubjFillType","m_Joins","m_GhostJoins","m_UsingPolyTree","ReverseSolution","ZFillFunction","ioReverseSolution","ioStrictlySimple","ioPreserveCollinear","DisposeAllPolyPts","DisposeScanbeamList","sb2","InsertScanbeam","newSb","ispolytree","clipType","solution","subjFillType","clipFillType","succeeded","ExecuteInternal","BuildResult","polytree","BuildResult2","FixHoleLinkage","outRec","orfl","botY","PopScanbeam","InsertLocalMinimaIntoAEL","ProcessHorizontals","topY","ProcessIntersections","ProcessEdgesAtTopOfScanbeam","Area","ReversePolyPtLinks","JoinCommonEdges","FixupOutPolygon","DoSimplePolygons","DisposeOutRec","index","AddJoin","Op1","Op2","AddGhostJoin","Op","SetZ","lb","rb","InsertEdgeIntoAEL","SetWindingCount","IsContributing","AddOutPt","AddLocalMinPoly","AddEdgeToSEL","HorzSegmentsOverlap","IntersectEdges","edge","startEdge","E2InsertsBeforeE1","TopX","IsEvenOddFillType","IsEvenOddAltFillType","pft","pft2","Inside","CopyAELToSEL","SwapPositionsInAEL","edge1","edge2","next","prev","SwapPositionsInSEL","AddLocalMaxPoly","AppendPolygon","prevE","outPt","CreateOutRec","ToFront","newOp","SetHoleState","SwapPoints","seg1a","seg1b","seg2a","seg2b","isHole","GetDx","FirstIsBottomPt","btmPt1","btmPt2","dx1p","dx1n","dx2p","dx2n","GetBottomPt","dups","GetLowermostRec","outRec1","outRec2","bPt1","bPt2","Param1RightOfParam2","GetOutRec","idx","outrec","holeStateRec","side","p1_lft","p1_rt","p2_lft","p2_rt","OKIdx","ObsoleteIdx","pp1","SwapSides","SwapPolyIndexes","outIdx","e1Contributing","e2Contributing","oldE1WindCnt","e1FillType","e2FillType","e1FillType2","e2FillType2","e1Wc","e2Wc","e1Wc2","e2Wc2","DeleteFromAEL","AelPrev","AelNext","DeleteFromSEL","SelPrev","SelNext","UpdateEdgeIntoAEL","isTopOfScanbeam","horzEdge","ProcessHorizontal","GetHorzDirection","HorzEdge","$var","Left","Right","Dir","dir","horzLeft","horzRight","eLastHorz","eMaxPair","GetMaximaPair","IsLastHorz","GetNextInAEL","op1","eNextHorz","op2","IsMinima","IsMaxima","IsIntermediate","BuildIntersectList","FixupIntersectionOrder","ProcessIntersectList","$$e2","isModified","IntersectPoint","newNode","EdgesAdjacent","inode","IntersectNodeSort","sort","iNode","R1","R2","R3","R4","currentY","ip","b1","b2","IsMaximaEdge","DoMaxima","ReversePaths","polys","len","reverse","Orientation","poly","PointCount","pts","polyg","pn","lastOK","DupOutPt","InsertAfter","GetOverlap","a1","a2","$val","JoinHorz","op1b","op2b","DiscardLeft","Dir1","Dir2","JoinPoints","isHorizontal","reverse1","reverse2","DiscardLeftSide","Reverse1","Reverse2","GetBounds","GetBounds2","ops","opStart","PointInPolygon","ipNext","startOp","ptx","pty","poly0x","poly0y","poly1x","poly1y","Poly2ContainsPoly1","outPt1","outPt2","res","FixupFirstLefts1","OldOutRec","NewOutRec","firstLeft","ParseFirstLeft","FixupFirstLefts2","$i2","$t2","$l2","UpdateOutPtIdxs","oRec","op3","op4","outrec2","SimplifyPolygon","fillType","DistanceSqrd","DistanceFromLineSqrd","ln1","ln2","A","B","C","SlopesNearCollinear","distSqrd","PointsAreClose","ExcludeOp","CleanPolygon","outPts","CleanPolygons","Minkowski","pattern","IsSum","IsClosed","delta","polyCnt","pathCnt","quads","quad","MinkowskiSum","path_or_paths","pathIsClosed","TranslatePath","outPath","MinkowskiDiff","poly1","poly2","AddPolyNodeToPaths","NodeType","ntAny","polynode","nt","ntOpen","ntClosed","$i3","$t3","$l3","OpenPathsFromPolyTree","ClosedPathsFromPolyTree","ClipperOffset","miterLimit","arcTolerance","def_arc_tolerance","m_destPolys","m_srcPoly","m_destPoly","m_normals","m_delta","m_sinA","m_sin","m_cos","m_miterLim","m_StepsPerRad","m_lowest","m_polyNodes","MiterLimit","ArcTolerance","two_pi","joinType","endType","FixOrientations","GetUnitNormal","DoOffset","steps","OffsetPoint","DoSquare","DoRound","X2","clpr","outerNode","jointype","cosA","DoMiter","atan2","err","alert","AreaOfPolygon","AreaOfPolygons","area","BoundsOfPath","BoundsOfPaths","bounds","Clean","polygon","isPolygons","Clone","k_length","results","plen","Lighten","P","rem","addlast","bxax","byay","ax","ay","toleranceSq","PerimeterOfPath","perimeter","p1x","p1y","p2x","p2y","PerimeterOfPaths","ScaleDownPath","ScaleDownPaths","ScaleUpPath","ScaleUpPaths","ExPolygons","ExPolygon","AddOuterPolyNodeToExPolygons","expolygons","ep","childs","childs2","ExPolygonsToPaths"],"mappings":"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","file":"lw.svg-parser.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGParser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGParser\"] = factory();\n\telse\n\t\troot[\"SVGParser\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGParser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGParser\"] = factory();\n\telse\n\t\troot[\"SVGParser\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Point = function () {\n\t    // Class constructor...\n\t    function Point(x, y) {\n\t        _classCallCheck(this, Point);\n\t\n\t        // Init properties\n\t        this.x = parseFloat(x);\n\t        this.y = parseFloat(y);\n\t\n\t        if (isNaN(this.x) || isNaN(this.y)) {\n\t            console.error('x:', x, 'y:', y);\n\t            throw new Error('Float value!!!');\n\t        }\n\t    }\n\t\n\t    _createClass(Point, [{\n\t        key: 'isEqual',\n\t        value: function isEqual(point) {\n\t            return this.x === point.x && this.y === point.y;\n\t        }\n\t    }]);\n\t\n\t    return Point;\n\t}();\n\t\n\tvar Path = function () {\n\t    // Class constructor...\n\t    function Path() {\n\t        _classCallCheck(this, Path);\n\t\n\t        // Init properties\n\t        this.points = [];\n\t        this.length = 0;\n\t    }\n\t\n\t    _createClass(Path, [{\n\t        key: 'getPoints',\n\t        value: function getPoints() {\n\t            return this.points;\n\t        }\n\t    }, {\n\t        key: 'getFlattenPoints',\n\t        value: function getFlattenPoints() {\n\t            var points = [];\n\t            this.points.forEach(function (point) {\n\t                return points.push(point.x, point.y);\n\t            });\n\t            return points;\n\t        }\n\t    }, {\n\t        key: 'getClipperPoints',\n\t        value: function getClipperPoints() {\n\t            var scaleUp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\t\n\t            var points = [];\n\t            this.points.forEach(function (point) {\n\t                return points.push({ X: parseInt(point.x * scaleUp), Y: parseInt(point.y * scaleUp) });\n\t            });\n\t            return points;\n\t        }\n\t    }, {\n\t        key: 'fromClipperPoints',\n\t        value: function fromClipperPoints(points) {\n\t            var _this = this;\n\t\n\t            var scaleDown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\t\n\t            this.points = [];\n\t            points.forEach(function (point) {\n\t                return _this.addPoint(parseFloat(point.X * scaleDown), parseFloat(point.Y * scaleDown));\n\t            });\n\t            return this;\n\t        }\n\t    }, {\n\t        key: 'getPoint',\n\t        value: function getPoint(i) {\n\t            return this.points[i < 0 ? this.length + i : i] || null;\n\t        }\n\t    }, {\n\t        key: 'addPoint',\n\t        value: function addPoint(x, y) {\n\t            this.points.push(new Point(x, y));\n\t            this.length = this.points.length;\n\t        }\n\t    }, {\n\t        key: 'addPoints',\n\t        value: function addPoints(points) {\n\t            // For each couple of points\n\t            for (var i = 0, il = points.length; i < il; i += 2) {\n\t                this.addPoint(points[i], points[i + 1]);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'isClosed',\n\t        value: function isClosed() {\n\t            var firstPoint = this.getPoint(0);\n\t            return firstPoint && firstPoint.isEqual(this.getPoint(-1));\n\t        }\n\t    }, {\n\t        key: 'close',\n\t        value: function close() {\n\t            if (!this.isClosed() && this.length > 2) {\n\t                var firstPoint = this.getPoint(0);\n\t                this.addPoint(firstPoint.x, firstPoint.y);\n\t                return true;\n\t            }\n\t\n\t            return false;\n\t        }\n\t    }, {\n\t        key: 'transform',\n\t        value: function transform(matrix) {\n\t            this.points = this.points.map(function (point) {\n\t                return new Point(matrix[0] * point.x + matrix[2] * point.y + matrix[4], matrix[1] * point.x + matrix[3] * point.y + matrix[5]);\n\t            });\n\t        }\n\t    }]);\n\t\n\t    return Path;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Path = Path;\n\texports.Point = Point;\n\texports.default = Path;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Parser = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Imports\n\t\n\t\n\tvar _tag = __webpack_require__(3);\n\t\n\tvar _tagparser = __webpack_require__(4);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// SVG parser class\n\tvar Parser = function () {\n\t    // Class constructor...\n\t    function Parser(settings) {\n\t        _classCallCheck(this, Parser);\n\t\n\t        // Defaults settings\n\t        settings = settings || {};\n\t\n\t        // Init properties\n\t        this.element = null; // XML document Element object\n\t        this.editor = null; // Editor info { name, version, fingerprint }\n\t        this.document = null; // Document info { width, height, viewBox }\n\t        this.defs = null; // Defined <defs> (DOM) nodes list by id\n\t        this.tags = null; // Tag objects hierarchy\n\t\n\t        // Trace settings (Arc, Bezier)\n\t        this.traceSettings = Object.assign({\n\t            linear: true, // Linear trace mode\n\t            step: 0.01, // Step resolution if linear mode = false\n\t            resolution: 100, // Number of segments we use to approximate arc length\n\t            segmentLength: 1 }, settings.traceSettings || {});\n\t\n\t        // Supported tags by this lib\n\t        this.supportedTags = ['svg', 'g', 'defs', 'use', 'line', 'polyline', 'polygon', 'rect', 'circle', 'ellipse', 'path', 'title', 'desc'];\n\t\n\t        // Tags list to includes/excludes\n\t        this.parseTags = settings.includes || this.supportedTags;\n\t        this.skipTags = settings.excludes || ['#text', '#comment']; // silent (no warning)\n\t\n\t        // User onTag callback ?\n\t        settings.onTag && this.onTag(settings.onTag, settings.onTagContext);\n\t    }\n\t\n\t    // Load raw XML string, XMLDocument, Element or File object\n\t\n\t\n\t    _createClass(Parser, [{\n\t        key: 'load',\n\t        value: function load(input) {\n\t            // Load raw XML string\n\t            if (typeof input === 'string') {\n\t                return this.loadFromString(input);\n\t            }\n\t\n\t            // Load File object\n\t            if (input instanceof File) {\n\t                return this.loadFromFile(input);\n\t            }\n\t\n\t            // Load XMLDocument object\n\t            if (input instanceof XMLDocument) {\n\t                return this.loadFromXMLDocument(input);\n\t            }\n\t\n\t            // Load Element object\n\t            if (input instanceof Element) {\n\t                return this.loadFromElement(input);\n\t            }\n\t\n\t            // Return rejected promise with an Error object\n\t            return Promise.reject(new Error('Unsupported input format.'));\n\t        }\n\t\n\t        // Load from Element object\n\t\n\t    }, {\n\t        key: 'loadFromElement',\n\t        value: function loadFromElement(input) {\n\t            var _this = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof Element)) {\n\t                    reject(new Error('Input param must be a Element object.'));\n\t                }\n\t\n\t                // Parser error\n\t                if (input.nodeName === 'parsererror') {\n\t                    // FF\n\t                    reject(new Error(input.textContent));\n\t                }\n\t\n\t                if (input.nodeName === 'html' && input.getElementsByTagName('parsererror')) {\n\t                    // Chrome\n\t                    reject(new Error(input.getElementsByTagName('parsererror')[0].textContent));\n\t                }\n\t\n\t                // Set document element\n\t                _this.element = input;\n\t\n\t                // Resolve promise\n\t                resolve(input);\n\t            });\n\t        }\n\t\n\t        // Load from XMLDocument object\n\t\n\t    }, {\n\t        key: 'loadFromXMLDocument',\n\t        value: function loadFromXMLDocument(input) {\n\t            var _this2 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof XMLDocument)) {\n\t                    reject(new Error('Input param must be a XMLDocument object.'));\n\t                }\n\t\n\t                // Load from Element...\n\t                _this2.loadFromElement(input.documentElement).then(resolve).catch(reject);\n\t            });\n\t        }\n\t\n\t        // Load raw XML string\n\t\n\t    }, {\n\t        key: 'loadFromString',\n\t        value: function loadFromString(input) {\n\t            var _this3 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (typeof input !== 'string') {\n\t                    reject(new Error('Input param must be a string.'));\n\t                }\n\t\n\t                // Parse svg editor\n\t                _this3._parseEditor(input);\n\t\n\t                // Parse string as DOM object\n\t                var parser = new DOMParser();\n\t                var XMLDoc = parser.parseFromString(input, 'text/xml');\n\t\n\t                // Load from XMLDocument...\n\t                _this3.loadFromXMLDocument(XMLDoc).then(resolve).catch(reject);\n\t            });\n\t        }\n\t\n\t        // Try to get the svg editor from input string\n\t\n\t    }, {\n\t        key: '_parseEditor',\n\t        value: function _parseEditor(input) {\n\t            // Reset editor\n\t            this.editor = {\n\t                name: 'unknown',\n\t                version: null,\n\t                fingerprint: null\n\t            };\n\t\n\t            // Fingerprint matches\n\t            var fingerprint = void 0;\n\t\n\t            // Inkscape\n\t            fingerprint = input.match(/<!-- Created with Inkscape .*-->/i);\n\t\n\t            if (fingerprint) {\n\t                this.editor.name = 'inkscape';\n\t                this.editor.fingerprint = fingerprint[0];\n\t\n\t                return this.editor;\n\t            }\n\t\n\t            // Illustrator\n\t            fingerprint = input.match(/<!-- Generator: Adobe Illustrator ([0-9\\.]+), .*-->/i);\n\t\n\t            if (fingerprint) {\n\t                this.editor.name = 'illustrator';\n\t                this.editor.version = fingerprint[1];\n\t                this.editor.fingerprint = fingerprint[0];\n\t\n\t                return this.editor;\n\t            }\n\t\n\t            // Return default\n\t            return this.editor;\n\t        }\n\t\n\t        // Load from File object\n\t\n\t    }, {\n\t        key: 'loadFromFile',\n\t        value: function loadFromFile(input) {\n\t            var _this4 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof File)) {\n\t                    reject(new Error('Input param must be a File object.'));\n\t                }\n\t\n\t                // Create file reader\n\t                var reader = new FileReader();\n\t\n\t                // Register reader events handlers\n\t                reader.onload = function (event) {\n\t                    _this4.loadFromString(event.target.result).then(resolve).catch(reject);\n\t                };\n\t\n\t                reader.onerror = function (event) {\n\t                    reject(new Error('Error reading file : ' + input.name));\n\t                };\n\t\n\t                // Finally read input file as text\n\t                reader.readAsText(input);\n\t            });\n\t        }\n\t\n\t        // Parse the (loaded) element\n\t\n\t    }, {\n\t        key: 'parse',\n\t        value: function parse(input) {\n\t            var _this5 = this;\n\t\n\t            // Reset properties\n\t            this.document = null;\n\t            this.defs = {};\n\t            this.tags = null;\n\t\n\t            // Load input if provided\n\t            if (input) {\n\t                return new Promise(function (resolve, reject) {\n\t                    _this5.load(input).then(function () {\n\t                        resolve(_this5.parse());\n\t                    }).catch(reject);\n\t                });\n\t            }\n\t\n\t            // Start parsing element\n\t            return new Promise(function (resolve, reject) {\n\t                // If no element is loaded\n\t                if (!_this5.element) {\n\t                    reject(new Error('No element is loaded, call the load method before.'));\n\t                }\n\t\n\t                // Parse the main Element (recursive)\n\t                _this5.tags = _this5._parseElement(_this5.element);\n\t\n\t                if (!_this5.tags) {\n\t                    reject(new Error('No supported tags found.'));\n\t                }\n\t\n\t                // Apply matrix (recursive)\n\t                _this5.tags.applyMatrix();\n\t\n\t                // Resolve the promise\n\t                resolve(_this5.tags);\n\t            });\n\t        }\n\t\n\t        // On tag callback\n\t\n\t    }, {\n\t        key: '_onTag',\n\t        value: function _onTag(tag) {}\n\t        //console.info('onTag:', tag)\n\t\n\t\n\t        // Register on tag callback\n\t\n\t    }, {\n\t        key: 'onTag',\n\t        value: function onTag(callback, context) {\n\t            var _this6 = this;\n\t\n\t            this._onTag = function (tag) {\n\t                return callback.call(context || _this6, tag);\n\t            };\n\t        }\n\t\n\t        // Parse the provided Element and return an Tag collection (recursive)\n\t\n\t    }, {\n\t        key: '_parseElement',\n\t        value: function _parseElement(element, parent) {\n\t            var _this7 = this;\n\t\n\t            // Create base tag object\n\t            var tag = new _tag.Tag(element, parent);\n\t\n\t            // Exluded tag ?\n\t            if (this.skipTags.indexOf(tag.name) !== -1) {\n\t                return null; // silent\n\t            }\n\t\n\t            // Supported tag ?\n\t            if (this.parseTags.indexOf(tag.name) === -1) {\n\t                return this._skipTag(tag, 'unsupported');\n\t            }\n\t\n\t            // Parse the tag\n\t            var tagParser = new _tagparser.TagParser(tag, this);\n\t\n\t            if (!tagParser.parse()) {\n\t                return false;\n\t            }\n\t\n\t            // Call the on tag callback\n\t            this._onTag(tag);\n\t\n\t            // Parse child nodes\n\t            var childTag = void 0;\n\t\n\t            element.childNodes.forEach(function (childNode) {\n\t                // Parse child element\n\t                if (childTag = _this7._parseElement(childNode, tag)) {\n\t                    tag.addChild(childTag);\n\t                }\n\t            });\n\t\n\t            // Empty group\n\t            if (['svg', 'g'].indexOf(tag.name) !== -1 && !tag.children.length) {\n\t                return this._skipTag(tag, 'empty');\n\t            }\n\t\n\t            // Return tag object\n\t            return tag;\n\t        }\n\t\n\t        // Log skip tag warning message\n\t\n\t    }, {\n\t        key: '_skipTag',\n\t        value: function _skipTag(tag, message) {\n\t            console.warn('Skip tag :', message + ':', tag);\n\t            return false;\n\t        }\n\t\n\t        // Log skip tag attribute warning message\n\t\n\t    }, {\n\t        key: '_skipTagAttr',\n\t        value: function _skipTagAttr(tag, attr, message) {\n\t            console.warn('Skip tag attribute :', message + ':', attr, tag);\n\t            return false;\n\t        }\n\t    }]);\n\t\n\t    return Parser;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Parser = Parser;\n\texports.default = Parser;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Tag = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _path = __webpack_require__(1);\n\t\n\tvar _clipperLib = __webpack_require__(6);\n\t\n\tvar _clipperLib2 = _interopRequireDefault(_clipperLib);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar DEG_TO_RAD = Math.PI / 180;\n\t\n\t// SVG tag class\n\t\n\tvar Tag = function () {\n\t    // Class constructor...\n\t    function Tag(element, parent) {\n\t        var _this = this;\n\t\n\t        _classCallCheck(this, Tag);\n\t\n\t        // Init properties\n\t        this.element = element;\n\t        this.name = element.nodeName.toLowerCase();\n\t        this.parent = parent || null;\n\t        this.layer = null;\n\t        this.attrs = {};\n\t        this.children = [];\n\t        this.paths = [];\n\t        this.matrix = null;\n\t        this.path = new _path.Path();\n\t        this.point = new _path.Point(0, 0);\n\t        this.shapes = [];\n\t\n\t        // Add first path\n\t        this.paths.push(this.path);\n\t\n\t        // Set the matrix\n\t        this.setMatrix(this.parent && this.parent.matrix);\n\t\n\t        // Clone parent attributes\n\t        if (this.parent && (this.parent.name === 'g' || this.parent.name === 'svg')) {\n\t            (function () {\n\t                // Inherit layer name\n\t                _this.layer = _this.parent.layer;\n\t\n\t                // Inherit parent attributes\n\t                var excludes = ['transform', 'width', 'height'];\n\t\n\t                Object.keys(_this.parent.attrs).forEach(function (key) {\n\t                    if (excludes.indexOf(key) === -1) {\n\t                        _this.setAttr(key, _this.parent.attrs[key]);\n\t                    }\n\t                });\n\t            })();\n\t        }\n\t    }\n\t\n\t    _createClass(Tag, [{\n\t        key: 'setAttr',\n\t        value: function setAttr(name, value) {\n\t            this.attrs[name] = value;\n\t        }\n\t    }, {\n\t        key: 'getAttr',\n\t        value: function getAttr(name, defaultValue) {\n\t            return this.attrs[name] !== undefined ? this.attrs[name] : defaultValue !== undefined ? defaultValue : null;\n\t        }\n\t    }, {\n\t        key: 'getLayerName',\n\t        value: function getLayerName() {\n\t            if (this.name === 'g') {\n\t                return this.getAttr('inkscape:label', this.getAttr('id', null));\n\t            }\n\t        }\n\t    }, {\n\t        key: 'setLayerName',\n\t        value: function setLayerName(name) {\n\t            if (this.name === 'g') {\n\t                this.layer = name || this.getLayerName();\n\t            }\n\t        }\n\t    }, {\n\t        key: 'addChild',\n\t        value: function addChild(childTag) {\n\t            this.children.push(childTag);\n\t        }\n\t    }, {\n\t        key: 'clearPath',\n\t        value: function clearPath() {\n\t            this.path = new _path.Path();\n\t        }\n\t    }, {\n\t        key: 'newPath',\n\t        value: function newPath() {\n\t            if (this.path.length > 0) {\n\t                this.clearPath();\n\t                this.paths.push(this.path);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'closePath',\n\t        value: function closePath() {\n\t            return this.path.close();\n\t        }\n\t    }, {\n\t        key: 'addPoint',\n\t        value: function addPoint(x, y, relative) {\n\t            // Relative from the last point\n\t            if (relative) {\n\t                x += this.point.x;\n\t                y += this.point.y;\n\t            }\n\t\n\t            // Add current point\n\t            this.path.addPoint(x, y);\n\t\n\t            // Update current point\n\t            this.point = this.path.getPoint(-1);\n\t        }\n\t    }, {\n\t        key: 'addPoints',\n\t        value: function addPoints(points, relative) {\n\t            // For each couple of points\n\t            for (var i = 0, il = points.length; i < il; i += 2) {\n\t                this.addPoint(points[i], points[i + 1], relative);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'setMatrix',\n\t        value: function setMatrix(matrix) {\n\t            this.matrix = matrix || [1, 0, 0, 1, 0, 0];\n\t        }\n\t    }, {\n\t        key: 'addMatrix',\n\t        value: function addMatrix(matrix) {\n\t            this.matrix = [this.matrix[0] * matrix[0] + this.matrix[2] * matrix[1], this.matrix[1] * matrix[0] + this.matrix[3] * matrix[1], this.matrix[0] * matrix[2] + this.matrix[2] * matrix[3], this.matrix[1] * matrix[2] + this.matrix[3] * matrix[3], this.matrix[0] * matrix[4] + this.matrix[2] * matrix[5] + this.matrix[4], this.matrix[1] * matrix[4] + this.matrix[3] * matrix[5] + this.matrix[5]];\n\t        }\n\t    }, {\n\t        key: 'translate',\n\t        value: function translate(x, y) {\n\t            y = y === undefined ? 0 : y;\n\t            this.addMatrix([1, 0, 0, 1, x, y]);\n\t        }\n\t    }, {\n\t        key: 'rotate',\n\t        value: function rotate(angle, x, y) {\n\t            angle = angle * DEG_TO_RAD;\n\t\n\t            if (arguments.length == 2) {\n\t                this.addMatrix([1, 0, 0, 1, x, y]);\n\t            }\n\t\n\t            this.addMatrix([Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0]);\n\t\n\t            if (arguments.length == 2) {\n\t                this.addMatrix([1, 0, 0, 1, -x, -y]);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'scale',\n\t        value: function scale(x, y) {\n\t            y = y === undefined ? x : y;\n\t            this.addMatrix([x, 0, 0, y, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'skewX',\n\t        value: function skewX(angle) {\n\t            this.addMatrix([1, 0, Math.tan(angle * DEG_TO_RAD), 1, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'skewY',\n\t        value: function skewY(angle) {\n\t            this.addMatrix([1, Math.tan(angle * DEG_TO_RAD), 0, 1, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'applyMatrix',\n\t        value: function applyMatrix(matrix) {\n\t            var _this2 = this;\n\t\n\t            matrix && this.addMatrix(matrix);\n\t\n\t            this.paths.forEach(function (path) {\n\t                path.transform(_this2.matrix);\n\t            });\n\t\n\t            this.shapes.forEach(function (shape) {\n\t                shape.outer.transform(_this2.matrix);\n\t                shape.holes.forEach(function (hole) {\n\t                    hole.transform(_this2.matrix);\n\t                });\n\t            });\n\t\n\t            this.setMatrix(null);\n\t\n\t            this.children.forEach(function (tag) {\n\t                tag.applyMatrix(matrix);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'getPaths',\n\t        value: function getPaths() {\n\t            return this.paths;\n\t        }\n\t    }, {\n\t        key: 'getShapes',\n\t        value: function getShapes() {\n\t            // No shapes...\n\t            if (this.getAttr('fill', 'none') === 'none' || !this.paths[0].length) {\n\t                return this.shapes;\n\t            }\n\t\n\t            // Get fill rule\n\t            var fillRule = this.getAttr('fill-rule', 'nonzero');\n\t            fillRule = fillRule === 'nonzero' ? _clipperLib2.default.PolyFillType.pftNonZero : _clipperLib2.default.PolyFillType.pftEvenOdd;\n\t\n\t            // Create clipper path\n\t            var cPolyTree = new _clipperLib2.default.PolyTree();\n\t            var cClipper = new _clipperLib2.default.Clipper();\n\t            var clipperScale = 10000000;\n\t            var clipperPaths = [];\n\t\n\t            this.paths.forEach(function (path) {\n\t                clipperPaths.push(path.getClipperPoints(clipperScale));\n\t            });\n\t\n\t            cClipper.AddPaths(clipperPaths, _clipperLib2.default.PolyType.ptSubject, true);\n\t            cClipper.Execute(_clipperLib2.default.ClipType.ctUnion, cPolyTree, fillRule, fillRule);\n\t\n\t            var paths = _clipperLib2.default.Clipper.PolyTreeToPaths(cPolyTree);\n\t            var polygones = _clipperLib2.default.Clipper.SimplifyPolygons(paths, fillRule);\n\t\n\t            // Single path (no hole)\n\t            if (this.paths.length > 1) {\n\t                cClipper.Clear();\n\t                cClipper.StrictlySimple = true;\n\t                cPolyTree = new _clipperLib2.default.PolyTree();\n\t                cClipper.AddPaths(polygones, _clipperLib2.default.PolyType.ptSubject, true);\n\t                cClipper.Execute(_clipperLib2.default.ClipType.ctUnion, cPolyTree, fillRule, fillRule);\n\t            }\n\t\n\t            // PolyTree to ExPolygons\n\t            var toPath = function toPath(path) {\n\t                return new _path.Path().fromClipperPoints(path, 1 / clipperScale);\n\t            };\n\t            var exPolygons = _clipperLib2.default.JS.PolyTreeToExPolygons(cPolyTree);\n\t            this.shapes = exPolygons.map(function (exPolygon) {\n\t                return {\n\t                    outer: toPath(exPolygon.outer),\n\t                    holes: exPolygon.holes.map(toPath)\n\t                };\n\t            });\n\t\n\t            // Return shapes...\n\t            return this.shapes;\n\t        }\n\t    }]);\n\t\n\t    return Tag;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Tag = Tag;\n\texports.default = Tag;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.TagParser = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _trace = __webpack_require__(5);\n\t\n\tvar _path2 = __webpack_require__(1);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// SVG tag parser\n\tvar TagParser = function () {\n\t    // Class constructor...\n\t    function TagParser(tag, parser) {\n\t        _classCallCheck(this, TagParser);\n\t\n\t        // Init properties\n\t        this.tag = tag;\n\t        this.parser = parser;\n\t        this.currentCommand = null;\n\t        this.lastCommand = null;\n\t        this.pathData = null;\n\t        this.traceSettings = parser.traceSettings;\n\t    }\n\t\n\t    _createClass(TagParser, [{\n\t        key: 'parse',\n\t        value: function parse() {\n\t            // Get internal parser from node name\n\t            var handler = this['_' + this.tag.name];\n\t\n\t            // Implemented tag handler?\n\t            if (!handler || typeof handler !== 'function') {\n\t                return this.parser._skipTag(this.tag, 'not yet implemented');\n\t            }\n\t\n\t            // Parse tag attributes\n\t            this._parseTagAttrs();\n\t\n\t            // Parse tag\n\t            return handler.call(this);\n\t        }\n\t\n\t        // Parse the tag attributes\n\t\n\t    }, {\n\t        key: '_parseTagAttrs',\n\t        value: function _parseTagAttrs() {\n\t            var _this = this;\n\t\n\t            // Get tag attributes\n\t            var attrs = this.tag.element.attributes;\n\t\n\t            if (!attrs) {\n\t                return null;\n\t            }\n\t\n\t            // For each attribute\n\t            var attr = void 0,\n\t                value = void 0,\n\t                style = void 0;\n\t\n\t            Object.keys(attrs).some(function (key) {\n\t                // Current attribute\n\t                attr = attrs[key];\n\t\n\t                // Normalize attribute value\n\t                value = _this._normalizeTagAttr(attr);\n\t\n\t                if (value === false) {\n\t                    return false; // continue\n\t                }\n\t\n\t                // Special case\n\t                if (attr.nodeName === 'style') {\n\t                    style = value;\n\t                } else {\n\t                    // Set new attribute name/value\n\t                    _this.tag.setAttr(attr.nodeName, value);\n\t                }\n\t            });\n\t\n\t            // If style attribute (override tag attributes)\n\t            // TODO get/parse global style and override this one...\n\t            style && style.replace(/;$/, '').split(';').some(function (attr) {\n\t                // Current style\n\t                attr = attr.split(':');\n\t                attr = { nodeName: attr[0], nodeValue: attr[1] };\n\t\n\t                // Normalize attribute value\n\t                value = _this._normalizeTagAttr(attr);\n\t\n\t                if (value === false) {\n\t                    return false; // continue\n\t                }\n\t\n\t                // Set new attribute name/value\n\t                _this.tag.setAttr(attr.nodeName, value);\n\t            });\n\t\n\t            // Set inherited color\n\t            var colorsAttrs = ['fill', 'stroke', 'color'];\n\t\n\t            colorsAttrs.forEach(function (attrName) {\n\t                if (_this.tag.getAttr(attrName) === 'inherit') {\n\t                    _this.tag.setAttr(attrName, _this.tag.parent.getAttr(attrName, 'none'));\n\t                }\n\t            });\n\t\n\t            // Parse viewBox attribute\n\t            this._parseViewBoxAttr();\n\t\n\t            // Parse transform attribute\n\t            this._parseTransformAttr();\n\t        }\n\t\n\t        // Normalize tag attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttr',\n\t        value: function _normalizeTagAttr(attr) {\n\t            // Normalize whitespaces\n\t            var value = attr.nodeValue.replace(/(\\r?\\n|\\r)+/gm, ' ') // Remove all new line chars\n\t            .replace(/\\s+/gm, ' ') // Reduce multiple whitespaces\n\t            .trim(); // Remove trailing whitespaces\n\t\n\t            if (!value.length) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'empty');\n\t            }\n\t\n\t            // Filters\n\t            switch (attr.nodeName) {\n\t                // Normalize size unit -> to px\n\t                case 'x':\n\t                case 'y':\n\t                case 'x1':\n\t                case 'y1':\n\t                case 'x2':\n\t                case 'y2':\n\t                case 'r':\n\t                case 'rx':\n\t                case 'ry':\n\t                case 'cx':\n\t                case 'cy':\n\t                case 'width':\n\t                case 'height':\n\t                case 'fontSize':\n\t                case 'strokeWidth':\n\t                    value = this._normalizeTagAttrUnit(attr);\n\t                    break;\n\t\n\t                // Normalize points attribute\n\t                case 'points':\n\t                case 'viewBox':\n\t                    value = this._normalizeTagAttrPoints(attr);\n\t                    break;\n\t\n\t                // Range limit to [0 - 1]\n\t                case 'opacity':\n\t                case 'fillOpacity':\n\t                case 'strokeOpacity':\n\t                    value = this._normalizeTagAttrRange(attr, 0, 1);\n\t                    break;\n\t\n\t                case 'preserveAspectRatio':\n\t                    value = this._normalizeTagAttrPreserveAspectRatio(attr);\n\t                    break;\n\t            }\n\t\n\t            // Return normalized value\n\t            return value;\n\t        }\n\t\n\t        // Normalize attribute unit to px\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrUnit',\n\t        value: function _normalizeTagAttrUnit(attr) {\n\t            var stringValue = attr.nodeValue.toLowerCase();\n\t            var floatValue = parseFloat(stringValue);\n\t\n\t            if (isNaN(floatValue)) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric value allowed');\n\t            }\n\t\n\t            if (stringValue.indexOf('mm') !== -1) {\n\t                return floatValue * 3.5433070869;\n\t            }\n\t\n\t            if (stringValue.indexOf('cm') !== -1) {\n\t                return floatValue * 35.433070869;\n\t            }\n\t\n\t            if (stringValue.indexOf('in') !== -1) {\n\t                return floatValue * 90.0;\n\t            }\n\t\n\t            if (stringValue.indexOf('pt') !== -1) {\n\t                return floatValue * 1.25;\n\t            }\n\t\n\t            if (stringValue.indexOf('pc') !== -1) {\n\t                return floatValue * 15.0;\n\t            }\n\t\n\t            return floatValue;\n\t        }\n\t\n\t        // Normalize points attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrPoints',\n\t        value: function _normalizeTagAttrPoints(attr) {\n\t            var points = this._parseNumbers(attr.nodeValue);\n\t\n\t            if (points === false) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed');\n\t            }\n\t\n\t            if (!points.length) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'empty points list');\n\t            }\n\t\n\t            if (points.length % 0) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'the number of points must be even');\n\t            }\n\t\n\t            return points;\n\t        }\n\t\n\t        // Normalize range attribute like \"opacity\"\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrRange',\n\t        value: function _normalizeTagAttrRange(attr, min, max) {\n\t            var stringValue = attr.nodeValue.trim();\n\t            var floatValue = parseFloat(stringValue);\n\t\n\t            if (isNaN(floatValue)) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed');\n\t            }\n\t\n\t            if (floatValue < min || floatValue > max) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'out of range [' + min + ', ' + max + ']');\n\t            }\n\t\n\t            return floatValue;\n\t        }\n\t\n\t        // Parse points string as numbers array\n\t\n\t    }, {\n\t        key: '_parseNumbers',\n\t        value: function _parseNumbers(points) {\n\t            // http://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly\n\t            if (typeof points === 'string') {\n\t                points = points.split(/([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/g).filter(function (point) {\n\t                    return point && ['', ','].indexOf(point.trim()) === -1;\n\t                });\n\t            }\n\t\n\t            // Normalize to float values\n\t            points = points.map(parseFloat);\n\t\n\t            // Test if all numbers is valid\n\t            if (points.some(isNaN)) {\n\t                return false;\n\t            }\n\t\n\t            return points;\n\t        }\n\t\n\t        // Normalize the preserveAspectRatio attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrPreserveAspectRatio',\n\t        value: function _normalizeTagAttrPreserveAspectRatio(attr) {\n\t            var params = {\n\t                defer: false,\n\t                align: 'none',\n\t                meet: true,\n\t                slice: false\n\t            };\n\t\n\t            var rawParams = attr.nodeValue;\n\t\n\t            if (rawParams.indexOf('defer') === 0) {\n\t                rawParams = rawParams.substr(6);\n\t                params.defer = true;\n\t            }\n\t\n\t            rawParams = rawParams.split(' ');\n\t            params.align = rawParams[0];\n\t            params.meet = rawParams[1] || 'meet';\n\t            params.meet = params.meet === 'meet';\n\t            params.slice = !params.meet;\n\t\n\t            return params;\n\t        }\n\t\n\t        // Parse viewBox attribute and set transformations\n\t\n\t    }, {\n\t        key: '_parseViewBoxAttr',\n\t        value: function _parseViewBoxAttr() {\n\t            // Get viewBox attribute\n\t            var viewBox = this.tag.getAttr('viewBox', null);\n\t\n\t            // No viewBox...\n\t            if (viewBox === null) {\n\t                return null;\n\t            }\n\t\n\t            // Update size attributes\n\t            var width = this.tag.getAttr('width', viewBox[2]);\n\t            var height = this.tag.getAttr('height', viewBox[3]);\n\t\n\t            this.tag.setAttr('width', width);\n\t            this.tag.setAttr('height', height);\n\t\n\t            // Scale to match viewBox\n\t            // TODO clip path if preserveAspectRatio.slice\n\t            var scaleX = width / viewBox[2];\n\t            var scaleY = height / viewBox[3];\n\t            var translateX = viewBox[0];\n\t            var translateY = viewBox[1];\n\t\n\t            var preserveAspectRatio = this.tag.getAttr('preserveAspectRatio', 'meet xMidYMid');\n\t\n\t            if (preserveAspectRatio) {\n\t                var newWidth = void 0,\n\t                    newHeight = void 0;\n\t\n\t                if (preserveAspectRatio.meet) {\n\t                    if (scaleX > scaleY) {\n\t                        scaleX = scaleY;\n\t                        newWidth = viewBox[2] * scaleX;\n\t                    } else if (scaleX < scaleY) {\n\t                        scaleY = scaleX;\n\t                        newHeight = viewBox[3] * scaleY;\n\t                    }\n\t                } else if (preserveAspectRatio.slice) {\n\t                    if (scaleX < scaleY) {\n\t                        scaleX = scaleY;\n\t                        newWidth = viewBox[2] * scaleX;\n\t                    } else if (scaleX > scaleY) {\n\t                        scaleY = scaleX;\n\t                        newHeight = viewBox[3] * scaleY;\n\t                    }\n\t                }\n\t\n\t                if (newWidth !== undefined) {\n\t                    if (preserveAspectRatio.align === 'xMidYMid') {\n\t                        this.tag.translate((width - newWidth) / 2, 0);\n\t                    } else if (preserveAspectRatio.align === 'xMaxYMax') {\n\t                        this.tag.translate(width - newWidth, 0);\n\t                    }\n\t                } else if (newHeight !== undefined) {\n\t                    if (preserveAspectRatio.align === 'xMidYMid') {\n\t                        this.tag.translate(0, (height - newHeight) / 2);\n\t                    } else if (preserveAspectRatio.align === 'xMaxYMax') {\n\t                        this.tag.translate(0, height - newHeight);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.tag.scale(scaleX, scaleY);\n\t            this.tag.translate(-translateX, -translateY);\n\t        }\n\t\n\t        // Parse transform attribute and set transformations\n\t\n\t    }, {\n\t        key: '_parseTransformAttr',\n\t        value: function _parseTransformAttr() {\n\t            var _this2 = this;\n\t\n\t            // Get transform attribute\n\t            var transformAttr = this.tag.getAttr('transform', null);\n\t\n\t            // No transformation...\n\t            if (transformAttr === null || !transformAttr.length) {\n\t                return null;\n\t            }\n\t\n\t            // Parse attribute (split group on closing parenthesis)\n\t            var transformations = transformAttr.split(')');\n\t\n\t            // Remove last entry due to last \")\" found\n\t            transformations.pop();\n\t\n\t            // For each transformation\n\t            var transform = void 0,\n\t                type = void 0,\n\t                params = void 0;\n\t\n\t            transformations.some(function (raw) {\n\t                // Split name and value on opening parenthesis\n\t                transform = raw.split('(');\n\t\n\t                // Invalid parts number\n\t                if (transform.length !== 2) {\n\t                    return _this2.parser._skipTagAttr(_this2.tag, transformAttr, 'malformed'); // continue\n\t                }\n\t\n\t                type = transform[0].trim();\n\t\n\t                // Quik hack 1/2\n\t                var func = type;\n\t                if (func === 'matrix') {\n\t                    func = 'addMatrix';\n\t                }\n\t\n\t                // Get tag transform method\n\t                var tagTransform = _this2.tag[func];\n\t\n\t                if (typeof tagTransform !== 'function') {\n\t                    return _this2.parser._skipTagAttr(_this2.tag, transformAttr, 'unsupported transform type :' + type);\n\t                }\n\t\n\t                params = transform[1].trim();\n\t                params = _this2._parseNumbers(params);\n\t\n\t                // Skip empty value\n\t                if (!params.length) {\n\t                    return _this2.parser._skipTagAttr(_this2.tag, transformAttr, 'malformed transform type :' + type);\n\t                }\n\t\n\t                // Quik hack 2/2\n\t                if (func == 'addMatrix') {\n\t                    params = [params];\n\t                }\n\t\n\t                // Call tag transform method like \"tag.translate(param1, ..., paramN)\"\n\t                tagTransform.apply(_this2.tag, params);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_newPath',\n\t        value: function _newPath() {\n\t            this.tag.newPath();\n\t        }\n\t    }, {\n\t        key: '_clearPath',\n\t        value: function _clearPath() {\n\t            this.tag.clearPath();\n\t        }\n\t    }, {\n\t        key: '_closePath',\n\t        value: function _closePath() {\n\t            return this.tag.closePath();\n\t        }\n\t    }, {\n\t        key: '_addPoints',\n\t        value: function _addPoints(points, relative) {\n\t            if (!points.length) {\n\t                return this.parser._skipTag(this.tag, 'empty points list');\n\t            }\n\t\n\t            if (points.length % 0) {\n\t                return this.parser._skipTag(this.tag, 'the number of points must be even');\n\t            }\n\t\n\t            relative = arguments.length < 2 && this.currentCommand.relative;\n\t\n\t            this.tag.addPoints(points, relative);\n\t            return true;\n\t        }\n\t\n\t        // SVG specs at https://www.w3.org/TR/SVG11/\n\t\n\t    }, {\n\t        key: '_svg',\n\t        value: function _svg() {\n\t            // Only parse the root SVG tag as main document\n\t            if (this.parser.document) {\n\t                // Handled tag\n\t                return true;\n\t            }\n\t\n\t            // Get the document size\n\t            var width = this.tag.getAttr('width');\n\t            var height = this.tag.getAttr('height');\n\t\n\t            // Invalid size\n\t            if (!width || width < 0 || !height || height < 0) {\n\t                throw new Error('Invalid document size: ' + width + ' / ' + height);\n\t            }\n\t\n\t            // Set document size\n\t            this.parser.document = {\n\t                width: width,\n\t                height: height\n\t            };\n\t\n\t            // Get document viewBox or set default to document size\n\t            var viewBox = this.tag.getAttr('viewBox', [0, 0, width, height]);\n\t\n\t            this.parser.document.viewBox = {\n\t                x: viewBox[0],\n\t                y: viewBox[1],\n\t                width: viewBox[2],\n\t                height: viewBox[3]\n\t            };\n\t\n\t            // Check inkscape version\n\t            if (this.parser.editor.name === 'inkscape') {\n\t                this.parser.editor.version = this.tag.getAttr('inkscape:version');\n\t            }\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_title',\n\t        value: function _title() {\n\t            // Register the first encountered title tag as document title\n\t            if (this.parser.document && !this.parser.document.title) {\n\t                this.parser.document.title = this.tag.element.textContent;\n\t            }\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_desc',\n\t        value: function _desc() {\n\t            // Register the first encountered desc tag as document description\n\t            if (this.parser.document && !this.parser.document.description) {\n\t                this.parser.document.description = this.tag.element.textContent;\n\t            }\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_defs',\n\t        value: function _defs() {\n\t            var _this3 = this;\n\t\n\t            // Register all child element with an id attribute\n\t            this.tag.element.childNodes.forEach(function (childNode) {\n\t                childNode.id && (_this3.parser.defs[childNode.id] = childNode);\n\t            });\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_use',\n\t        value: function _use() {\n\t            // Get the target id\n\t            var target = this.tag.getAttr('xlink:href').replace(/^#/, '');\n\t\n\t            // Try to get the defined element\n\t            var element = this.parser.defs[target];\n\t\n\t            if (!element) {\n\t                return this.parser._skipTag(this.tag, 'undefined reference [' + target + ']');\n\t            }\n\t\n\t            // Parse the defined element and set new parent from <use> tag parent\n\t            var useTag = this.parser._parseElement(element, this.tag.parent);\n\t\n\t            if (!useTag) {\n\t                return this.parser._skipTag(this.tag, 'empty reference [' + target + ']');\n\t            }\n\t\n\t            // Set matrix from real parent (<use>)\n\t            useTag.setMatrix(this.tag.matrix);\n\t\n\t            // Replace the use tag with new one\n\t            this.tag.parent.addChild(useTag);\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_g',\n\t        value: function _g() {\n\t            // Set the tag layer name\n\t            this.tag.setLayerName();\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_line',\n\t        value: function _line() {\n\t            // Handled tag\n\t            return this._path(['M', this.tag.getAttr('x1'), this.tag.getAttr('y1'), 'L', this.tag.getAttr('x2'), this.tag.getAttr('y2')]);\n\t        }\n\t    }, {\n\t        key: '_polyline',\n\t        value: function _polyline() {\n\t            var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t            var points = this.tag.getAttr('points');\n\t            var path = ['M', points.shift(), points.shift(), 'L'];\n\t\n\t            path = path.concat(points);\n\t            close && path.push('Z');\n\t\n\t            // Handled tag\n\t            return this._path(path);\n\t        }\n\t    }, {\n\t        key: '_polygon',\n\t        value: function _polygon() {\n\t            // Handled like polyline but closed\n\t            return this._polyline(true);\n\t        }\n\t    }, {\n\t        key: '_rect',\n\t        value: function _rect() {\n\t            // Get rectangle attributes\n\t            var w = this.tag.getAttr('width');\n\t            var h = this.tag.getAttr('height');\n\t            var x = this.tag.getAttr('x', 0);\n\t            var y = this.tag.getAttr('y', 0);\n\t            var rx = this.tag.getAttr('rx', null);\n\t            var ry = this.tag.getAttr('ry', null);\n\t\n\t            // Simple rect\n\t            if (!rx && !ry) {\n\t                // Handled tag\n\t                return this._path(['M', x, y, 'h', w, 'v', h, 'h', -w, 'z']);\n\t            }\n\t\n\t            // If a properly specified value is provided for ‘rx’, but not for ‘ry’,\n\t            // then set both rx and ry to the value of ‘rx’ and vis-vera...\n\t            if (rx === null) rx = ry;\n\t            if (ry === null) ry = rx;\n\t\n\t            // A negative value is an error\n\t            if (rx === null || rx === null || rx < 0 || ry < 0) {\n\t                // Skip tag\n\t                return this.parser._skipTag(this.tag, 'negative value for \"rx/ry\" not allowed');\n\t            }\n\t\n\t            // If rx is greater than half of ‘width’, then set rx to half of ‘width’.\n\t            // If ry is greater than half of ‘height’, then set ry to half of ‘height’.\n\t            if (rx > w / 2) rx = w / 2;\n\t            if (ry > h / 2) ry = h / 2;\n\t\n\t            var dx = rx * 2;\n\t            var dy = ry * 2;\n\t\n\t            // Handled tag\n\t            return this._path(['M', x + rx, y, 'h', w - dx, 'c', rx, 0, rx, ry, rx, ry, 'v', h - dy, 'c', 0, ry, -rx, ry, -rx, ry, 'h', -w + dx, 'c', -rx, 0, -rx, -ry, -rx, -ry, 'v', -h + dy, 'c', 0, 0, 0, -ry, rx, -ry, 'z']);\n\t        }\n\t    }, {\n\t        key: '_circle',\n\t        value: function _circle() {\n\t            var r = this.tag.getAttr('r', 0);\n\t\n\t            if (r <= 0) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            var cx = this.tag.getAttr('cx', 0);\n\t            var cy = this.tag.getAttr('cy', 0);\n\t\n\t            // Handled tag\n\t            return this._path(['M', cx - r, cy, 'A', r, r, 0, 0, 0, cx, cy + r, 'A', r, r, 0, 0, 0, cx + r, cy, 'A', r, r, 0, 0, 0, cx, cy - r, 'A', r, r, 0, 0, 0, cx - r, cy, 'Z']);\n\t        }\n\t    }, {\n\t        key: '_ellipse',\n\t        value: function _ellipse() {\n\t            var rx = this.tag.getAttr('rx', 0);\n\t            var ry = this.tag.getAttr('ry', 0);\n\t\n\t            if (rx <= 0 || ry <= 0) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            var cx = this.tag.getAttr('cx', 0);\n\t            var cy = this.tag.getAttr('cy', 0);\n\t\n\t            // Handled tag\n\t            return this._path(['M', cx - rx, cy, 'A', rx, ry, 0, 0, 0, cx, cy + ry, 'A', rx, ry, 0, 0, 0, cx + rx, cy, 'A', rx, ry, 0, 0, 0, cx, cy - ry, 'A', rx, ry, 0, 0, 0, cx - rx, cy, 'Z']);\n\t        }\n\t    }, {\n\t        key: '_paths',\n\t        value: function _paths(type, num, points) {\n\t            if (points.length > num) {\n\t                var handler = void 0,\n\t                    result = true;\n\t\n\t                while (result && points.length) {\n\t                    handler = this['_path' + type];\n\t                    result = handler.call(this, points.splice(0, num));\n\t                }\n\t\n\t                return result;\n\t            }\n\t\n\t            return null;\n\t        }\n\t    }, {\n\t        key: '_path',\n\t        value: function _path(path) {\n\t            var _this4 = this;\n\t\n\t            // Provided path\n\t            if (path && typeof path !== 'string') {\n\t                path = path.join(' ');\n\t            }\n\t\n\t            // Get the paths data attribute value\n\t            var dAttr = path || this.tag.getAttr('d', null);\n\t\n\t            if (!dAttr) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            // Split on each commands\n\t            var commands = dAttr.match(/([M|Z|L|H|V|C|S|Q|T|A]+([^M|Z|L|H|V|C|S|Q|T|A]+)?)/gi);\n\t\n\t            if (!commands) {\n\t                return this.parser._skipTag(this.tag, 'malformed \"d\" attribute');\n\t            }\n\t\n\t            // For each command...\n\t            this.currentCommand = {\n\t                raw: null,\n\t                type: null,\n\t                params: null,\n\t                relative: null\n\t            };\n\t            this.lastCommand = this.currentCommand;\n\t            this.pathData = {};\n\t\n\t            var handler = null;\n\t            var parseError = false;\n\t\n\t            commands.some(function (raw) {\n\t                // Remove trailing whitespaces\n\t                raw = raw.trim();\n\t\n\t                // Extract command char and params\n\t                _this4.currentCommand.raw = raw;\n\t                _this4.currentCommand.type = raw[0].toUpperCase();\n\t                _this4.currentCommand.params = raw.substr(1).trim();\n\t                _this4.currentCommand.relative = _this4.currentCommand.type !== raw[0];\n\t\n\t                // Get path handler from command char\n\t                handler = _this4['_path' + _this4.currentCommand.type];\n\t\n\t                if (!handler || typeof handler !== 'function') {\n\t                    _this4.parser._skipTag(_this4.tag, 'unsupported path command [' + raw[0] + ']');\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Extract all numbers from arguments string\n\t                _this4.currentCommand.params = _this4._parseNumbers(_this4.currentCommand.params);\n\t\n\t                if (_this4.currentCommand.params === false) {\n\t                    _this4.parser._skipTag(_this4.tag, 'only numeric values are allowed in [' + _this4.currentCommand.raw + ']');\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Execute command parser\n\t                if (!handler.call(_this4, _this4.currentCommand.params)) {\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Update last command\n\t                _this4.lastCommand = {};\n\t\n\t                Object.keys(_this4.currentCommand).forEach(function (key) {\n\t                    _this4.lastCommand[key] = _this4.currentCommand[key];\n\t                });\n\t            });\n\t\n\t            // Skip tag\n\t            if (parseError) {\n\t                this._clearPath();\n\t                return false;\n\t            }\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_pathM',\n\t        value: function _pathM(points) {\n\t            // New path\n\t            this._newPath();\n\t\n\t            // Set the current point (start of new path)\n\t            // If is followed by multiple pairs of coordinates,\n\t            // the subsequent pairs are treated as implicit lineto commands.\n\t            return this._addPoints(points);\n\t        }\n\t    }, {\n\t        key: '_pathZ',\n\t        value: function _pathZ() {\n\t            this._closePath();\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_pathL',\n\t        value: function _pathL(points) {\n\t            return this._addPoints(points);\n\t        }\n\t    }, {\n\t        key: '_pathH',\n\t        value: function _pathH(points) {\n\t            var _this5 = this;\n\t\n\t            return points.every(function (x) {\n\t                return _this5._addPoints([x, _this5.currentCommand.relative ? 0 : _this5.tag.point.y]);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_pathV',\n\t        value: function _pathV(points) {\n\t            var _this6 = this;\n\t\n\t            return points.every(function (y) {\n\t                return _this6._addPoints([_this6.currentCommand.relative ? 0 : _this6.tag.point.x, y]);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_pathC',\n\t        value: function _pathC(points) {\n\t            // Multiple paths\n\t            var result = this._paths('C', 6, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = points[0] + (rl ? p1.x : 0);\n\t            var y1 = points[1] + (rl ? p1.y : 0);\n\t            var x2 = points[2] + (rl ? p1.x : 0);\n\t            var y2 = points[3] + (rl ? p1.y : 0);\n\t            var x = points[4] + (rl ? p1.x : 0);\n\t            var y = points[5] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x2 = x2;\n\t            this.pathData.y2 = y2;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x2, y2);\n\t            var p4 = new _path2.Point(x, y);\n\t\n\t            //console.log('C', p1, p2, p3, p4)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : control point\n\t            // p4  : end point\n\t            var tracer = new _trace.CubicBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3, p4: p4 }); // => [x,y, x,y, ...]\n\t            // let tracer = trace(CubicBezier, this.traceSettings)\n\t            // let coords = tracer({ p1, p2, p3, p4 })\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathS',\n\t        value: function _pathS(points) {\n\t            // Multiple paths\n\t            var result = this._paths('S', 4, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = p1.x;\n\t            var y1 = p1.y;\n\t\n\t            if (this.lastCommand.type === 'S' || this.lastCommand.type === 'C') {\n\t                x1 -= this.pathData.x2 - x1;\n\t                y1 -= this.pathData.y2 - y1;\n\t            }\n\t\n\t            var x2 = points[0] + (rl ? p1.x : 0);\n\t            var y2 = points[1] + (rl ? p1.y : 0);\n\t            var x = points[2] + (rl ? p1.x : 0);\n\t            var y = points[3] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x2 = x2;\n\t            this.pathData.y2 = y2;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x2, y2);\n\t            var p4 = new _path2.Point(x, y);\n\t\n\t            //console.log('S', p1, p2, p3, p4)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : control point\n\t            // p4  : end point\n\t            var tracer = new _trace.CubicBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3, p4: p4 }); // => [x,y, x,y, ...]\n\t            // let tracer = trace(CubicBezier, this.traceSettings)\n\t            // let coords = tracer({ p1, p2, p3, p4 })\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathQ',\n\t        value: function _pathQ(points) {\n\t            // Multiple paths\n\t            var result = this._paths('Q', 4, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = points[0] + (rl ? p1.x : 0);\n\t            var y1 = points[1] + (rl ? p1.y : 0);\n\t            var x = points[2] + (rl ? p1.x : 0);\n\t            var y = points[3] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x1 = x1;\n\t            this.pathData.y1 = y1;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x, y);\n\t\n\t            //console.log('Q', p1, p2, p3)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : end point\n\t            var tracer = new _trace.QuadricBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathT',\n\t        value: function _pathT(points) {\n\t            // Multiple paths\n\t            var result = this._paths('T', 2, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = p1.x;\n\t            var y1 = p1.y;\n\t\n\t            if (this.lastCommand.type === 'Q' || this.lastCommand.type === 'T') {\n\t                x1 -= this.pathData.x1 - x1;\n\t                y1 -= this.pathData.y1 - y1;\n\t            }\n\t\n\t            var x = points[0] + (rl ? p1.x : 0);\n\t            var y = points[1] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x1 = x1;\n\t            this.pathData.y1 = y1;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x, y);\n\t\n\t            //console.log('T', p1, p2, p3)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : end point\n\t            var tracer = new _trace.QuadricBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathA',\n\t        value: function _pathA(points) {\n\t            // Multiple paths\n\t            var result = this._paths('A', 7, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var rl = this.currentCommand.relative;\n\t            var p1 = this.tag.point;\n\t            var rx = points[0];\n\t            var ry = points[1];\n\t            var angle = points[2];\n\t            var large = !!points[3];\n\t            var sweep = !!points[4];\n\t            var x = points[5] + (rl ? p1.x : 0);\n\t            var y = points[6] + (rl ? p1.y : 0);\n\t            var p2 = new _path2.Point(x, y);\n\t\n\t            //console.log('A', p1, rx, ry, angle, large, sweep, p2)\n\t\n\t            var tracer = new _trace.Arc(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, rx: rx, ry: ry, angle: angle, large: large, sweep: sweep, p2: p2 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }]);\n\t\n\t    return TagParser;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.TagParser = TagParser;\n\texports.default = TagParser;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.QuadricBezier = exports.CubicBezier = exports.Arc = undefined;\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Base code from : https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js\n\t\n\t\n\tvar _path = __webpack_require__(1);\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar MATH_PI_2 = Math.PI * 2;\n\tvar DEG_TO_RAD = Math.PI / 180;\n\t\n\tfunction mod(x, m) {\n\t    return (x % m + m) % m;\n\t}\n\t\n\tfunction clamp(val, min, max) {\n\t    return Math.min(Math.max(val, min), max);\n\t}\n\t\n\tfunction distance(p0, p1) {\n\t    return Math.sqrt(Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2));\n\t}\n\t\n\tfunction angle(v0, v1) {\n\t    var p = v0.x * v1.x + v0.y * v1.y;\n\t    var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));\n\t    return (v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1) * Math.acos(p / n);\n\t}\n\t\n\t// Abstract class\n\t\n\tvar TraceBase = function () {\n\t    function TraceBase(settings) {\n\t        _classCallCheck(this, TraceBase);\n\t\n\t        // Set defaults properties\n\t        this.path = []; // Points collection [x,y, x,y, ...]\n\t        this.linear = true; // Linear trace mode\n\t        this.step = 0.01; // Step resolution if linear mode = false\n\t        this.resolution = 500; // Number of segments we use to approximate arc length\n\t        this.segmentLength = 0.1; // Segment length\n\t\n\t        // Update properties from user settings\n\t        Object.assign(this, settings || {});\n\t\n\t        // Arc length properties\n\t        this.arcLength = null;\n\t        this.arcLengthMap = null;\n\t    }\n\t\n\t    _createClass(TraceBase, [{\n\t        key: '_clearPath',\n\t        value: function _clearPath() {\n\t            this.path = [];\n\t        }\n\t    }, {\n\t        key: 'getPath',\n\t        value: function getPath() {\n\t            return this.path;\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            return new _path.Point(0, 0);\n\t        }\n\t    }, {\n\t        key: '_addPoint',\n\t        value: function _addPoint(point) {\n\t            this.path.push(point.x, point.y);\n\t        }\n\t    }, {\n\t        key: '_postTrace',\n\t        value: function _postTrace() {\n\t            // Do additional tasks\n\t        }\n\t    }, {\n\t        key: '_approximateLength',\n\t        value: function _approximateLength() {\n\t            var arcLength = 0;\n\t            var arcLengthMap = [];\n\t            var prevPoint = this.getPointAtT(0);\n\t\n\t            var i = void 0,\n\t                t = void 0,\n\t                nextPoint = void 0;\n\t\n\t            for (i = 0; i < this.resolution; i++) {\n\t                t = clamp(i * (1 / this.resolution), 0, 1);\n\t                nextPoint = this.getPointAtT(t);\n\t                arcLength += distance(prevPoint, nextPoint);\n\t\n\t                arcLengthMap.push({ t: t, arcLength: arcLength });\n\t\n\t                prevPoint = nextPoint;\n\t            }\n\t\n\t            // Last stretch to the endpoint\n\t            nextPoint = this.getPointAtT(1);\n\t            arcLength += distance(prevPoint, nextPoint);\n\t\n\t            arcLengthMap.push({ t: 1, arcLength: arcLength });\n\t            Object.assign(this, { arcLength: arcLength, arcLengthMap: arcLengthMap });\n\t        }\n\t    }, {\n\t        key: 'getPointAtU',\n\t        value: function getPointAtU(u) {\n\t            u = clamp(u, 0, 1);\n\t\n\t            var targetDistanceFromStartingPoint = u * this.arcLength;\n\t\n\t            var resultantT = 0;\n\t            var prevArcLength = 0;\n\t            var prevT = 0;\n\t\n\t            this.arcLengthMap.every(function (entry) {\n\t                var t = entry.t;\n\t                var arcLength = entry.arcLength;\n\t\n\t                // Once we go a past our target\n\t                // Lets interpolate from a previous to current\n\t                if (arcLength >= targetDistanceFromStartingPoint) {\n\t                    var endDiff = arcLength - targetDistanceFromStartingPoint;\n\t                    var startDiff = targetDistanceFromStartingPoint - prevArcLength;\n\t                    var linearFactor = startDiff / (endDiff + startDiff) || 0;\n\t\n\t                    resultantT = prevT + (t - prevT) * linearFactor;\n\t\n\t                    // Break\n\t                    return false;\n\t                }\n\t\n\t                prevArcLength = arcLength;\n\t                prevT = t;\n\t\n\t                return true;\n\t            });\n\t\n\t            return this.getPointAtT(resultantT);\n\t        }\n\t    }, {\n\t        key: 'trace',\n\t        value: function trace(settings) {\n\t            // Update properties from user settings\n\t            Object.assign(this, settings || {});\n\t\n\t            // Default getPoint settings\n\t            var getPoint = 'getPointAtT';\n\t            var step = this.step;\n\t\n\t            // Linear mode ?\n\t            if (this.linear) {\n\t                this._approximateLength();\n\t\n\t                var segments = Math.round(this.arcLength / this.segmentLength);\n\t\n\t                getPoint = 'getPointAtU';\n\t                step = 1 / segments;\n\t            }\n\t\n\t            // Clear points list\n\t            this._clearPath();\n\t\n\t            // Trace the path\n\t            for (var t = 0; t <= 1; t += step) {\n\t                this._addPoint(this[getPoint](t));\n\t            }\n\t\n\t            // Do additional tasks\n\t            this._postTrace();\n\t\n\t            // Return the path\n\t            return this.getPath();\n\t        }\n\t    }]);\n\t\n\t    return TraceBase;\n\t}();\n\t\n\t// Rewrite from https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js#L84\n\t\n\t\n\tvar Arc = function (_TraceBase) {\n\t    _inherits(Arc, _TraceBase);\n\t\n\t    function Arc() {\n\t        _classCallCheck(this, Arc);\n\t\n\t        return _possibleConstructorReturn(this, (Arc.__proto__ || Object.getPrototypeOf(Arc)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(Arc, [{\n\t        key: 'init',\n\t        value: function init(settings) {\n\t            // Update properties from user settings\n\t            Object.assign(this, settings || {});\n\t\n\t            // Get angle in radians\n\t            this.radians = mod(this.angle, 360) * DEG_TO_RAD;\n\t\n\t            // If the endpoints are identical, then this is equivalent\n\t            // to omitting the elliptical arc segment entirely.\n\t            if (this.p1.x === this.p2.x && this.p1.y === this.p2.y) {\n\t                return this.path;\n\t            }\n\t\n\t            this.rx = Math.abs(this.rx);\n\t            this.ry = Math.abs(this.ry);\n\t\n\t            // If rx = 0 or ry = 0 then this arc is treated as\n\t            // a straight line segment joining the endpoints.\n\t            if (this.rx === 0 || this.ry === 0) {\n\t                this.__addPoint(this.p1);\n\t                this.__addPoint(this.p2);\n\t                return this.path;\n\t            }\n\t\n\t            // Following \"Conversion from endpoint to center parameterization\"\n\t            // http://www.w3.org/TR/SVG/implnote.html#ArcConversionEndpointToCenter\n\t\n\t            // Step #1: Compute transformedPoint\n\t            var dx = (this.p1.x - this.p2.x) / 2;\n\t            var dy = (this.p1.y - this.p2.y) / 2;\n\t\n\t            var transformedPoint = {\n\t                x: Math.cos(this.radians) * dx + Math.sin(this.radians) * dy,\n\t                y: -Math.sin(this.radians) * dx + Math.cos(this.radians) * dy\n\t            };\n\t\n\t            // Ensure radii are large enough\n\t            var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(this.rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(this.ry, 2);\n\t\n\t            if (radiiCheck > 1) {\n\t                this.rx = Math.sqrt(radiiCheck) * this.rx;\n\t                this.ry = Math.sqrt(radiiCheck) * this.ry;\n\t            }\n\t\n\t            // Step #2: Compute transformedCenter\n\t            var cSquareNumerator = Math.pow(this.rx, 2) * Math.pow(this.ry, 2) - Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2);\n\t            var cSquareRootDenom = Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2);\n\t            var cRadicand = cSquareNumerator / cSquareRootDenom;\n\t\n\t            // Make sure this never drops below zero because of precision\n\t            cRadicand = cRadicand < 0 ? 0 : cRadicand;\n\t            var cCoef = (this.large !== this.sweep ? 1 : -1) * Math.sqrt(cRadicand);\n\t            var transformedCenter = {\n\t                x: cCoef * (this.rx * transformedPoint.y / this.ry),\n\t                y: cCoef * (-(this.ry * transformedPoint.x) / this.rx)\n\t            };\n\t\n\t            // Step #3: Compute center\n\t            this.center = {\n\t                x: Math.cos(this.radians) * transformedCenter.x - Math.sin(this.radians) * transformedCenter.y + (this.p1.x + this.p2.x) / 2,\n\t                y: Math.sin(this.radians) * transformedCenter.x + Math.cos(this.radians) * transformedCenter.y + (this.p1.y + this.p2.y) / 2\n\t            };\n\t\n\t            // Step #4: Compute start/sweep angles\n\t            // Start angle of the elliptical arc prior to the stretch and rotate operations.\n\t            // Difference between the start and end angles\n\t            var startVector = {\n\t                x: (transformedPoint.x - transformedCenter.x) / this.rx,\n\t                y: (transformedPoint.y - transformedCenter.y) / this.ry\n\t            };\n\t\n\t            var endVector = {\n\t                x: (-transformedPoint.x - transformedCenter.x) / this.rx,\n\t                y: (-transformedPoint.y - transformedCenter.y) / this.ry\n\t            };\n\t\n\t            this.startAngle = angle({ x: 1, y: 0 }, startVector);\n\t            this.sweepAngle = angle(startVector, endVector);\n\t\n\t            if (!this.sweep && this.sweepAngle > 0) {\n\t                this.sweepAngle -= MATH_PI_2;\n\t            } else if (this.sweep && this.sweepAngle < 0) {\n\t                this.sweepAngle += MATH_PI_2;\n\t            }\n\t\n\t            // We use % instead of `mod(..)` because we want it to be -360deg to 360deg(but actually in radians)\n\t            this.sweepAngle %= MATH_PI_2;\n\t        }\n\t    }, {\n\t        key: 'trace',\n\t        value: function trace(settings) {\n\t            this.init(settings);\n\t            return _get(Arc.prototype.__proto__ || Object.getPrototypeOf(Arc.prototype), 'trace', this).call(this);\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            var angle = this.startAngle + this.sweepAngle * t;\n\t\n\t            var x = this.rx * Math.cos(angle);\n\t            var y = this.ry * Math.sin(angle);\n\t\n\t            return new _path.Point(Math.cos(this.radians) * x - Math.sin(this.radians) * y + this.center.x, Math.sin(this.radians) * x + Math.cos(this.radians) * y + this.center.y);\n\t        }\n\t    }, {\n\t        key: '_postTrace',\n\t        value: function _postTrace() {\n\t            // Add last point in the path\n\t            this._addPoint(this.p2);\n\t        }\n\t    }]);\n\t\n\t    return Arc;\n\t}(TraceBase);\n\t\n\tvar CubicBezier = function (_TraceBase2) {\n\t    _inherits(CubicBezier, _TraceBase2);\n\t\n\t    function CubicBezier() {\n\t        _classCallCheck(this, CubicBezier);\n\t\n\t        return _possibleConstructorReturn(this, (CubicBezier.__proto__ || Object.getPrototypeOf(CubicBezier)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(CubicBezier, [{\n\t        key: '_B1',\n\t        value: function _B1(t) {\n\t            return t * t * t;\n\t        }\n\t    }, {\n\t        key: '_B2',\n\t        value: function _B2(t) {\n\t            return 3 * t * t * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_B3',\n\t        value: function _B3(t) {\n\t            return 3 * t * (1 - t) * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_B4',\n\t        value: function _B4(t) {\n\t            return (1 - t) * (1 - t) * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_C1',\n\t        value: function _C1(p1, p2, p3, p4, t) {\n\t            return p1 * this._B1(t) + p2 * this._B2(t) + p3 * this._B3(t) + p4 * this._B4(t);\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            return new _path.Point(this._C1(this.p1.x, this.p2.x, this.p3.x, this.p4.x, t), this._C1(this.p1.y, this.p2.y, this.p3.y, this.p4.y, t));\n\t        }\n\t    }, {\n\t        key: '_addPoint',\n\t        value: function _addPoint(point) {\n\t            this.path.unshift(point.x, point.y);\n\t        }\n\t    }]);\n\t\n\t    return CubicBezier;\n\t}(TraceBase);\n\t\n\tvar QuadricBezier = function (_TraceBase3) {\n\t    _inherits(QuadricBezier, _TraceBase3);\n\t\n\t    function QuadricBezier() {\n\t        _classCallCheck(this, QuadricBezier);\n\t\n\t        return _possibleConstructorReturn(this, (QuadricBezier.__proto__ || Object.getPrototypeOf(QuadricBezier)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(QuadricBezier, [{\n\t        key: '_B1',\n\t        value: function _B1(t) {\n\t            return t * t;\n\t        }\n\t    }, {\n\t        key: '_B2',\n\t        value: function _B2(t) {\n\t            return 2 * t * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_B3',\n\t        value: function _B3(t) {\n\t            return (1 - t) * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_C1',\n\t        value: function _C1(p1, p2, p3, t) {\n\t            return p1 * this._B1(t) + p2 * this._B2(t) + p3 * this._B3(t);\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            return new _path.Point(this._C1(this.p1.x, this.p2.x, this.p3.x, t), this._C1(this.p1.y, this.p2.y, this.p3.y, t));\n\t        }\n\t    }, {\n\t        key: '_addPoint',\n\t        value: function _addPoint(point) {\n\t            this.path.unshift(point.x, point.y);\n\t        }\n\t    }]);\n\t\n\t    return QuadricBezier;\n\t}(TraceBase);\n\t\n\t// Exports\n\t\n\t\n\texports.Arc = Arc;\n\texports.CubicBezier = CubicBezier;\n\texports.QuadricBezier = QuadricBezier;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// rev 482\n\t/********************************************************************************\n\t *                                                                              *\n\t * Author    :  Angus Johnson                                                   *\n\t * Version   :  6.2.1                                                          *\n\t * Date      :  31 October 2014                                                 *\n\t * Website   :  http://www.angusj.com                                           *\n\t * Copyright :  Angus Johnson 2010-2014                                         *\n\t *                                                                              *\n\t * License:                                                                     *\n\t * Use, modification & distribution is subject to Boost Software License Ver 1. *\n\t * http://www.boost.org/LICENSE_1_0.txt                                         *\n\t *                                                                              *\n\t * Attributions:                                                                *\n\t * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n\t * \"A generic solution to polygon clipping\"                                     *\n\t * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n\t * http://portal.acm.org/citation.cfm?id=129906                                 *\n\t *                                                                              *\n\t * Computer graphics and geometric modeling: implementation and algorithms      *\n\t * By Max K. Agoston                                                            *\n\t * Springer; 1 edition (January 4, 2005)                                        *\n\t * http://books.google.com/books?q=vatti+clipping+agoston                       *\n\t *                                                                              *\n\t * See also:                                                                    *\n\t * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n\t * Paper no. DETC2005-85513 pp. 565-575                                         *\n\t * ASME 2005 International Design Engineering Technical Conferences             *\n\t * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n\t * September 24-28, 2005 , Long Beach, California, USA                          *\n\t * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n\t *                                                                              *\n\t *******************************************************************************/\n\t/*******************************************************************************\n\t *                                                                              *\n\t * Author    :  Timo                                                            *\n\t * Version   :  6.2.1.0                                                         *\n\t * Date      :  17 June 2016                                                 *\n\t *                                                                              *\n\t * This is a translation of the C# Clipper library to Javascript.               *\n\t * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n\t * Because Javascript lacks support for 64-bit integers, the space              *\n\t * is a little more restricted than in C# version.                              *\n\t *                                                                              *\n\t * C# version has support for coordinate space:                                 *\n\t * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n\t * while Javascript version has support for space:                              *\n\t * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n\t *                                                                              *\n\t * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n\t * http://jsperf.com/big-integer-library-test                                   *\n\t *                                                                              *\n\t * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n\t *                                                                              *\n\t *******************************************************************************/\n\t/*******************************************************************************\n\t *                                                                              *\n\t * Basic JavaScript BN library - subset useful for RSA encryption.              *\n\t * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n\t * Copyright (c) 2005  Tom Wu                                                   *\n\t * All Rights Reserved.                                                         *\n\t * See \"LICENSE\" for details:                                                   *\n\t * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n\t *                                                                              *\n\t *******************************************************************************/\n\t(function ()\n\t{\n\t  \"use strict\";\n\t  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n\t  //improve performance but coordinate values are limited to the range +/- 46340\n\t  var use_int32 = false;\n\t  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n\t  var use_xyz = false;\n\t  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n\t  var use_lines = true;\n\t\n\t  var ClipperLib = {};\n\t  var isNode = false;\n\t  if (typeof module !== 'undefined' && module.exports)\n\t  {\n\t    module.exports = ClipperLib;\n\t    isNode = true;\n\t  }\n\t  else\n\t  {\n\t    if (true) {\n\t      !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ClipperLib), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n\t    else self['ClipperLib'] = ClipperLib;\n\t  }\n\t  var navigator_appName;\n\t  if (!isNode)\n\t  {\n\t    var nav = navigator.userAgent.toString().toLowerCase();\n\t    navigator_appName = navigator.appName;\n\t  }\n\t  else\n\t  {\n\t    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n\t    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n\t  }\n\t  // Browser test to speedup performance critical functions\n\t  var browser = {};\n\t  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n\t  else browser.chrome = 0;\n\t  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n\t  else browser.chromium = 0;\n\t  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n\t  else browser.safari = 0;\n\t  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n\t  else browser.firefox = 0;\n\t  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n\t  else browser.firefox17 = 0;\n\t  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n\t  else browser.firefox15 = 0;\n\t  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n\t  else browser.firefox3 = 0;\n\t  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n\t  else browser.opera = 0;\n\t  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n\t  else browser.msie10 = 0;\n\t  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n\t  else browser.msie9 = 0;\n\t  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n\t  else browser.msie8 = 0;\n\t  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n\t  else browser.msie7 = 0;\n\t  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n\t  else browser.msie = 0;\n\t  ClipperLib.biginteger_used = null;\n\t\n\t  // Copyright (c) 2005  Tom Wu\n\t  // All Rights Reserved.\n\t  // See \"LICENSE\" for details.\n\t  // Basic JavaScript BN library - subset useful for RSA encryption.\n\t  // Bits per digit\n\t  var dbits;\n\t  // JavaScript engine analysis\n\t  var canary = 0xdeadbeefcafe;\n\t  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n\t  // (public) Constructor\n\t  function BigInteger(a, b, c)\n\t  {\n\t    // This test variable can be removed,\n\t    // but at least for performance tests it is useful piece of knowledge\n\t    // This is the only ClipperLib related variable in BigInteger library\n\t    ClipperLib.biginteger_used = 1;\n\t    if (a != null)\n\t      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n\t      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n\t    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n\t    else this.fromString(a, b);\n\t  }\n\t  // return new, unset BigInteger\n\t  function nbi()\n\t  {\n\t    return new BigInteger(null,undefined,undefined);\n\t  }\n\t  // am: Compute w_j += (x*this_i), propagate carries,\n\t  // c is initial carry, returns final carry.\n\t  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n\t  // We need to select the fastest one that works in this environment.\n\t  // am1: use a single mult and divide to get the high bits,\n\t  // max digit bits should be 26 because\n\t  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n\t  function am1(i, x, w, j, c, n)\n\t  {\n\t    while (--n >= 0)\n\t    {\n\t      var v = x * this[i++] + w[j] + c;\n\t      c = Math.floor(v / 0x4000000);\n\t      w[j++] = v & 0x3ffffff;\n\t    }\n\t    return c;\n\t  }\n\t  // am2 avoids a big mult-and-extract completely.\n\t  // Max digit bits should be <= 30 because we do bitwise ops\n\t  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n\t  function am2(i, x, w, j, c, n)\n\t  {\n\t    var xl = x & 0x7fff,\n\t      xh = x >> 15;\n\t    while (--n >= 0)\n\t    {\n\t      var l = this[i] & 0x7fff;\n\t      var h = this[i++] >> 15;\n\t      var m = xh * l + h * xl;\n\t      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n\t      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n\t      w[j++] = l & 0x3fffffff;\n\t    }\n\t    return c;\n\t  }\n\t  // Alternately, set max digit bits to 28 since some\n\t  // browsers slow down when dealing with 32-bit numbers.\n\t  function am3(i, x, w, j, c, n)\n\t  {\n\t    var xl = x & 0x3fff,\n\t      xh = x >> 14;\n\t    while (--n >= 0)\n\t    {\n\t      var l = this[i] & 0x3fff;\n\t      var h = this[i++] >> 14;\n\t      var m = xh * l + h * xl;\n\t      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n\t      c = (l >> 28) + (m >> 14) + xh * h;\n\t      w[j++] = l & 0xfffffff;\n\t    }\n\t    return c;\n\t  }\n\t  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n\t  {\n\t    BigInteger.prototype.am = am2;\n\t    dbits = 30;\n\t  }\n\t  else if (j_lm && (navigator_appName != \"Netscape\"))\n\t  {\n\t    BigInteger.prototype.am = am1;\n\t    dbits = 26;\n\t  }\n\t  else\n\t  { // Mozilla/Netscape seems to prefer am3\n\t    BigInteger.prototype.am = am3;\n\t    dbits = 28;\n\t  }\n\t  BigInteger.prototype.DB = dbits;\n\t  BigInteger.prototype.DM = ((1 << dbits) - 1);\n\t  BigInteger.prototype.DV = (1 << dbits);\n\t  var BI_FP = 52;\n\t  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n\t  BigInteger.prototype.F1 = BI_FP - dbits;\n\t  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n\t  // Digit conversions\n\t  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\t  var BI_RC = new Array();\n\t  var rr, vv;\n\t  rr = \"0\".charCodeAt(0);\n\t  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n\t  rr = \"a\".charCodeAt(0);\n\t  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t  rr = \"A\".charCodeAt(0);\n\t  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t\n\t  function int2char(n)\n\t  {\n\t    return BI_RM.charAt(n);\n\t  }\n\t\n\t  function intAt(s, i)\n\t  {\n\t    var c = BI_RC[s.charCodeAt(i)];\n\t    return (c == null) ? -1 : c;\n\t  }\n\t  // (protected) copy this to r\n\t  function bnpCopyTo(r)\n\t  {\n\t    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n\t    r.t = this.t;\n\t    r.s = this.s;\n\t  }\n\t  // (protected) set from integer value x, -DV <= x < DV\n\t  function bnpFromInt(x)\n\t  {\n\t    this.t = 1;\n\t    this.s = (x < 0) ? -1 : 0;\n\t    if (x > 0) this[0] = x;\n\t    else if (x < -1) this[0] = x + this.DV;\n\t    else this.t = 0;\n\t  }\n\t  // return bigint initialized to value\n\t  function nbv(i)\n\t  {\n\t    var r = nbi();\n\t    r.fromInt(i);\n\t    return r;\n\t  }\n\t  // (protected) set from string and radix\n\t  function bnpFromString(s, b)\n\t  {\n\t    var k;\n\t    if (b == 16) k = 4;\n\t    else if (b == 8) k = 3;\n\t    else if (b == 256) k = 8; // byte array\n\t    else if (b == 2) k = 1;\n\t    else if (b == 32) k = 5;\n\t    else if (b == 4) k = 2;\n\t    else\n\t    {\n\t      this.fromRadix(s, b);\n\t      return;\n\t    }\n\t    this.t = 0;\n\t    this.s = 0;\n\t    var i = s.length,\n\t      mi = false,\n\t      sh = 0;\n\t    while (--i >= 0)\n\t    {\n\t      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n\t      if (x < 0)\n\t      {\n\t        if (s.charAt(i) == \"-\") mi = true;\n\t        continue;\n\t      }\n\t      mi = false;\n\t      if (sh == 0)\n\t        this[this.t++] = x;\n\t      else if (sh + k > this.DB)\n\t      {\n\t        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n\t        this[this.t++] = (x >> (this.DB - sh));\n\t      }\n\t      else\n\t        this[this.t - 1] |= x << sh;\n\t      sh += k;\n\t      if (sh >= this.DB) sh -= this.DB;\n\t    }\n\t    if (k == 8 && (s[0] & 0x80) != 0)\n\t    {\n\t      this.s = -1;\n\t      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n\t    }\n\t    this.clamp();\n\t    if (mi) BigInteger.ZERO.subTo(this, this);\n\t  }\n\t  // (protected) clamp off excess high words\n\t  function bnpClamp()\n\t  {\n\t    var c = this.s & this.DM;\n\t    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n\t  }\n\t  // (public) return string representation in given radix\n\t  function bnToString(b)\n\t  {\n\t    if (this.s < 0) return \"-\" + this.negate().toString(b);\n\t    var k;\n\t    if (b == 16) k = 4;\n\t    else if (b == 8) k = 3;\n\t    else if (b == 2) k = 1;\n\t    else if (b == 32) k = 5;\n\t    else if (b == 4) k = 2;\n\t    else return this.toRadix(b);\n\t    var km = (1 << k) - 1,\n\t      d, m = false,\n\t      r = \"\",\n\t      i = this.t;\n\t    var p = this.DB - (i * this.DB) % k;\n\t    if (i-- > 0)\n\t    {\n\t      if (p < this.DB && (d = this[i] >> p) > 0)\n\t      {\n\t        m = true;\n\t        r = int2char(d);\n\t      }\n\t      while (i >= 0)\n\t      {\n\t        if (p < k)\n\t        {\n\t          d = (this[i] & ((1 << p) - 1)) << (k - p);\n\t          d |= this[--i] >> (p += this.DB - k);\n\t        }\n\t        else\n\t        {\n\t          d = (this[i] >> (p -= k)) & km;\n\t          if (p <= 0)\n\t          {\n\t            p += this.DB;\n\t            --i;\n\t          }\n\t        }\n\t        if (d > 0) m = true;\n\t        if (m) r += int2char(d);\n\t      }\n\t    }\n\t    return m ? r : \"0\";\n\t  }\n\t  // (public) -this\n\t  function bnNegate()\n\t  {\n\t    var r = nbi();\n\t    BigInteger.ZERO.subTo(this, r);\n\t    return r;\n\t  }\n\t  // (public) |this|\n\t  function bnAbs()\n\t  {\n\t    return (this.s < 0) ? this.negate() : this;\n\t  }\n\t  // (public) return + if this > a, - if this < a, 0 if equal\n\t  function bnCompareTo(a)\n\t  {\n\t    var r = this.s - a.s;\n\t    if (r != 0) return r;\n\t    var i = this.t;\n\t    r = i - a.t;\n\t    if (r != 0) return (this.s < 0) ? -r : r;\n\t    while (--i >= 0)\n\t      if ((r = this[i] - a[i]) != 0) return r;\n\t    return 0;\n\t  }\n\t  // returns bit length of the integer x\n\t  function nbits(x)\n\t  {\n\t    var r = 1,\n\t      t;\n\t    if ((t = x >>> 16) != 0)\n\t    {\n\t      x = t;\n\t      r += 16;\n\t    }\n\t    if ((t = x >> 8) != 0)\n\t    {\n\t      x = t;\n\t      r += 8;\n\t    }\n\t    if ((t = x >> 4) != 0)\n\t    {\n\t      x = t;\n\t      r += 4;\n\t    }\n\t    if ((t = x >> 2) != 0)\n\t    {\n\t      x = t;\n\t      r += 2;\n\t    }\n\t    if ((t = x >> 1) != 0)\n\t    {\n\t      x = t;\n\t      r += 1;\n\t    }\n\t    return r;\n\t  }\n\t  // (public) return the number of bits in \"this\"\n\t  function bnBitLength()\n\t  {\n\t    if (this.t <= 0) return 0;\n\t    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n\t  }\n\t  // (protected) r = this << n*DB\n\t  function bnpDLShiftTo(n, r)\n\t  {\n\t    var i;\n\t    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n\t    for (i = n - 1; i >= 0; --i) r[i] = 0;\n\t    r.t = this.t + n;\n\t    r.s = this.s;\n\t  }\n\t  // (protected) r = this >> n*DB\n\t  function bnpDRShiftTo(n, r)\n\t  {\n\t    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n\t    r.t = Math.max(this.t - n, 0);\n\t    r.s = this.s;\n\t  }\n\t  // (protected) r = this << n\n\t  function bnpLShiftTo(n, r)\n\t  {\n\t    var bs = n % this.DB;\n\t    var cbs = this.DB - bs;\n\t    var bm = (1 << cbs) - 1;\n\t    var ds = Math.floor(n / this.DB),\n\t      c = (this.s << bs) & this.DM,\n\t      i;\n\t    for (i = this.t - 1; i >= 0; --i)\n\t    {\n\t      r[i + ds + 1] = (this[i] >> cbs) | c;\n\t      c = (this[i] & bm) << bs;\n\t    }\n\t    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n\t    r[ds] = c;\n\t    r.t = this.t + ds + 1;\n\t    r.s = this.s;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this >> n\n\t  function bnpRShiftTo(n, r)\n\t  {\n\t    r.s = this.s;\n\t    var ds = Math.floor(n / this.DB);\n\t    if (ds >= this.t)\n\t    {\n\t      r.t = 0;\n\t      return;\n\t    }\n\t    var bs = n % this.DB;\n\t    var cbs = this.DB - bs;\n\t    var bm = (1 << bs) - 1;\n\t    r[0] = this[ds] >> bs;\n\t    for (var i = ds + 1; i < this.t; ++i)\n\t    {\n\t      r[i - ds - 1] |= (this[i] & bm) << cbs;\n\t      r[i - ds] = this[i] >> bs;\n\t    }\n\t    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n\t    r.t = this.t - ds;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this - a\n\t  function bnpSubTo(a, r)\n\t  {\n\t    var i = 0,\n\t      c = 0,\n\t      m = Math.min(a.t, this.t);\n\t    while (i < m)\n\t    {\n\t      c += this[i] - a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    if (a.t < this.t)\n\t    {\n\t      c -= a.s;\n\t      while (i < this.t)\n\t      {\n\t        c += this[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += this.s;\n\t    }\n\t    else\n\t    {\n\t      c += this.s;\n\t      while (i < a.t)\n\t      {\n\t        c -= a[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c -= a.s;\n\t    }\n\t    r.s = (c < 0) ? -1 : 0;\n\t    if (c < -1) r[i++] = this.DV + c;\n\t    else if (c > 0) r[i++] = c;\n\t    r.t = i;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this * a, r != this,a (HAC 14.12)\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyTo(a, r)\n\t  {\n\t    var x = this.abs(),\n\t      y = a.abs();\n\t    var i = x.t;\n\t    r.t = i + y.t;\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n\t    r.s = 0;\n\t    r.clamp();\n\t    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n\t  }\n\t  // (protected) r = this^2, r != this (HAC 14.16)\n\t  function bnpSquareTo(r)\n\t  {\n\t    var x = this.abs();\n\t    var i = r.t = 2 * x.t;\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = 0; i < x.t - 1; ++i)\n\t    {\n\t      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n\t      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n\t      {\n\t        r[i + x.t] -= x.DV;\n\t        r[i + x.t + 1] = 1;\n\t      }\n\t    }\n\t    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n\t    r.s = 0;\n\t    r.clamp();\n\t  }\n\t  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n\t  // r != q, this != m.  q or r may be null.\n\t  function bnpDivRemTo(m, q, r)\n\t  {\n\t    var pm = m.abs();\n\t    if (pm.t <= 0) return;\n\t    var pt = this.abs();\n\t    if (pt.t < pm.t)\n\t    {\n\t      if (q != null) q.fromInt(0);\n\t      if (r != null) this.copyTo(r);\n\t      return;\n\t    }\n\t    if (r == null) r = nbi();\n\t    var y = nbi(),\n\t      ts = this.s,\n\t      ms = m.s;\n\t    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n\t    if (nsh > 0)\n\t    {\n\t      pm.lShiftTo(nsh, y);\n\t      pt.lShiftTo(nsh, r);\n\t    }\n\t    else\n\t    {\n\t      pm.copyTo(y);\n\t      pt.copyTo(r);\n\t    }\n\t    var ys = y.t;\n\t    var y0 = y[ys - 1];\n\t    if (y0 == 0) return;\n\t    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n\t    var d1 = this.FV / yt,\n\t      d2 = (1 << this.F1) / yt,\n\t      e = 1 << this.F2;\n\t    var i = r.t,\n\t      j = i - ys,\n\t      t = (q == null) ? nbi() : q;\n\t    y.dlShiftTo(j, t);\n\t    if (r.compareTo(t) >= 0)\n\t    {\n\t      r[r.t++] = 1;\n\t      r.subTo(t, r);\n\t    }\n\t    BigInteger.ONE.dlShiftTo(ys, t);\n\t    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n\t    while (y.t < ys) y[y.t++] = 0;\n\t    while (--j >= 0)\n\t    {\n\t      // Estimate quotient digit\n\t      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n\t      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n\t      { // Try it out\n\t        y.dlShiftTo(j, t);\n\t        r.subTo(t, r);\n\t        while (r[i] < --qd) r.subTo(t, r);\n\t      }\n\t    }\n\t    if (q != null)\n\t    {\n\t      r.drShiftTo(ys, q);\n\t      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n\t    }\n\t    r.t = ys;\n\t    r.clamp();\n\t    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n\t    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n\t  }\n\t  // (public) this mod a\n\t  function bnMod(a)\n\t  {\n\t    var r = nbi();\n\t    this.abs().divRemTo(a, null, r);\n\t    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n\t    return r;\n\t  }\n\t  // Modular reduction using \"classic\" algorithm\n\t  function Classic(m)\n\t  {\n\t    this.m = m;\n\t  }\n\t\n\t  function cConvert(x)\n\t  {\n\t    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n\t    else return x;\n\t  }\n\t\n\t  function cRevert(x)\n\t  {\n\t    return x;\n\t  }\n\t\n\t  function cReduce(x)\n\t  {\n\t    x.divRemTo(this.m, null, x);\n\t  }\n\t\n\t  function cMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t\n\t  function cSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  Classic.prototype.convert = cConvert;\n\t  Classic.prototype.revert = cRevert;\n\t  Classic.prototype.reduce = cReduce;\n\t  Classic.prototype.mulTo = cMulTo;\n\t  Classic.prototype.sqrTo = cSqrTo;\n\t  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n\t  // justification:\n\t  //         xy == 1 (mod m)\n\t  //         xy =  1+km\n\t  //   xy(2-xy) = (1+km)(1-km)\n\t  // x[y(2-xy)] = 1-k^2m^2\n\t  // x[y(2-xy)] == 1 (mod m^2)\n\t  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n\t  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n\t  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n\t  function bnpInvDigit()\n\t  {\n\t    if (this.t < 1) return 0;\n\t    var x = this[0];\n\t    if ((x & 1) == 0) return 0;\n\t    var y = x & 3; // y == 1/x mod 2^2\n\t    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n\t    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n\t    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n\t    // last step - calculate inverse mod DV directly;\n\t    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n\t    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n\t    // we really want the negative inverse, and -DV < y < DV\n\t    return (y > 0) ? this.DV - y : -y;\n\t  }\n\t  // Montgomery reduction\n\t  function Montgomery(m)\n\t  {\n\t    this.m = m;\n\t    this.mp = m.invDigit();\n\t    this.mpl = this.mp & 0x7fff;\n\t    this.mph = this.mp >> 15;\n\t    this.um = (1 << (m.DB - 15)) - 1;\n\t    this.mt2 = 2 * m.t;\n\t  }\n\t  // xR mod m\n\t  function montConvert(x)\n\t  {\n\t    var r = nbi();\n\t    x.abs().dlShiftTo(this.m.t, r);\n\t    r.divRemTo(this.m, null, r);\n\t    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n\t    return r;\n\t  }\n\t  // x/R mod m\n\t  function montRevert(x)\n\t  {\n\t    var r = nbi();\n\t    x.copyTo(r);\n\t    this.reduce(r);\n\t    return r;\n\t  }\n\t  // x = x/R mod m (HAC 14.32)\n\t  function montReduce(x)\n\t  {\n\t    while (x.t <= this.mt2) // pad x so am has enough room later\n\t      x[x.t++] = 0;\n\t    for (var i = 0; i < this.m.t; ++i)\n\t    {\n\t      // faster way of calculating u0 = x[i]*mp mod DV\n\t      var j = x[i] & 0x7fff;\n\t      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n\t      // use am to combine the multiply-shift-add into one call\n\t      j = i + this.m.t;\n\t      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n\t      // propagate carry\n\t      while (x[j] >= x.DV)\n\t      {\n\t        x[j] -= x.DV;\n\t        x[++j]++;\n\t      }\n\t    }\n\t    x.clamp();\n\t    x.drShiftTo(this.m.t, x);\n\t    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t  }\n\t  // r = \"x^2/R mod m\"; x != r\n\t  function montSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  // r = \"xy/R mod m\"; x,y != r\n\t  function montMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t  Montgomery.prototype.convert = montConvert;\n\t  Montgomery.prototype.revert = montRevert;\n\t  Montgomery.prototype.reduce = montReduce;\n\t  Montgomery.prototype.mulTo = montMulTo;\n\t  Montgomery.prototype.sqrTo = montSqrTo;\n\t  // (protected) true iff this is even\n\t  function bnpIsEven()\n\t  {\n\t    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n\t  }\n\t  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n\t  function bnpExp(e, z)\n\t  {\n\t    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n\t    var r = nbi(),\n\t      r2 = nbi(),\n\t      g = z.convert(this),\n\t      i = nbits(e) - 1;\n\t    g.copyTo(r);\n\t    while (--i >= 0)\n\t    {\n\t      z.sqrTo(r, r2);\n\t      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n\t      else\n\t      {\n\t        var t = r;\n\t        r = r2;\n\t        r2 = t;\n\t      }\n\t    }\n\t    return z.revert(r);\n\t  }\n\t  // (public) this^e % m, 0 <= e < 2^32\n\t  function bnModPowInt(e, m)\n\t  {\n\t    var z;\n\t    if (e < 256 || m.isEven()) z = new Classic(m);\n\t    else z = new Montgomery(m);\n\t    return this.exp(e, z);\n\t  }\n\t  // protected\n\t  BigInteger.prototype.copyTo = bnpCopyTo;\n\t  BigInteger.prototype.fromInt = bnpFromInt;\n\t  BigInteger.prototype.fromString = bnpFromString;\n\t  BigInteger.prototype.clamp = bnpClamp;\n\t  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n\t  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n\t  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n\t  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n\t  BigInteger.prototype.subTo = bnpSubTo;\n\t  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n\t  BigInteger.prototype.squareTo = bnpSquareTo;\n\t  BigInteger.prototype.divRemTo = bnpDivRemTo;\n\t  BigInteger.prototype.invDigit = bnpInvDigit;\n\t  BigInteger.prototype.isEven = bnpIsEven;\n\t  BigInteger.prototype.exp = bnpExp;\n\t  // public\n\t  BigInteger.prototype.toString = bnToString;\n\t  BigInteger.prototype.negate = bnNegate;\n\t  BigInteger.prototype.abs = bnAbs;\n\t  BigInteger.prototype.compareTo = bnCompareTo;\n\t  BigInteger.prototype.bitLength = bnBitLength;\n\t  BigInteger.prototype.mod = bnMod;\n\t  BigInteger.prototype.modPowInt = bnModPowInt;\n\t  // \"constants\"\n\t  BigInteger.ZERO = nbv(0);\n\t  BigInteger.ONE = nbv(1);\n\t  // Copyright (c) 2005-2009  Tom Wu\n\t  // All Rights Reserved.\n\t  // See \"LICENSE\" for details.\n\t  // Extended JavaScript BN functions, required for RSA private ops.\n\t  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n\t  // Version 1.2: square() API, isProbablePrime fix\n\t  // (public)\n\t  function bnClone()\n\t  {\n\t    var r = nbi();\n\t    this.copyTo(r);\n\t    return r;\n\t  }\n\t  // (public) return value as integer\n\t  function bnIntValue()\n\t  {\n\t    if (this.s < 0)\n\t    {\n\t      if (this.t == 1) return this[0] - this.DV;\n\t      else if (this.t == 0) return -1;\n\t    }\n\t    else if (this.t == 1) return this[0];\n\t    else if (this.t == 0) return 0;\n\t    // assumes 16 < DB < 32\n\t    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n\t  }\n\t  // (public) return value as byte\n\t  function bnByteValue()\n\t  {\n\t    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n\t  }\n\t  // (public) return value as short (assumes DB>=16)\n\t  function bnShortValue()\n\t  {\n\t    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n\t  }\n\t  // (protected) return x s.t. r^x < DV\n\t  function bnpChunkSize(r)\n\t  {\n\t    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n\t  }\n\t  // (public) 0 if this == 0, 1 if this > 0\n\t  function bnSigNum()\n\t  {\n\t    if (this.s < 0) return -1;\n\t    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n\t    else return 1;\n\t  }\n\t  // (protected) convert to radix string\n\t  function bnpToRadix(b)\n\t  {\n\t    if (b == null) b = 10;\n\t    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n\t    var cs = this.chunkSize(b);\n\t    var a = Math.pow(b, cs);\n\t    var d = nbv(a),\n\t      y = nbi(),\n\t      z = nbi(),\n\t      r = \"\";\n\t    this.divRemTo(d, y, z);\n\t    while (y.signum() > 0)\n\t    {\n\t      r = (a + z.intValue()).toString(b).substr(1) + r;\n\t      y.divRemTo(d, y, z);\n\t    }\n\t    return z.intValue().toString(b) + r;\n\t  }\n\t  // (protected) convert from radix string\n\t  function bnpFromRadix(s, b)\n\t  {\n\t    this.fromInt(0);\n\t    if (b == null) b = 10;\n\t    var cs = this.chunkSize(b);\n\t    var d = Math.pow(b, cs),\n\t      mi = false,\n\t      j = 0,\n\t      w = 0;\n\t    for (var i = 0; i < s.length; ++i)\n\t    {\n\t      var x = intAt(s, i);\n\t      if (x < 0)\n\t      {\n\t        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n\t        continue;\n\t      }\n\t      w = b * w + x;\n\t      if (++j >= cs)\n\t      {\n\t        this.dMultiply(d);\n\t        this.dAddOffset(w, 0);\n\t        j = 0;\n\t        w = 0;\n\t      }\n\t    }\n\t    if (j > 0)\n\t    {\n\t      this.dMultiply(Math.pow(b, j));\n\t      this.dAddOffset(w, 0);\n\t    }\n\t    if (mi) BigInteger.ZERO.subTo(this, this);\n\t  }\n\t  // (protected) alternate constructor\n\t  function bnpFromNumber(a, b, c)\n\t  {\n\t    if (\"number\" == typeof b)\n\t    {\n\t      // new BigInteger(int,int,RNG)\n\t      if (a < 2) this.fromInt(1);\n\t      else\n\t      {\n\t        this.fromNumber(a, c);\n\t        if (!this.testBit(a - 1)) // force MSB set\n\t          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n\t        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n\t        while (!this.isProbablePrime(b))\n\t        {\n\t          this.dAddOffset(2, 0);\n\t          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n\t        }\n\t      }\n\t    }\n\t    else\n\t    {\n\t      // new BigInteger(int,RNG)\n\t      var x = new Array(),\n\t        t = a & 7;\n\t      x.length = (a >> 3) + 1;\n\t      b.nextBytes(x);\n\t      if (t > 0) x[0] &= ((1 << t) - 1);\n\t      else x[0] = 0;\n\t      this.fromString(x, 256);\n\t    }\n\t  }\n\t  // (public) convert to bigendian byte array\n\t  function bnToByteArray()\n\t  {\n\t    var i = this.t,\n\t      r = new Array();\n\t    r[0] = this.s;\n\t    var p = this.DB - (i * this.DB) % 8,\n\t      d, k = 0;\n\t    if (i-- > 0)\n\t    {\n\t      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n\t        r[k++] = d | (this.s << (this.DB - p));\n\t      while (i >= 0)\n\t      {\n\t        if (p < 8)\n\t        {\n\t          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n\t          d |= this[--i] >> (p += this.DB - 8);\n\t        }\n\t        else\n\t        {\n\t          d = (this[i] >> (p -= 8)) & 0xff;\n\t          if (p <= 0)\n\t          {\n\t            p += this.DB;\n\t            --i;\n\t          }\n\t        }\n\t        if ((d & 0x80) != 0) d |= -256;\n\t        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n\t        if (k > 0 || d != this.s) r[k++] = d;\n\t      }\n\t    }\n\t    return r;\n\t  }\n\t\n\t  function bnEquals(a)\n\t  {\n\t    return (this.compareTo(a) == 0);\n\t  }\n\t\n\t  function bnMin(a)\n\t  {\n\t    return (this.compareTo(a) < 0) ? this : a;\n\t  }\n\t\n\t  function bnMax(a)\n\t  {\n\t    return (this.compareTo(a) > 0) ? this : a;\n\t  }\n\t  // (protected) r = this op a (bitwise)\n\t  function bnpBitwiseTo(a, op, r)\n\t  {\n\t    var i, f, m = Math.min(a.t, this.t);\n\t    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n\t    if (a.t < this.t)\n\t    {\n\t      f = a.s & this.DM;\n\t      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n\t      r.t = this.t;\n\t    }\n\t    else\n\t    {\n\t      f = this.s & this.DM;\n\t      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n\t      r.t = a.t;\n\t    }\n\t    r.s = op(this.s, a.s);\n\t    r.clamp();\n\t  }\n\t  // (public) this & a\n\t  function op_and(x, y)\n\t  {\n\t    return x & y;\n\t  }\n\t\n\t  function bnAnd(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_and, r);\n\t    return r;\n\t  }\n\t  // (public) this | a\n\t  function op_or(x, y)\n\t  {\n\t    return x | y;\n\t  }\n\t\n\t  function bnOr(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_or, r);\n\t    return r;\n\t  }\n\t  // (public) this ^ a\n\t  function op_xor(x, y)\n\t  {\n\t    return x ^ y;\n\t  }\n\t\n\t  function bnXor(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_xor, r);\n\t    return r;\n\t  }\n\t  // (public) this & ~a\n\t  function op_andnot(x, y)\n\t  {\n\t    return x & ~y;\n\t  }\n\t\n\t  function bnAndNot(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_andnot, r);\n\t    return r;\n\t  }\n\t  // (public) ~this\n\t  function bnNot()\n\t  {\n\t    var r = nbi();\n\t    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n\t    r.t = this.t;\n\t    r.s = ~this.s;\n\t    return r;\n\t  }\n\t  // (public) this << n\n\t  function bnShiftLeft(n)\n\t  {\n\t    var r = nbi();\n\t    if (n < 0) this.rShiftTo(-n, r);\n\t    else this.lShiftTo(n, r);\n\t    return r;\n\t  }\n\t  // (public) this >> n\n\t  function bnShiftRight(n)\n\t  {\n\t    var r = nbi();\n\t    if (n < 0) this.lShiftTo(-n, r);\n\t    else this.rShiftTo(n, r);\n\t    return r;\n\t  }\n\t  // return index of lowest 1-bit in x, x < 2^31\n\t  function lbit(x)\n\t  {\n\t    if (x == 0) return -1;\n\t    var r = 0;\n\t    if ((x & 0xffff) == 0)\n\t    {\n\t      x >>= 16;\n\t      r += 16;\n\t    }\n\t    if ((x & 0xff) == 0)\n\t    {\n\t      x >>= 8;\n\t      r += 8;\n\t    }\n\t    if ((x & 0xf) == 0)\n\t    {\n\t      x >>= 4;\n\t      r += 4;\n\t    }\n\t    if ((x & 3) == 0)\n\t    {\n\t      x >>= 2;\n\t      r += 2;\n\t    }\n\t    if ((x & 1) == 0)++r;\n\t    return r;\n\t  }\n\t  // (public) returns index of lowest 1-bit (or -1 if none)\n\t  function bnGetLowestSetBit()\n\t  {\n\t    for (var i = 0; i < this.t; ++i)\n\t      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n\t    if (this.s < 0) return this.t * this.DB;\n\t    return -1;\n\t  }\n\t  // return number of 1 bits in x\n\t  function cbit(x)\n\t  {\n\t    var r = 0;\n\t    while (x != 0)\n\t    {\n\t      x &= x - 1;\n\t      ++r;\n\t    }\n\t    return r;\n\t  }\n\t  // (public) return number of set bits\n\t  function bnBitCount()\n\t  {\n\t    var r = 0,\n\t      x = this.s & this.DM;\n\t    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n\t    return r;\n\t  }\n\t  // (public) true iff nth bit is set\n\t  function bnTestBit(n)\n\t  {\n\t    var j = Math.floor(n / this.DB);\n\t    if (j >= this.t) return (this.s != 0);\n\t    return ((this[j] & (1 << (n % this.DB))) != 0);\n\t  }\n\t  // (protected) this op (1<<n)\n\t  function bnpChangeBit(n, op)\n\t  {\n\t    var r = BigInteger.ONE.shiftLeft(n);\n\t    this.bitwiseTo(r, op, r);\n\t    return r;\n\t  }\n\t  // (public) this | (1<<n)\n\t  function bnSetBit(n)\n\t  {\n\t    return this.changeBit(n, op_or);\n\t  }\n\t  // (public) this & ~(1<<n)\n\t  function bnClearBit(n)\n\t  {\n\t    return this.changeBit(n, op_andnot);\n\t  }\n\t  // (public) this ^ (1<<n)\n\t  function bnFlipBit(n)\n\t  {\n\t    return this.changeBit(n, op_xor);\n\t  }\n\t  // (protected) r = this + a\n\t  function bnpAddTo(a, r)\n\t  {\n\t    var i = 0,\n\t      c = 0,\n\t      m = Math.min(a.t, this.t);\n\t    while (i < m)\n\t    {\n\t      c += this[i] + a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    if (a.t < this.t)\n\t    {\n\t      c += a.s;\n\t      while (i < this.t)\n\t      {\n\t        c += this[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += this.s;\n\t    }\n\t    else\n\t    {\n\t      c += this.s;\n\t      while (i < a.t)\n\t      {\n\t        c += a[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += a.s;\n\t    }\n\t    r.s = (c < 0) ? -1 : 0;\n\t    if (c > 0) r[i++] = c;\n\t    else if (c < -1) r[i++] = this.DV + c;\n\t    r.t = i;\n\t    r.clamp();\n\t  }\n\t  // (public) this + a\n\t  function bnAdd(a)\n\t  {\n\t    var r = nbi();\n\t    this.addTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this - a\n\t  function bnSubtract(a)\n\t  {\n\t    var r = nbi();\n\t    this.subTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this * a\n\t  function bnMultiply(a)\n\t  {\n\t    var r = nbi();\n\t    this.multiplyTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this^2\n\t  function bnSquare()\n\t  {\n\t    var r = nbi();\n\t    this.squareTo(r);\n\t    return r;\n\t  }\n\t  // (public) this / a\n\t  function bnDivide(a)\n\t  {\n\t    var r = nbi();\n\t    this.divRemTo(a, r, null);\n\t    return r;\n\t  }\n\t  // (public) this % a\n\t  function bnRemainder(a)\n\t  {\n\t    var r = nbi();\n\t    this.divRemTo(a, null, r);\n\t    return r;\n\t  }\n\t  // (public) [this/a,this%a]\n\t  function bnDivideAndRemainder(a)\n\t  {\n\t    var q = nbi(),\n\t      r = nbi();\n\t    this.divRemTo(a, q, r);\n\t    return new Array(q, r);\n\t  }\n\t  // (protected) this *= n, this >= 0, 1 < n < DV\n\t  function bnpDMultiply(n)\n\t  {\n\t    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n\t    ++this.t;\n\t    this.clamp();\n\t  }\n\t  // (protected) this += n << w words, this >= 0\n\t  function bnpDAddOffset(n, w)\n\t  {\n\t    if (n == 0) return;\n\t    while (this.t <= w) this[this.t++] = 0;\n\t    this[w] += n;\n\t    while (this[w] >= this.DV)\n\t    {\n\t      this[w] -= this.DV;\n\t      if (++w >= this.t) this[this.t++] = 0;\n\t      ++this[w];\n\t    }\n\t  }\n\t  // A \"null\" reducer\n\t  function NullExp()\n\t  {}\n\t\n\t  function nNop(x)\n\t  {\n\t    return x;\n\t  }\n\t\n\t  function nMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t  }\n\t\n\t  function nSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t  }\n\t  NullExp.prototype.convert = nNop;\n\t  NullExp.prototype.revert = nNop;\n\t  NullExp.prototype.mulTo = nMulTo;\n\t  NullExp.prototype.sqrTo = nSqrTo;\n\t  // (public) this^e\n\t  function bnPow(e)\n\t  {\n\t    return this.exp(e, new NullExp());\n\t  }\n\t  // (protected) r = lower n words of \"this * a\", a.t <= n\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyLowerTo(a, n, r)\n\t  {\n\t    var i = Math.min(this.t + a.t, n);\n\t    r.s = 0; // assumes a,this >= 0\n\t    r.t = i;\n\t    while (i > 0) r[--i] = 0;\n\t    var j;\n\t    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n\t    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n\t    r.clamp();\n\t  }\n\t  // (protected) r = \"this * a\" without lower n words, n > 0\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyUpperTo(a, n, r)\n\t  {\n\t    --n;\n\t    var i = r.t = this.t + a.t - n;\n\t    r.s = 0; // assumes a,this >= 0\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n\t      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n\t    r.clamp();\n\t    r.drShiftTo(1, r);\n\t  }\n\t  // Barrett modular reduction\n\t  function Barrett(m)\n\t  {\n\t    // setup Barrett\n\t    this.r2 = nbi();\n\t    this.q3 = nbi();\n\t    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n\t    this.mu = this.r2.divide(m);\n\t    this.m = m;\n\t  }\n\t\n\t  function barrettConvert(x)\n\t  {\n\t    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n\t    else if (x.compareTo(this.m) < 0) return x;\n\t    else\n\t    {\n\t      var r = nbi();\n\t      x.copyTo(r);\n\t      this.reduce(r);\n\t      return r;\n\t    }\n\t  }\n\t\n\t  function barrettRevert(x)\n\t  {\n\t    return x;\n\t  }\n\t  // x = x mod m (HAC 14.42)\n\t  function barrettReduce(x)\n\t  {\n\t    x.drShiftTo(this.m.t - 1, this.r2);\n\t    if (x.t > this.m.t + 1)\n\t    {\n\t      x.t = this.m.t + 1;\n\t      x.clamp();\n\t    }\n\t    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n\t    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n\t    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n\t    x.subTo(this.r2, x);\n\t    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t  }\n\t  // r = x^2 mod m; x != r\n\t  function barrettSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  // r = x*y mod m; x,y != r\n\t  function barrettMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t  Barrett.prototype.convert = barrettConvert;\n\t  Barrett.prototype.revert = barrettRevert;\n\t  Barrett.prototype.reduce = barrettReduce;\n\t  Barrett.prototype.mulTo = barrettMulTo;\n\t  Barrett.prototype.sqrTo = barrettSqrTo;\n\t  // (public) this^e % m (HAC 14.85)\n\t  function bnModPow(e, m)\n\t  {\n\t    var i = e.bitLength(),\n\t      k, r = nbv(1),\n\t      z;\n\t    if (i <= 0) return r;\n\t    else if (i < 18) k = 1;\n\t    else if (i < 48) k = 3;\n\t    else if (i < 144) k = 4;\n\t    else if (i < 768) k = 5;\n\t    else k = 6;\n\t    if (i < 8)\n\t      z = new Classic(m);\n\t    else if (m.isEven())\n\t      z = new Barrett(m);\n\t    else\n\t      z = new Montgomery(m);\n\t    // precomputation\n\t    var g = new Array(),\n\t      n = 3,\n\t      k1 = k - 1,\n\t      km = (1 << k) - 1;\n\t    g[1] = z.convert(this);\n\t    if (k > 1)\n\t    {\n\t      var g2 = nbi();\n\t      z.sqrTo(g[1], g2);\n\t      while (n <= km)\n\t      {\n\t        g[n] = nbi();\n\t        z.mulTo(g2, g[n - 2], g[n]);\n\t        n += 2;\n\t      }\n\t    }\n\t    var j = e.t - 1,\n\t      w, is1 = true,\n\t      r2 = nbi(),\n\t      t;\n\t    i = nbits(e[j]) - 1;\n\t    while (j >= 0)\n\t    {\n\t      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n\t      else\n\t      {\n\t        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n\t        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n\t      }\n\t      n = k;\n\t      while ((w & 1) == 0)\n\t      {\n\t        w >>= 1;\n\t        --n;\n\t      }\n\t      if ((i -= n) < 0)\n\t      {\n\t        i += this.DB;\n\t        --j;\n\t      }\n\t      if (is1)\n\t      { // ret == 1, don't bother squaring or multiplying it\n\t        g[w].copyTo(r);\n\t        is1 = false;\n\t      }\n\t      else\n\t      {\n\t        while (n > 1)\n\t        {\n\t          z.sqrTo(r, r2);\n\t          z.sqrTo(r2, r);\n\t          n -= 2;\n\t        }\n\t        if (n > 0) z.sqrTo(r, r2);\n\t        else\n\t        {\n\t          t = r;\n\t          r = r2;\n\t          r2 = t;\n\t        }\n\t        z.mulTo(r2, g[w], r);\n\t      }\n\t      while (j >= 0 && (e[j] & (1 << i)) == 0)\n\t      {\n\t        z.sqrTo(r, r2);\n\t        t = r;\n\t        r = r2;\n\t        r2 = t;\n\t        if (--i < 0)\n\t        {\n\t          i = this.DB - 1;\n\t          --j;\n\t        }\n\t      }\n\t    }\n\t    return z.revert(r);\n\t  }\n\t  // (public) gcd(this,a) (HAC 14.54)\n\t  function bnGCD(a)\n\t  {\n\t    var x = (this.s < 0) ? this.negate() : this.clone();\n\t    var y = (a.s < 0) ? a.negate() : a.clone();\n\t    if (x.compareTo(y) < 0)\n\t    {\n\t      var t = x;\n\t      x = y;\n\t      y = t;\n\t    }\n\t    var i = x.getLowestSetBit(),\n\t      g = y.getLowestSetBit();\n\t    if (g < 0) return x;\n\t    if (i < g) g = i;\n\t    if (g > 0)\n\t    {\n\t      x.rShiftTo(g, x);\n\t      y.rShiftTo(g, y);\n\t    }\n\t    while (x.signum() > 0)\n\t    {\n\t      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n\t      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n\t      if (x.compareTo(y) >= 0)\n\t      {\n\t        x.subTo(y, x);\n\t        x.rShiftTo(1, x);\n\t      }\n\t      else\n\t      {\n\t        y.subTo(x, y);\n\t        y.rShiftTo(1, y);\n\t      }\n\t    }\n\t    if (g > 0) y.lShiftTo(g, y);\n\t    return y;\n\t  }\n\t  // (protected) this % n, n < 2^26\n\t  function bnpModInt(n)\n\t  {\n\t    if (n <= 0) return 0;\n\t    var d = this.DV % n,\n\t      r = (this.s < 0) ? n - 1 : 0;\n\t    if (this.t > 0)\n\t      if (d == 0) r = this[0] % n;\n\t      else\n\t        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n\t    return r;\n\t  }\n\t  // (public) 1/this % m (HAC 14.61)\n\t  function bnModInverse(m)\n\t  {\n\t    var ac = m.isEven();\n\t    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n\t    var u = m.clone(),\n\t      v = this.clone();\n\t    var a = nbv(1),\n\t      b = nbv(0),\n\t      c = nbv(0),\n\t      d = nbv(1);\n\t    while (u.signum() != 0)\n\t    {\n\t      while (u.isEven())\n\t      {\n\t        u.rShiftTo(1, u);\n\t        if (ac)\n\t        {\n\t          if (!a.isEven() || !b.isEven())\n\t          {\n\t            a.addTo(this, a);\n\t            b.subTo(m, b);\n\t          }\n\t          a.rShiftTo(1, a);\n\t        }\n\t        else if (!b.isEven()) b.subTo(m, b);\n\t        b.rShiftTo(1, b);\n\t      }\n\t      while (v.isEven())\n\t      {\n\t        v.rShiftTo(1, v);\n\t        if (ac)\n\t        {\n\t          if (!c.isEven() || !d.isEven())\n\t          {\n\t            c.addTo(this, c);\n\t            d.subTo(m, d);\n\t          }\n\t          c.rShiftTo(1, c);\n\t        }\n\t        else if (!d.isEven()) d.subTo(m, d);\n\t        d.rShiftTo(1, d);\n\t      }\n\t      if (u.compareTo(v) >= 0)\n\t      {\n\t        u.subTo(v, u);\n\t        if (ac) a.subTo(c, a);\n\t        b.subTo(d, b);\n\t      }\n\t      else\n\t      {\n\t        v.subTo(u, v);\n\t        if (ac) c.subTo(a, c);\n\t        d.subTo(b, d);\n\t      }\n\t    }\n\t    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n\t    if (d.compareTo(m) >= 0) return d.subtract(m);\n\t    if (d.signum() < 0) d.addTo(m, d);\n\t    else return d;\n\t    if (d.signum() < 0) return d.add(m);\n\t    else return d;\n\t  }\n\t  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n\t  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n\t  // (public) test primality with certainty >= 1-.5^t\n\t  function bnIsProbablePrime(t)\n\t  {\n\t    var i, x = this.abs();\n\t    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n\t    {\n\t      for (i = 0; i < lowprimes.length; ++i)\n\t        if (x[0] == lowprimes[i]) return true;\n\t      return false;\n\t    }\n\t    if (x.isEven()) return false;\n\t    i = 1;\n\t    while (i < lowprimes.length)\n\t    {\n\t      var m = lowprimes[i],\n\t        j = i + 1;\n\t      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n\t      m = x.modInt(m);\n\t      while (i < j)\n\t        if (m % lowprimes[i++] == 0) return false;\n\t    }\n\t    return x.millerRabin(t);\n\t  }\n\t  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n\t  function bnpMillerRabin(t)\n\t  {\n\t    var n1 = this.subtract(BigInteger.ONE);\n\t    var k = n1.getLowestSetBit();\n\t    if (k <= 0) return false;\n\t    var r = n1.shiftRight(k);\n\t    t = (t + 1) >> 1;\n\t    if (t > lowprimes.length) t = lowprimes.length;\n\t    var a = nbi();\n\t    for (var i = 0; i < t; ++i)\n\t    {\n\t      //Pick bases at random, instead of starting at 2\n\t      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n\t      var y = a.modPow(r, this);\n\t      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n\t      {\n\t        var j = 1;\n\t        while (j++ < k && y.compareTo(n1) != 0)\n\t        {\n\t          y = y.modPowInt(2, this);\n\t          if (y.compareTo(BigInteger.ONE) == 0) return false;\n\t        }\n\t        if (y.compareTo(n1) != 0) return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t  // protected\n\t  BigInteger.prototype.chunkSize = bnpChunkSize;\n\t  BigInteger.prototype.toRadix = bnpToRadix;\n\t  BigInteger.prototype.fromRadix = bnpFromRadix;\n\t  BigInteger.prototype.fromNumber = bnpFromNumber;\n\t  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n\t  BigInteger.prototype.changeBit = bnpChangeBit;\n\t  BigInteger.prototype.addTo = bnpAddTo;\n\t  BigInteger.prototype.dMultiply = bnpDMultiply;\n\t  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n\t  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n\t  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n\t  BigInteger.prototype.modInt = bnpModInt;\n\t  BigInteger.prototype.millerRabin = bnpMillerRabin;\n\t  // public\n\t  BigInteger.prototype.clone = bnClone;\n\t  BigInteger.prototype.intValue = bnIntValue;\n\t  BigInteger.prototype.byteValue = bnByteValue;\n\t  BigInteger.prototype.shortValue = bnShortValue;\n\t  BigInteger.prototype.signum = bnSigNum;\n\t  BigInteger.prototype.toByteArray = bnToByteArray;\n\t  BigInteger.prototype.equals = bnEquals;\n\t  BigInteger.prototype.min = bnMin;\n\t  BigInteger.prototype.max = bnMax;\n\t  BigInteger.prototype.and = bnAnd;\n\t  BigInteger.prototype.or = bnOr;\n\t  BigInteger.prototype.xor = bnXor;\n\t  BigInteger.prototype.andNot = bnAndNot;\n\t  BigInteger.prototype.not = bnNot;\n\t  BigInteger.prototype.shiftLeft = bnShiftLeft;\n\t  BigInteger.prototype.shiftRight = bnShiftRight;\n\t  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n\t  BigInteger.prototype.bitCount = bnBitCount;\n\t  BigInteger.prototype.testBit = bnTestBit;\n\t  BigInteger.prototype.setBit = bnSetBit;\n\t  BigInteger.prototype.clearBit = bnClearBit;\n\t  BigInteger.prototype.flipBit = bnFlipBit;\n\t  BigInteger.prototype.add = bnAdd;\n\t  BigInteger.prototype.subtract = bnSubtract;\n\t  BigInteger.prototype.multiply = bnMultiply;\n\t  BigInteger.prototype.divide = bnDivide;\n\t  BigInteger.prototype.remainder = bnRemainder;\n\t  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n\t  BigInteger.prototype.modPow = bnModPow;\n\t  BigInteger.prototype.modInverse = bnModInverse;\n\t  BigInteger.prototype.pow = bnPow;\n\t  BigInteger.prototype.gcd = bnGCD;\n\t  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\t  // JSBN-specific extension\n\t  BigInteger.prototype.square = bnSquare;\n\t  var Int128 = BigInteger;\n\t  // BigInteger interfaces not implemented in jsbn:\n\t  // BigInteger(int signum, byte[] magnitude)\n\t  // double doubleValue()\n\t  // float floatValue()\n\t  // int hashCode()\n\t  // long longValue()\n\t  // static BigInteger valueOf(long val)\n\t  // Helper functions to make BigInteger functions callable with two parameters\n\t  // as in original C# Clipper\n\t  Int128.prototype.IsNegative = function ()\n\t  {\n\t    if (this.compareTo(Int128.ZERO) == -1) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Equality = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) == 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Inequality = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) != 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_GreaterThan = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) > 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_LessThan = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) < 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Addition = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).add(new Int128(rhs));\n\t  };\n\t  Int128.op_Subtraction = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).subtract(new Int128(rhs));\n\t  };\n\t  Int128.Int128Mul = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).multiply(new Int128(rhs));\n\t  };\n\t  Int128.op_Division = function (lhs, rhs)\n\t  {\n\t    return lhs.divide(rhs);\n\t  };\n\t  Int128.prototype.ToDouble = function ()\n\t  {\n\t    return parseFloat(this.toString()); // This could be something faster\n\t  };\n\t  // end of Int128 section\n\t  /*\n\t  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n\t  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n\t  else self.Int128 = Int128;\n\t  */\n\t\n\t\n\t  // ---------------------------------------------\n\t  // Here starts the actual Clipper library:\n\t  // Helper function to support Inheritance in Javascript\n\t\tvar Inherit = function (ce, ce2)\n\t\t{\n\t\t\tvar p;\n\t\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t\t{\n\t\t\t\tfor (p in ce2.prototype)\n\t\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\t\tfor (p in ce2)\n\t\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\t\tce.$baseCtor = ce2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\t\tfor (p in ce2)\n\t\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\t\tce.$baseCtor = ce2;\n\t\t\t}\n\t\t};\n\t  ClipperLib.Path = function ()\n\t  {\n\t    return [];\n\t  };\n\t  ClipperLib.Paths = function ()\n\t  {\n\t    return []; // Was previously [[]], but caused problems when pushed\n\t  };\n\t  // Preserves the calling way of original C# Clipper\n\t  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n\t  ClipperLib.DoublePoint = function ()\n\t  {\n\t    var a = arguments;\n\t    this.X = 0;\n\t    this.Y = 0;\n\t    // public DoublePoint(DoublePoint dp)\n\t    // public DoublePoint(IntPoint ip)\n\t    if (a.length == 1)\n\t    {\n\t      this.X = a[0].X;\n\t      this.Y = a[0].Y;\n\t    }\n\t    else if (a.length == 2)\n\t    {\n\t      this.X = a[0];\n\t      this.Y = a[1];\n\t    }\n\t  }; // This is internal faster function when called without arguments\n\t  ClipperLib.DoublePoint0 = function ()\n\t  {\n\t    this.X = 0;\n\t    this.Y = 0;\n\t  };\n\t  // This is internal faster function when called with 1 argument (dp or ip)\n\t  ClipperLib.DoublePoint1 = function (dp)\n\t  {\n\t    this.X = dp.X;\n\t    this.Y = dp.Y;\n\t  };\n\t  // This is internal faster function when called with 2 arguments (x and y)\n\t  ClipperLib.DoublePoint2 = function (x, y)\n\t  {\n\t    this.X = x;\n\t    this.Y = y;\n\t  };\n\t  // PolyTree & PolyNode start\n\t  // -------------------------------\n\t  ClipperLib.PolyNode = function ()\n\t  {\n\t    this.m_Parent = null;\n\t    this.m_polygon = new ClipperLib.Path();\n\t    this.m_Index = 0;\n\t    this.m_jointype = 0;\n\t    this.m_endtype = 0;\n\t    this.m_Childs = [];\n\t    this.IsOpen = false;\n\t  };\n\t  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n\t  {\n\t    var result = true;\n\t    var node = this.m_Parent;\n\t    while (node !== null)\n\t    {\n\t      result = !result;\n\t      node = node.m_Parent;\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.PolyNode.prototype.ChildCount = function ()\n\t  {\n\t    return this.m_Childs.length;\n\t  };\n\t  ClipperLib.PolyNode.prototype.Contour = function ()\n\t  {\n\t    return this.m_polygon;\n\t  };\n\t  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n\t  {\n\t    var cnt = this.m_Childs.length;\n\t    this.m_Childs.push(Child);\n\t    Child.m_Parent = this;\n\t    Child.m_Index = cnt;\n\t  };\n\t  ClipperLib.PolyNode.prototype.GetNext = function ()\n\t  {\n\t    if (this.m_Childs.length > 0)\n\t      return this.m_Childs[0];\n\t    else\n\t      return this.GetNextSiblingUp();\n\t  };\n\t  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n\t  {\n\t    if (this.m_Parent === null)\n\t      return null;\n\t    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n\t      return this.m_Parent.GetNextSiblingUp();\n\t    else\n\t      return this.m_Parent.m_Childs[this.m_Index + 1];\n\t  };\n\t  ClipperLib.PolyNode.prototype.Childs = function ()\n\t  {\n\t    return this.m_Childs;\n\t  };\n\t  ClipperLib.PolyNode.prototype.Parent = function ()\n\t  {\n\t    return this.m_Parent;\n\t  };\n\t  ClipperLib.PolyNode.prototype.IsHole = function ()\n\t  {\n\t    return this.IsHoleNode();\n\t  };\n\t  // PolyTree : PolyNode\n\t  ClipperLib.PolyTree = function ()\n\t  {\n\t    this.m_AllPolys = [];\n\t    ClipperLib.PolyNode.call(this);\n\t  };\n\t  ClipperLib.PolyTree.prototype.Clear = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n\t      this.m_AllPolys[i] = null;\n\t    this.m_AllPolys.length = 0;\n\t    this.m_Childs.length = 0;\n\t  };\n\t  ClipperLib.PolyTree.prototype.GetFirst = function ()\n\t  {\n\t    if (this.m_Childs.length > 0)\n\t      return this.m_Childs[0];\n\t    else\n\t      return null;\n\t  };\n\t  ClipperLib.PolyTree.prototype.Total = function ()\n\t  {\n\t\t\tvar result = this.m_AllPolys.length;\n\t\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\t\treturn result;\n\t  };\n\t  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n\t  // -------------------------------\n\t  // PolyTree & PolyNode end\n\t  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n\t  {\n\t    return Math.abs(a);\n\t  };\n\t  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n\t  {\n\t    return Math.max(a, b);\n\t  };\n\t  /*\n\t  -----------------------------------\n\t  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n\t  -----------------------------------\n\t  */\n\t  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n\t  {\n\t    return a | 0;\n\t  };\n\t  else ClipperLib.Cast_Int32 = function (a)\n\t  { // eg. browser.chrome || browser.chromium || browser.firefox\n\t    return~~ a;\n\t  };\n\t  /*\n\t  --------------------------\n\t  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n\t  Chrome: bitwise_not_floor\n\t  Firefox17: toInteger (typeof test)\n\t  IE9: bitwise_or_floor\n\t  IE7 and IE8: to_parseint\n\t  Chromium: to_floor_or_ceil\n\t  Firefox3: to_floor_or_ceil\n\t  Firefox15: to_floor_or_ceil\n\t  Opera: to_floor_or_ceil\n\t  Safari: to_floor_or_ceil\n\t  --------------------------\n\t  */\n\t  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    if (a < -2147483648 || a > 2147483647)\n\t      return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t    else return~~ a;\n\t  };\n\t  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return Number.toInteger(a);\n\t  };\n\t  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return parseInt(a, 10);\n\t  };\n\t  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    if (a < -2147483648 || a > 2147483647)\n\t      return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t    return a | 0;\n\t  };\n\t  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n\t  else ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t  };\n\t  ClipperLib.Clear = function (a)\n\t  {\n\t    a.length = 0;\n\t  };\n\t  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n\t  ClipperLib.PI = 3.141592653589793;\n\t  ClipperLib.PI2 = 2 * 3.141592653589793;\n\t  ClipperLib.IntPoint = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    this.X = 0;\n\t    this.Y = 0;\n\t    if (use_xyz)\n\t    {\n\t      this.Z = 0;\n\t      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t        this.Z = a[2];\n\t      }\n\t      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t        this.Z = 0;\n\t      }\n\t      else if (alen == 1)\n\t      {\n\t        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t        {\n\t          var dp = a[0];\n\t          this.X = ClipperLib.Clipper.Round(dp.X);\n\t          this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t          this.Z = 0;\n\t        }\n\t        else // public IntPoint(IntPoint pt)\n\t        {\n\t          var pt = a[0];\n\t          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n\t          this.X = pt.X;\n\t          this.Y = pt.Y;\n\t          this.Z = pt.Z;\n\t        }\n\t      }\n\t      else // public IntPoint()\n\t      {\n\t        this.X = 0;\n\t        this.Y = 0;\n\t        this.Z = 0;\n\t      }\n\t    }\n\t    else // if (!use_xyz)\n\t    {\n\t      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t      }\n\t      else if (alen == 1)\n\t      {\n\t        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t        {\n\t          var dp = a[0];\n\t          this.X = ClipperLib.Clipper.Round(dp.X);\n\t          this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t        }\n\t        else // public IntPoint(IntPoint pt)\n\t        {\n\t          var pt = a[0];\n\t          this.X = pt.X;\n\t          this.Y = pt.Y;\n\t        }\n\t      }\n\t      else // public IntPoint(IntPoint pt)\n\t      {\n\t        this.X = 0;\n\t        this.Y = 0;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.IntPoint.op_Equality = function (a, b)\n\t  {\n\t    //return a == b;\n\t    return a.X == b.X && a.Y == b.Y;\n\t  };\n\t  ClipperLib.IntPoint.op_Inequality = function (a, b)\n\t  {\n\t    //return a != b;\n\t    return a.X != b.X || a.Y != b.Y;\n\t  };\n\t  /*\n\t  ClipperLib.IntPoint.prototype.Equals = function (obj)\n\t  {\n\t    if (obj === null)\n\t        return false;\n\t    if (obj instanceof ClipperLib.IntPoint)\n\t    {\n\t        var a = Cast(obj, ClipperLib.IntPoint);\n\t        return (this.X == a.X) && (this.Y == a.Y);\n\t    }\n\t    else\n\t        return false;\n\t  };\n\t*/\n\t  if (use_xyz)\n\t  {\n\t    ClipperLib.IntPoint0 = function ()\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint1 = function (pt)\n\t    {\n\t      this.X = pt.X;\n\t      this.Y = pt.Y;\n\t      this.Z = pt.Z;\n\t    };\n\t    ClipperLib.IntPoint1dp = function (dp)\n\t    {\n\t      this.X = ClipperLib.Clipper.Round(dp.X);\n\t      this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint2 = function (x, y)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint3 = function (x, y, z)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t      this.Z = z;\n\t    };\n\t  }\n\t  else // if (!use_xyz)\n\t  {\n\t    ClipperLib.IntPoint0 = function ()\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t    };\n\t    ClipperLib.IntPoint1 = function (pt)\n\t    {\n\t      this.X = pt.X;\n\t      this.Y = pt.Y;\n\t    };\n\t    ClipperLib.IntPoint1dp = function (dp)\n\t    {\n\t      this.X = ClipperLib.Clipper.Round(dp.X);\n\t      this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t    };\n\t    ClipperLib.IntPoint2 = function (x, y)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t    };\n\t  }\n\t  ClipperLib.IntRect = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    if (alen == 4) // function (l, t, r, b)\n\t    {\n\t      this.left = a[0];\n\t      this.top = a[1];\n\t      this.right = a[2];\n\t      this.bottom = a[3];\n\t    }\n\t    else if (alen == 1) // function (ir)\n\t    {\n\t      this.left = ir.left;\n\t      this.top = ir.top;\n\t      this.right = ir.right;\n\t      this.bottom = ir.bottom;\n\t    }\n\t    else // function ()\n\t    {\n\t      this.left = 0;\n\t      this.top = 0;\n\t      this.right = 0;\n\t      this.bottom = 0;\n\t    }\n\t  };\n\t  ClipperLib.IntRect0 = function ()\n\t  {\n\t    this.left = 0;\n\t    this.top = 0;\n\t    this.right = 0;\n\t    this.bottom = 0;\n\t  };\n\t  ClipperLib.IntRect1 = function (ir)\n\t  {\n\t    this.left = ir.left;\n\t    this.top = ir.top;\n\t    this.right = ir.right;\n\t    this.bottom = ir.bottom;\n\t  };\n\t  ClipperLib.IntRect4 = function (l, t, r, b)\n\t  {\n\t    this.left = l;\n\t    this.top = t;\n\t    this.right = r;\n\t    this.bottom = b;\n\t  };\n\t  ClipperLib.ClipType = {\n\t    ctIntersection: 0,\n\t    ctUnion: 1,\n\t    ctDifference: 2,\n\t    ctXor: 3\n\t  };\n\t  ClipperLib.PolyType = {\n\t    ptSubject: 0,\n\t    ptClip: 1\n\t  };\n\t  ClipperLib.PolyFillType = {\n\t    pftEvenOdd: 0,\n\t    pftNonZero: 1,\n\t    pftPositive: 2,\n\t    pftNegative: 3\n\t  };\n\t  ClipperLib.JoinType = {\n\t    jtSquare: 0,\n\t    jtRound: 1,\n\t    jtMiter: 2\n\t  };\n\t  ClipperLib.EndType = {\n\t    etOpenSquare: 0,\n\t    etOpenRound: 1,\n\t    etOpenButt: 2,\n\t    etClosedLine: 3,\n\t    etClosedPolygon: 4\n\t  };\n\t  ClipperLib.EdgeSide = {\n\t    esLeft: 0,\n\t    esRight: 1\n\t  };\n\t  ClipperLib.Direction = {\n\t    dRightToLeft: 0,\n\t    dLeftToRight: 1\n\t  };\n\t  ClipperLib.TEdge = function ()\n\t  {\n\t    this.Bot = new ClipperLib.IntPoint();\n\t    this.Curr = new ClipperLib.IntPoint();\n\t    this.Top = new ClipperLib.IntPoint();\n\t    this.Delta = new ClipperLib.IntPoint();\n\t    this.Dx = 0;\n\t    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n\t    this.Side = ClipperLib.EdgeSide.esLeft;\n\t    this.WindDelta = 0;\n\t    this.WindCnt = 0;\n\t    this.WindCnt2 = 0;\n\t    this.OutIdx = 0;\n\t    this.Next = null;\n\t    this.Prev = null;\n\t    this.NextInLML = null;\n\t    this.NextInAEL = null;\n\t    this.PrevInAEL = null;\n\t    this.NextInSEL = null;\n\t    this.PrevInSEL = null;\n\t  };\n\t  ClipperLib.IntersectNode = function ()\n\t  {\n\t    this.Edge1 = null;\n\t    this.Edge2 = null;\n\t    this.Pt = new ClipperLib.IntPoint();\n\t  };\n\t  ClipperLib.MyIntersectNodeSort = function () {};\n\t  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n\t  {\n\t    var i = node2.Pt.Y - node1.Pt.Y;\n\t    if (i > 0) return 1;\n\t    else if (i < 0) return -1;\n\t    else return 0;\n\t  };\n\t\n\t  ClipperLib.LocalMinima = function ()\n\t  {\n\t    this.Y = 0;\n\t    this.LeftBound = null;\n\t    this.RightBound = null;\n\t    this.Next = null;\n\t  };\n\t  ClipperLib.Scanbeam = function ()\n\t  {\n\t    this.Y = 0;\n\t    this.Next = null;\n\t  };\n\t  ClipperLib.OutRec = function ()\n\t  {\n\t    this.Idx = 0;\n\t    this.IsHole = false;\n\t    this.IsOpen = false;\n\t    this.FirstLeft = null;\n\t    this.Pts = null;\n\t    this.BottomPt = null;\n\t    this.PolyNode = null;\n\t  };\n\t  ClipperLib.OutPt = function ()\n\t  {\n\t    this.Idx = 0;\n\t    this.Pt = new ClipperLib.IntPoint();\n\t    this.Next = null;\n\t    this.Prev = null;\n\t  };\n\t  ClipperLib.Join = function ()\n\t  {\n\t    this.OutPt1 = null;\n\t    this.OutPt2 = null;\n\t    this.OffPt = new ClipperLib.IntPoint();\n\t  };\n\t  ClipperLib.ClipperBase = function ()\n\t  {\n\t    this.m_MinimaList = null;\n\t    this.m_CurrentLM = null;\n\t    this.m_edges = new Array();\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t    this.PreserveCollinear = false;\n\t    this.m_MinimaList = null;\n\t    this.m_CurrentLM = null;\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t  };\n\t  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n\t  // protected const double horizontal = -3.4E+38;\n\t  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n\t  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n\t  // So had to adjust them to more suitable for Javascript.\n\t  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n\t  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n\t  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n\t  ClipperLib.ClipperBase.Skip = -2;\n\t  ClipperLib.ClipperBase.Unassigned = -1;\n\t  ClipperLib.ClipperBase.tolerance = 1E-20;\n\t  if (use_int32)\n\t  {\n\t    ClipperLib.ClipperBase.loRange = 0x7FFF;\n\t    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n\t  }\n\t  else\n\t  {\n\t    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n\t    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n\t  }\n\t\n\t  ClipperLib.ClipperBase.near_zero = function (val)\n\t  {\n\t    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n\t  };\n\t  ClipperLib.ClipperBase.IsHorizontal = function (e)\n\t  {\n\t    return e.Delta.Y === 0;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n\t  {\n\t    var pp2 = pp;\n\t    do {\n\t      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n\t        return true;\n\t      pp2 = pp2.Next;\n\t    }\n\t    while (pp2 != pp)\n\t    return false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n\t        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n\t        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n\t        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n\t        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n\t          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n\t    else\n\t      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n\t  {\n\t    var pp2 = pp;\n\t    while (true)\n\t    {\n\t      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n\t        return true;\n\t      pp2 = pp2.Next;\n\t      if (pp2 == pp)\n\t        break;\n\t    }\n\t    return false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n\t    if (alen == 3) // function (e1, e2, UseFullRange)\n\t    {\n\t      e1 = a[0];\n\t      e2 = a[1];\n\t      UseFullRange = a[2];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t    }\n\t    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n\t    {\n\t      pt1 = a[0];\n\t      pt2 = a[1];\n\t      pt3 = a[2];\n\t      UseFullRange = a[3];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t    }\n\t    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n\t    {\n\t      pt1 = a[0];\n\t      pt2 = a[1];\n\t      pt3 = a[2];\n\t      pt4 = a[3];\n\t      UseFullRange = a[4];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.Clear = function ()\n\t  {\n\t    this.DisposeLocalMinimaList();\n\t    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n\t    {\n\t      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n\t        this.m_edges[i][j] = null;\n\t      ClipperLib.Clear(this.m_edges[i]);\n\t    }\n\t    ClipperLib.Clear(this.m_edges);\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n\t  {\n\t    while (this.m_MinimaList !== null)\n\t    {\n\t      var tmpLm = this.m_MinimaList.Next;\n\t      this.m_MinimaList = null;\n\t      this.m_MinimaList = tmpLm;\n\t    }\n\t    this.m_CurrentLM = null;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n\t  {\n\t    if (useFullRange.Value)\n\t    {\n\t      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n\t        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n\t    }\n\t    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n\t    {\n\t      useFullRange.Value = true;\n\t      this.RangeTest(Pt, useFullRange);\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n\t  {\n\t    e.Next = eNext;\n\t    e.Prev = ePrev;\n\t    //e.Curr = pt;\n\t    e.Curr.X = pt.X;\n\t    e.Curr.Y = pt.Y;\n\t    e.OutIdx = -1;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n\t  {\n\t    if (e.Curr.Y >= e.Next.Curr.Y)\n\t    {\n\t      //e.Bot = e.Curr;\n\t      e.Bot.X = e.Curr.X;\n\t      e.Bot.Y = e.Curr.Y;\n\t      //e.Top = e.Next.Curr;\n\t      e.Top.X = e.Next.Curr.X;\n\t      e.Top.Y = e.Next.Curr.Y;\n\t    }\n\t    else\n\t    {\n\t      //e.Top = e.Curr;\n\t      e.Top.X = e.Curr.X;\n\t      e.Top.Y = e.Curr.Y;\n\t      //e.Bot = e.Next.Curr;\n\t      e.Bot.X = e.Next.Curr.X;\n\t      e.Bot.Y = e.Next.Curr.Y;\n\t    }\n\t    this.SetDx(e);\n\t    e.PolyTyp = polyType;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n\t  {\n\t    var E2;\n\t    for (;;)\n\t    {\n\t      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n\t        E = E.Next;\n\t      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n\t        break;\n\t      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Prev;\n\t      E2 = E;\n\t      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Next;\n\t      if (E.Top.Y == E.Prev.Bot.Y)\n\t        continue;\n\t      //ie just an intermediate horz.\n\t      if (E2.Prev.Bot.X < E.Bot.X)\n\t        E = E2;\n\t      break;\n\t    }\n\t    return E;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n\t  {\n\t    var EStart;\n\t    var Result = E;\n\t    var Horz;\n\t\n\t      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      {\n\t        //check if there are edges beyond the skip edge in the bound and if so\n\t        //create another LocMin and calling ProcessBound once more ...\n\t        E = Result;\n\t        if (LeftBoundIsForward)\n\t        {\n\t          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n\t          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n\t        }\n\t        else\n\t        {\n\t          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n\t          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n\t        }\n\t        if (E == Result)\n\t        {\n\t          if (LeftBoundIsForward) Result = E.Next;\n\t          else Result = E.Prev;\n\t        }\n\t        else\n\t        {\n\t          //there are more edges in the bound beyond result starting with E\n\t          if (LeftBoundIsForward)\n\t            E = Result.Next;\n\t          else\n\t            E = Result.Prev;\n\t          var locMin = new ClipperLib.LocalMinima();\n\t          locMin.Next = null;\n\t          locMin.Y = E.Bot.Y;\n\t          locMin.LeftBound = null;\n\t          locMin.RightBound = E;\n\t          E.WindDelta = 0;\n\t          Result = this.ProcessBound(E, LeftBoundIsForward);\n\t          this.InsertLocalMinima(locMin);\n\t        }\n\t        return Result;\n\t      }\n\t\n\t      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t      {\n\t        //We need to be careful with open paths because this may not be a\n\t        //true local minima (ie E may be following a skip edge).\n\t        //Also, consecutive horz. edges may start heading left before going right.\n\t        if (LeftBoundIsForward) EStart = E.Prev;\n\t        else EStart = E.Next;\n\t        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n\t          {\n\t            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n\t              this.ReverseHorizontal(E);\n\t          }\n\t          else if (EStart.Bot.X != E.Bot.X)\n\t            this.ReverseHorizontal(E);\n\t        }\n\t      }\n\t\n\t      EStart = E;\n\t      if (LeftBoundIsForward)\n\t      {\n\t        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t          Result = Result.Next;\n\t        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          //nb: at the top of a bound, horizontals are added to the bound\n\t          //only when the preceding edge attaches to the horizontal's left vertex\n\t          //unless a Skip edge is encountered when that becomes the top divide\n\t          Horz = Result;\n\t          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t            Horz = Horz.Prev;\n\t          if (Horz.Prev.Top.X == Result.Next.Top.X)\n\t          {\n\t            if (!LeftBoundIsForward)\n\t              Result = Horz.Prev;\n\t          }\n\t          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n\t            Result = Horz.Prev;\n\t        }\n\t        while (E != Result)\n\t        {\n\t          E.NextInLML = E.Next;\n\t          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t            this.ReverseHorizontal(E);\n\t          E = E.Next;\n\t        }\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        Result = Result.Next;\n\t        //move to the edge just beyond current bound\n\t      }\n\t      else\n\t      {\n\t        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t          Result = Result.Prev;\n\t        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          Horz = Result;\n\t          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n\t            Horz = Horz.Next;\n\t          if (Horz.Next.Top.X == Result.Prev.Top.X)\n\t          {\n\t            if (!LeftBoundIsForward)\n\t              Result = Horz.Next;\n\t          }\n\t          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n\t            Result = Horz.Next;\n\t        }\n\t        while (E != Result)\n\t        {\n\t          E.NextInLML = E.Prev;\n\t          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t            this.ReverseHorizontal(E);\n\t          E = E.Prev;\n\t        }\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        Result = Result.Prev;\n\t        //move to the edge just beyond current bound\n\t      }\n\t\n\t    return Result;\n\t  };\n\t\n\t  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n\t  {\n\t    if (use_lines)\n\t    {\n\t      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n\t        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n\t    }\n\t    else\n\t    {\n\t      if (!Closed)\n\t        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n\t    }\n\t    var highI = pg.length - 1;\n\t    if (Closed)\n\t      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n\t    --highI;\n\t    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n\t    --highI;\n\t    if ((Closed && highI < 2) || (!Closed && highI < 1))\n\t      return false;\n\t    //create a new edge array ...\n\t    var edges = new Array();\n\t    for (var i = 0; i <= highI; i++)\n\t      edges.push(new ClipperLib.TEdge());\n\t    var IsFlat = true;\n\t    //1. Basic (first) edge initialization ...\n\t\n\t    //edges[1].Curr = pg[1];\n\t    edges[1].Curr.X = pg[1].X;\n\t    edges[1].Curr.Y = pg[1].Y;\n\t\n\t    var $1 = {Value: this.m_UseFullRange};\n\t    this.RangeTest(pg[0], $1);\n\t    this.m_UseFullRange = $1.Value;\n\t\n\t    $1.Value = this.m_UseFullRange;\n\t    this.RangeTest(pg[highI], $1);\n\t    this.m_UseFullRange = $1.Value;\n\t\n\t    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n\t    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n\t    for (var i = highI - 1; i >= 1; --i)\n\t    {\n\t      $1.Value = this.m_UseFullRange;\n\t      this.RangeTest(pg[i], $1);\n\t      this.m_UseFullRange = $1.Value;\n\t\n\t      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n\t    }\n\t\n\t    var eStart = edges[0];\n\t    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n\t    var E = eStart,\n\t      eLoopStop = eStart;\n\t    for (;;)\n\t    {\n\t    //console.log(E.Next, eStart);\n\t    \t//nb: allows matching start and end points when not Closed ...\n\t      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n\t      {\n\t        if (E == E.Next)\n\t          break;\n\t        if (E == eStart)\n\t          eStart = E.Next;\n\t        E = this.RemoveEdge(E);\n\t        eLoopStop = E;\n\t        continue;\n\t      }\n\t      if (E.Prev == E.Next)\n\t        break;\n\t      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n\t      {\n\t        //Collinear edges are allowed for open paths but in closed paths\n\t        //the default is to merge adjacent collinear edges into a single edge.\n\t        //However, if the PreserveCollinear property is enabled, only overlapping\n\t        //collinear edges (ie spikes) will be removed from closed paths.\n\t        if (E == eStart)\n\t          eStart = E.Next;\n\t        E = this.RemoveEdge(E);\n\t        E = E.Prev;\n\t        eLoopStop = E;\n\t        continue;\n\t      }\n\t      E = E.Next;\n\t      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n\t    }\n\t    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n\t      return false;\n\t    if (!Closed)\n\t    {\n\t      this.m_HasOpenPaths = true;\n\t      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t    }\n\t    //3. Do second stage of edge initialization ...\n\t    E = eStart;\n\t    do {\n\t      this.InitEdge2(E, polyType);\n\t      E = E.Next;\n\t      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n\t        IsFlat = false;\n\t    }\n\t    while (E != eStart)\n\t    //4. Finally, add edge bounds to LocalMinima list ...\n\t    //Totally flat paths must be handled differently when adding them\n\t    //to LocalMinima list to avoid endless loops etc ...\n\t    if (IsFlat)\n\t    {\n\t      if (Closed)\n\t        return false;\n\t      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t      if (E.Prev.Bot.X < E.Prev.Top.X)\n\t        this.ReverseHorizontal(E.Prev);\n\t      var locMin = new ClipperLib.LocalMinima();\n\t      locMin.Next = null;\n\t      locMin.Y = E.Bot.Y;\n\t      locMin.LeftBound = null;\n\t      locMin.RightBound = E;\n\t      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t      locMin.RightBound.WindDelta = 0;\n\t      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t      {\n\t        E.NextInLML = E.Next;\n\t        if (E.Bot.X != E.Prev.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        E = E.Next;\n\t      }\n\t      this.InsertLocalMinima(locMin);\n\t      this.m_edges.push(edges);\n\t      return true;\n\t    }\n\t    this.m_edges.push(edges);\n\t    var leftBoundIsForward;\n\t    var EMin = null;\n\t\n\t\t\t//workaround to avoid an endless loop in the while loop below when\n\t    //open paths have matching start and end points ...\n\t    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n\t    \tE = E.Next;\n\t\n\t    for (;;)\n\t    {\n\t      E = this.FindNextLocMin(E);\n\t      if (E == EMin)\n\t        break;\n\t      else if (EMin == null)\n\t        EMin = E;\n\t      //E and E.Prev now share a local minima (left aligned if horizontal).\n\t      //Compare their slopes to find which starts which bound ...\n\t      var locMin = new ClipperLib.LocalMinima();\n\t      locMin.Next = null;\n\t      locMin.Y = E.Bot.Y;\n\t      if (E.Dx < E.Prev.Dx)\n\t      {\n\t        locMin.LeftBound = E.Prev;\n\t        locMin.RightBound = E;\n\t        leftBoundIsForward = false;\n\t        //Q.nextInLML = Q.prev\n\t      }\n\t      else\n\t      {\n\t        locMin.LeftBound = E;\n\t        locMin.RightBound = E.Prev;\n\t        leftBoundIsForward = true;\n\t        //Q.nextInLML = Q.next\n\t      }\n\t      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n\t      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t      if (!Closed)\n\t        locMin.LeftBound.WindDelta = 0;\n\t      else if (locMin.LeftBound.Next == locMin.RightBound)\n\t        locMin.LeftBound.WindDelta = -1;\n\t      else\n\t        locMin.LeftBound.WindDelta = 1;\n\t      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n\t      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n\t      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      \tE = this.ProcessBound(E, leftBoundIsForward);\n\t      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n\t      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n\t      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t        locMin.LeftBound = null;\n\t      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t        locMin.RightBound = null;\n\t      this.InsertLocalMinima(locMin);\n\t      if (!leftBoundIsForward)\n\t        E = E2;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n\t  {\n\t    //  console.log(\"-------------------------------------------\");\n\t    //  console.log(JSON.stringify(ppg));\n\t    var result = false;\n\t    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n\t      if (this.AddPath(ppg[i], polyType, closed))\n\t        result = true;\n\t    return result;\n\t  };\n\t  //------------------------------------------------------------------------------\n\t  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n\t  {\n\t    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\t\n\t   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n\t   return false;\n\t\n\t    else if (pt1.X != pt3.X)\n\t      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n\t    else\n\t      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n\t  };\n\t  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n\t  {\n\t    //removes e from double_linked_list (but without removing from memory)\n\t    e.Prev.Next = e.Next;\n\t    e.Next.Prev = e.Prev;\n\t    var result = e.Next;\n\t    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n\t    return result;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n\t  {\n\t    e.Delta.X = (e.Top.X - e.Bot.X);\n\t    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n\t    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n\t    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n\t  {\n\t    if (this.m_MinimaList === null)\n\t    {\n\t      this.m_MinimaList = newLm;\n\t    }\n\t    else if (newLm.Y >= this.m_MinimaList.Y)\n\t    {\n\t      newLm.Next = this.m_MinimaList;\n\t      this.m_MinimaList = newLm;\n\t    }\n\t    else\n\t    {\n\t      var tmpLm = this.m_MinimaList;\n\t      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n\t        tmpLm = tmpLm.Next;\n\t      newLm.Next = tmpLm.Next;\n\t      tmpLm.Next = newLm;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n\t  {\n\t    if (this.m_CurrentLM === null)\n\t      return;\n\t    this.m_CurrentLM = this.m_CurrentLM.Next;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n\t  {\n\t    //swap horizontal edges' top and bottom x's so they follow the natural\n\t    //progression of the bounds - ie so their xbots will align with the\n\t    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n\t    var tmp = e.Top.X;\n\t    e.Top.X = e.Bot.X;\n\t    e.Bot.X = tmp;\n\t    if (use_xyz)\n\t    {\n\t      tmp = e.Top.Z;\n\t      e.Top.Z = e.Bot.Z;\n\t      e.Bot.Z = tmp;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.Reset = function ()\n\t  {\n\t    this.m_CurrentLM = this.m_MinimaList;\n\t    if (this.m_CurrentLM == null)\n\t      return;\n\t    //ie nothing to process\n\t    //reset all edges ...\n\t    var lm = this.m_MinimaList;\n\t    while (lm != null)\n\t    {\n\t      var e = lm.LeftBound;\n\t      if (e != null)\n\t      {\n\t        //e.Curr = e.Bot;\n\t        e.Curr.X = e.Bot.X;\n\t        e.Curr.Y = e.Bot.Y;\n\t        e.Side = ClipperLib.EdgeSide.esLeft;\n\t        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t      }\n\t      e = lm.RightBound;\n\t      if (e != null)\n\t      {\n\t        //e.Curr = e.Bot;\n\t        e.Curr.X = e.Bot.X;\n\t        e.Curr.Y = e.Bot.Y;\n\t        e.Side = ClipperLib.EdgeSide.esRight;\n\t        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t      }\n\t      lm = lm.Next;\n\t    }\n\t  };\n\t  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n\t  {\n\t    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n\t    this.m_PolyOuts = null;\n\t    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t    this.m_IntersectList = null;\n\t    this.m_IntersectNodeComparer = null;\n\t    this.m_ExecuteLocked = false;\n\t    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    this.m_Joins = null;\n\t    this.m_GhostJoins = null;\n\t    this.m_UsingPolyTree = false;\n\t    this.ReverseSolution = false;\n\t    this.StrictlySimple = false;\n\t    ClipperLib.ClipperBase.call(this);\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t    this.m_IntersectList = new Array();\n\t    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n\t    this.m_ExecuteLocked = false;\n\t    this.m_UsingPolyTree = false;\n\t    this.m_PolyOuts = new Array();\n\t    this.m_Joins = new Array();\n\t    this.m_GhostJoins = new Array();\n\t    this.ReverseSolution = (1 & InitOptions) !== 0;\n\t    this.StrictlySimple = (2 & InitOptions) !== 0;\n\t    this.PreserveCollinear = (4 & InitOptions) !== 0;\n\t    if (use_xyz)\n\t    {\n\t      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.ioReverseSolution = 1;\n\t  ClipperLib.Clipper.ioStrictlySimple = 2;\n\t  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\t\n\t  ClipperLib.Clipper.prototype.Clear = function ()\n\t  {\n\t    if (this.m_edges.length === 0)\n\t      return;\n\t    //avoids problems with ClipperBase destructor\n\t    this.DisposeAllPolyPts();\n\t    ClipperLib.ClipperBase.prototype.Clear.call(this);\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n\t  {\n\t    while (this.m_Scanbeam !== null)\n\t    {\n\t      var sb2 = this.m_Scanbeam.Next;\n\t      this.m_Scanbeam = null;\n\t      this.m_Scanbeam = sb2;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.Reset = function ()\n\t  {\n\t    ClipperLib.ClipperBase.prototype.Reset.call(this);\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t\n\t    var lm = this.m_MinimaList;\n\t    while (lm !== null)\n\t    {\n\t      this.InsertScanbeam(lm.Y);\n\t      lm = lm.Next;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n\t  {\n\t    if (this.m_Scanbeam === null)\n\t    {\n\t      this.m_Scanbeam = new ClipperLib.Scanbeam();\n\t      this.m_Scanbeam.Next = null;\n\t      this.m_Scanbeam.Y = Y;\n\t    }\n\t    else if (Y > this.m_Scanbeam.Y)\n\t    {\n\t      var newSb = new ClipperLib.Scanbeam();\n\t      newSb.Y = Y;\n\t      newSb.Next = this.m_Scanbeam;\n\t      this.m_Scanbeam = newSb;\n\t    }\n\t    else\n\t    {\n\t      var sb2 = this.m_Scanbeam;\n\t      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n\t        sb2 = sb2.Next;\n\t      if (Y == sb2.Y)\n\t        return;\n\t      //ie ignores duplicates\n\t      var newSb = new ClipperLib.Scanbeam();\n\t      newSb.Y = Y;\n\t      newSb.Next = sb2.Next;\n\t      sb2.Next = newSb;\n\t    }\n\t  };\n\t  // ************************************\n\t  ClipperLib.Clipper.prototype.Execute = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length,\n\t      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n\t    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n\t    {\n\t      var clipType = a[0],\n\t        solution = a[1],\n\t        subjFillType = a[2],\n\t        clipFillType = a[3];\n\t      if (this.m_ExecuteLocked)\n\t        return false;\n\t      if (this.m_HasOpenPaths)\n\t        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n\t      this.m_ExecuteLocked = true;\n\t      ClipperLib.Clear(solution);\n\t      this.m_SubjFillType = subjFillType;\n\t      this.m_ClipFillType = clipFillType;\n\t      this.m_ClipType = clipType;\n\t      this.m_UsingPolyTree = false;\n\t      try\n\t      {\n\t        var succeeded = this.ExecuteInternal();\n\t        //build the return polygons ...\n\t        if (succeeded) this.BuildResult(solution);\n\t      }\n\t      finally\n\t      {\n\t        this.DisposeAllPolyPts();\n\t        this.m_ExecuteLocked = false;\n\t      }\n\t      return succeeded;\n\t    }\n\t    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n\t    {\n\t      var clipType = a[0],\n\t        polytree = a[1],\n\t        subjFillType = a[2],\n\t        clipFillType = a[3];\n\t      if (this.m_ExecuteLocked)\n\t        return false;\n\t      this.m_ExecuteLocked = true;\n\t      this.m_SubjFillType = subjFillType;\n\t      this.m_ClipFillType = clipFillType;\n\t      this.m_ClipType = clipType;\n\t      this.m_UsingPolyTree = true;\n\t      try\n\t      {\n\t        var succeeded = this.ExecuteInternal();\n\t        //build the return polygons ...\n\t        if (succeeded) this.BuildResult2(polytree);\n\t      }\n\t      finally\n\t      {\n\t        this.DisposeAllPolyPts();\n\t        this.m_ExecuteLocked = false;\n\t      }\n\t      return succeeded;\n\t    }\n\t    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n\t    {\n\t      var clipType = a[0],\n\t        solution = a[1];\n\t      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t    }\n\t    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n\t    {\n\t      var clipType = a[0],\n\t        polytree = a[1];\n\t      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n\t  {\n\t    //skip if an outermost polygon or\n\t    //already already points to the correct FirstLeft ...\n\t    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n\t      return;\n\t    var orfl = outRec.FirstLeft;\n\t    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n\t      orfl = orfl.FirstLeft;\n\t    outRec.FirstLeft = orfl;\n\t  };\n\t  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n\t  {\n\t    try\n\t    {\n\t      this.Reset();\n\t      if (this.m_CurrentLM === null)\n\t        return false;\n\t      var botY = this.PopScanbeam();\n\t      do {\n\t        this.InsertLocalMinimaIntoAEL(botY);\n\t        ClipperLib.Clear(this.m_GhostJoins);\n\t        this.ProcessHorizontals(false);\n\t        if (this.m_Scanbeam === null)\n\t          break;\n\t        var topY = this.PopScanbeam();\n\t        if (!this.ProcessIntersections(topY)) return false;\n\t\n\t        this.ProcessEdgesAtTopOfScanbeam(topY);\n\t        botY = topY;\n\t      }\n\t      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n\t      //fix orientations ...\n\t      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t      {\n\t        var outRec = this.m_PolyOuts[i];\n\t        if (outRec.Pts === null || outRec.IsOpen)\n\t          continue;\n\t        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n\t          this.ReversePolyPtLinks(outRec.Pts);\n\t      }\n\t      this.JoinCommonEdges();\n\t      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t      {\n\t        var outRec = this.m_PolyOuts[i];\n\t        if (outRec.Pts !== null && !outRec.IsOpen)\n\t          this.FixupOutPolygon(outRec);\n\t      }\n\t      if (this.StrictlySimple)\n\t        this.DoSimplePolygons();\n\t      return true;\n\t    }\n\t    finally\n\t    {\n\t      ClipperLib.Clear(this.m_Joins);\n\t      ClipperLib.Clear(this.m_GhostJoins);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n\t  {\n\t    var Y = this.m_Scanbeam.Y;\n\t    this.m_Scanbeam = this.m_Scanbeam.Next;\n\t    return Y;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n\t      this.DisposeOutRec(i);\n\t    ClipperLib.Clear(this.m_PolyOuts);\n\t  };\n\t  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n\t  {\n\t    var outRec = this.m_PolyOuts[index];\n\t    outRec.Pts = null;\n\t    outRec = null;\n\t    this.m_PolyOuts[index] = null;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n\t  {\n\t    var j = new ClipperLib.Join();\n\t    j.OutPt1 = Op1;\n\t    j.OutPt2 = Op2;\n\t    //j.OffPt = OffPt;\n\t    j.OffPt.X = OffPt.X;\n\t    j.OffPt.Y = OffPt.Y;\n\t    this.m_Joins.push(j);\n\t  };\n\t  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n\t  {\n\t    var j = new ClipperLib.Join();\n\t    j.OutPt1 = Op;\n\t    //j.OffPt = OffPt;\n\t    j.OffPt.X = OffPt.X;\n\t    j.OffPt.Y = OffPt.Y;\n\t    this.m_GhostJoins.push(j);\n\t  };\n\t  if (use_xyz)\n\t  {\n\t    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n\t    {\n\t      if (this.ZFillFunction !== null)\n\t      {\n\t        if (pt.Z != 0 || this.ZFillFunction === null) return;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n\t        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n\t      }\n\t    };\n\t\n\t    //------------------------------------------------------------------------------\n\t  }\n\t\n\t  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n\t  {\n\t    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n\t    {\n\t      var lb = this.m_CurrentLM.LeftBound;\n\t      var rb = this.m_CurrentLM.RightBound;\n\t      this.PopLocalMinima();\n\t      var Op1 = null;\n\t      if (lb === null)\n\t      {\n\t        this.InsertEdgeIntoAEL(rb, null);\n\t        this.SetWindingCount(rb);\n\t        if (this.IsContributing(rb))\n\t          Op1 = this.AddOutPt(rb, rb.Bot);\n\t      }\n\t      else if (rb == null)\n\t      {\n\t        this.InsertEdgeIntoAEL(lb, null);\n\t        this.SetWindingCount(lb);\n\t        if (this.IsContributing(lb))\n\t          Op1 = this.AddOutPt(lb, lb.Bot);\n\t        this.InsertScanbeam(lb.Top.Y);\n\t      }\n\t      else\n\t      {\n\t        this.InsertEdgeIntoAEL(lb, null);\n\t        this.InsertEdgeIntoAEL(rb, lb);\n\t        this.SetWindingCount(lb);\n\t        rb.WindCnt = lb.WindCnt;\n\t        rb.WindCnt2 = lb.WindCnt2;\n\t        if (this.IsContributing(lb))\n\t          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n\t        this.InsertScanbeam(lb.Top.Y);\n\t      }\n\t      if (rb != null)\n\t      {\n\t        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n\t          this.AddEdgeToSEL(rb);\n\t        else\n\t          this.InsertScanbeam(rb.Top.Y);\n\t      }\n\t      if (lb == null || rb == null) continue;\n\t      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n\t      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n\t      {\n\t        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n\t        {\n\t          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n\t          //the 'ghost' join to a real join ready for later ...\n\t          var j = this.m_GhostJoins[i];\n\t\n\t\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n\t            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n\t        }\n\t      }\n\t      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n\t        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n\t        lb.PrevInAEL.OutIdx >= 0 &&\n\t        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n\t        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n\t      {\n\t        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n\t        this.AddJoin(Op1, Op2, lb.Top);\n\t      }\n\t      if (lb.NextInAEL != rb)\n\t      {\n\t        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n\t          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n\t          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n\t        {\n\t          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n\t          this.AddJoin(Op1, Op2, rb.Top);\n\t        }\n\t        var e = lb.NextInAEL;\n\t        if (e !== null)\n\t          while (e != rb)\n\t          {\n\t            //nb: For calculating winding counts etc, IntersectEdges() assumes\n\t            //that param1 will be to the right of param2 ABOVE the intersection ...\n\t            this.IntersectEdges(rb, e, lb.Curr, false);\n\t            //order important here\n\t            e = e.NextInAEL;\n\t          }\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n\t  {\n\t    if (this.m_ActiveEdges === null)\n\t    {\n\t      edge.PrevInAEL = null;\n\t      edge.NextInAEL = null;\n\t      this.m_ActiveEdges = edge;\n\t    }\n\t    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n\t    {\n\t      edge.PrevInAEL = null;\n\t      edge.NextInAEL = this.m_ActiveEdges;\n\t      this.m_ActiveEdges.PrevInAEL = edge;\n\t      this.m_ActiveEdges = edge;\n\t    }\n\t    else\n\t    {\n\t      if (startEdge === null)\n\t        startEdge = this.m_ActiveEdges;\n\t      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n\t        startEdge = startEdge.NextInAEL;\n\t      edge.NextInAEL = startEdge.NextInAEL;\n\t      if (startEdge.NextInAEL !== null)\n\t        startEdge.NextInAEL.PrevInAEL = edge;\n\t      edge.PrevInAEL = startEdge;\n\t      startEdge.NextInAEL = edge;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n\t  {\n\t    if (e2.Curr.X == e1.Curr.X)\n\t    {\n\t      if (e2.Top.Y > e1.Top.Y)\n\t        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n\t      else\n\t        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n\t    }\n\t    else\n\t      return e2.Curr.X < e1.Curr.X;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n\t  {\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t    else\n\t      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n\t  {\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t    else\n\t      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n\t  {\n\t    var pft, pft2;\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      pft = this.m_SubjFillType;\n\t      pft2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      pft = this.m_ClipFillType;\n\t      pft2 = this.m_SubjFillType;\n\t    }\n\t    switch (pft)\n\t    {\n\t    case ClipperLib.PolyFillType.pftEvenOdd:\n\t      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n\t        return false;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNonZero:\n\t      if (Math.abs(edge.WindCnt) != 1)\n\t        return false;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      if (edge.WindCnt != 1)\n\t        return false;\n\t      break;\n\t    default:\n\t      if (edge.WindCnt != -1)\n\t        return false;\n\t      break;\n\t    }\n\t    switch (this.m_ClipType)\n\t    {\n\t    case ClipperLib.ClipType.ctIntersection:\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 !== 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 > 0);\n\t      default:\n\t        return (edge.WindCnt2 < 0);\n\t      }\n\t    case ClipperLib.ClipType.ctUnion:\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 === 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 <= 0);\n\t      default:\n\t        return (edge.WindCnt2 >= 0);\n\t      }\n\t    case ClipperLib.ClipType.ctDifference:\n\t      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 === 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 <= 0);\n\t        default:\n\t          return (edge.WindCnt2 >= 0);\n\t        }\n\t      else\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 !== 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 > 0);\n\t        default:\n\t          return (edge.WindCnt2 < 0);\n\t        }\n\t    case ClipperLib.ClipType.ctXor:\n\t      if (edge.WindDelta === 0)\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 === 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 <= 0);\n\t        default:\n\t          return (edge.WindCnt2 >= 0);\n\t        }\n\t      else\n\t        return true;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n\t  {\n\t    var e = edge.PrevInAEL;\n\t    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n\t    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n\t      e = e.PrevInAEL;\n\t    if (e === null)\n\t    {\n\t      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t      edge.WindCnt2 = 0;\n\t      e = this.m_ActiveEdges;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n\t    {\n\t      edge.WindCnt = 1;\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else if (this.IsEvenOddFillType(edge))\n\t    {\n\t      //EvenOdd filling ...\n\t      if (edge.WindDelta === 0)\n\t      {\n\t        //are we inside a subj polygon ...\n\t        var Inside = true;\n\t        var e2 = e.PrevInAEL;\n\t        while (e2 !== null)\n\t        {\n\t          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n\t            Inside = !Inside;\n\t          e2 = e2.PrevInAEL;\n\t        }\n\t        edge.WindCnt = (Inside ? 0 : 1);\n\t      }\n\t      else\n\t      {\n\t        edge.WindCnt = edge.WindDelta;\n\t      }\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else\n\t    {\n\t      //nonZero, Positive or Negative filling ...\n\t      if (e.WindCnt * e.WindDelta < 0)\n\t      {\n\t        //prev edge is 'decreasing' WindCount (WC) toward zero\n\t        //so we're outside the previous polygon ...\n\t        if (Math.abs(e.WindCnt) > 1)\n\t        {\n\t          //outside prev poly but still inside another.\n\t          //when reversing direction of prev poly use the same WC\n\t          if (e.WindDelta * edge.WindDelta < 0)\n\t            edge.WindCnt = e.WindCnt;\n\t          else\n\t            edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t        }\n\t        else\n\t          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t      }\n\t      else\n\t      {\n\t        //prev edge is 'increasing' WindCount (WC) away from zero\n\t        //so we're inside the previous polygon ...\n\t        if (edge.WindDelta === 0)\n\t          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n\t        else if (e.WindDelta * edge.WindDelta < 0)\n\t          edge.WindCnt = e.WindCnt;\n\t        else\n\t          edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t      }\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    //update WindCnt2 ...\n\t    if (this.IsEvenOddAltFillType(edge))\n\t    {\n\t      //EvenOdd filling ...\n\t      while (e != edge)\n\t      {\n\t        if (e.WindDelta !== 0)\n\t          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      //nonZero, Positive or Negative filling ...\n\t      while (e != edge)\n\t      {\n\t        edge.WindCnt2 += e.WindDelta;\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n\t  {\n\t    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n\t    //However, we don't need to worry about order with horizontal edge processing.\n\t    if (this.m_SortedEdges === null)\n\t    {\n\t      this.m_SortedEdges = edge;\n\t      edge.PrevInSEL = null;\n\t      edge.NextInSEL = null;\n\t    }\n\t    else\n\t    {\n\t      edge.NextInSEL = this.m_SortedEdges;\n\t      edge.PrevInSEL = null;\n\t      this.m_SortedEdges.PrevInSEL = edge;\n\t      this.m_SortedEdges = edge;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n\t  {\n\t    var e = this.m_ActiveEdges;\n\t    this.m_SortedEdges = e;\n\t    while (e !== null)\n\t    {\n\t      e.PrevInSEL = e.PrevInAEL;\n\t      e.NextInSEL = e.NextInAEL;\n\t      e = e.NextInAEL;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n\t  {\n\t    //check that one or other edge hasn't already been removed from AEL ...\n\t    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n\t      return;\n\t    if (edge1.NextInAEL == edge2)\n\t    {\n\t      var next = edge2.NextInAEL;\n\t      if (next !== null)\n\t        next.PrevInAEL = edge1;\n\t      var prev = edge1.PrevInAEL;\n\t      if (prev !== null)\n\t        prev.NextInAEL = edge2;\n\t      edge2.PrevInAEL = prev;\n\t      edge2.NextInAEL = edge1;\n\t      edge1.PrevInAEL = edge2;\n\t      edge1.NextInAEL = next;\n\t    }\n\t    else if (edge2.NextInAEL == edge1)\n\t    {\n\t      var next = edge1.NextInAEL;\n\t      if (next !== null)\n\t        next.PrevInAEL = edge2;\n\t      var prev = edge2.PrevInAEL;\n\t      if (prev !== null)\n\t        prev.NextInAEL = edge1;\n\t      edge1.PrevInAEL = prev;\n\t      edge1.NextInAEL = edge2;\n\t      edge2.PrevInAEL = edge1;\n\t      edge2.NextInAEL = next;\n\t    }\n\t    else\n\t    {\n\t      var next = edge1.NextInAEL;\n\t      var prev = edge1.PrevInAEL;\n\t      edge1.NextInAEL = edge2.NextInAEL;\n\t      if (edge1.NextInAEL !== null)\n\t        edge1.NextInAEL.PrevInAEL = edge1;\n\t      edge1.PrevInAEL = edge2.PrevInAEL;\n\t      if (edge1.PrevInAEL !== null)\n\t        edge1.PrevInAEL.NextInAEL = edge1;\n\t      edge2.NextInAEL = next;\n\t      if (edge2.NextInAEL !== null)\n\t        edge2.NextInAEL.PrevInAEL = edge2;\n\t      edge2.PrevInAEL = prev;\n\t      if (edge2.PrevInAEL !== null)\n\t        edge2.PrevInAEL.NextInAEL = edge2;\n\t    }\n\t    if (edge1.PrevInAEL === null)\n\t      this.m_ActiveEdges = edge1;\n\t    else if (edge2.PrevInAEL === null)\n\t      this.m_ActiveEdges = edge2;\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n\t  {\n\t    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n\t      return;\n\t    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n\t      return;\n\t    if (edge1.NextInSEL == edge2)\n\t    {\n\t      var next = edge2.NextInSEL;\n\t      if (next !== null)\n\t        next.PrevInSEL = edge1;\n\t      var prev = edge1.PrevInSEL;\n\t      if (prev !== null)\n\t        prev.NextInSEL = edge2;\n\t      edge2.PrevInSEL = prev;\n\t      edge2.NextInSEL = edge1;\n\t      edge1.PrevInSEL = edge2;\n\t      edge1.NextInSEL = next;\n\t    }\n\t    else if (edge2.NextInSEL == edge1)\n\t    {\n\t      var next = edge1.NextInSEL;\n\t      if (next !== null)\n\t        next.PrevInSEL = edge2;\n\t      var prev = edge2.PrevInSEL;\n\t      if (prev !== null)\n\t        prev.NextInSEL = edge1;\n\t      edge1.PrevInSEL = prev;\n\t      edge1.NextInSEL = edge2;\n\t      edge2.PrevInSEL = edge1;\n\t      edge2.NextInSEL = next;\n\t    }\n\t    else\n\t    {\n\t      var next = edge1.NextInSEL;\n\t      var prev = edge1.PrevInSEL;\n\t      edge1.NextInSEL = edge2.NextInSEL;\n\t      if (edge1.NextInSEL !== null)\n\t        edge1.NextInSEL.PrevInSEL = edge1;\n\t      edge1.PrevInSEL = edge2.PrevInSEL;\n\t      if (edge1.PrevInSEL !== null)\n\t        edge1.PrevInSEL.NextInSEL = edge1;\n\t      edge2.NextInSEL = next;\n\t      if (edge2.NextInSEL !== null)\n\t        edge2.NextInSEL.PrevInSEL = edge2;\n\t      edge2.PrevInSEL = prev;\n\t      if (edge2.PrevInSEL !== null)\n\t        edge2.PrevInSEL.NextInSEL = edge2;\n\t    }\n\t    if (edge1.PrevInSEL === null)\n\t      this.m_SortedEdges = edge1;\n\t    else if (edge2.PrevInSEL === null)\n\t      this.m_SortedEdges = edge2;\n\t  };\n\t  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n\t  {\n\t    this.AddOutPt(e1, pt);\n\t    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n\t    if (e1.OutIdx == e2.OutIdx)\n\t    {\n\t      e1.OutIdx = -1;\n\t      e2.OutIdx = -1;\n\t    }\n\t    else if (e1.OutIdx < e2.OutIdx)\n\t      this.AppendPolygon(e1, e2);\n\t    else\n\t      this.AppendPolygon(e2, e1);\n\t  };\n\t  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n\t  {\n\t    var result;\n\t    var e, prevE;\n\t    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n\t    {\n\t      result = this.AddOutPt(e1, pt);\n\t      e2.OutIdx = e1.OutIdx;\n\t      e1.Side = ClipperLib.EdgeSide.esLeft;\n\t      e2.Side = ClipperLib.EdgeSide.esRight;\n\t      e = e1;\n\t      if (e.PrevInAEL == e2)\n\t        prevE = e2.PrevInAEL;\n\t      else\n\t        prevE = e.PrevInAEL;\n\t    }\n\t    else\n\t    {\n\t      result = this.AddOutPt(e2, pt);\n\t      e1.OutIdx = e2.OutIdx;\n\t      e1.Side = ClipperLib.EdgeSide.esRight;\n\t      e2.Side = ClipperLib.EdgeSide.esLeft;\n\t      e = e2;\n\t      if (e.PrevInAEL == e1)\n\t        prevE = e1.PrevInAEL;\n\t      else\n\t        prevE = e.PrevInAEL;\n\t    }\n\t    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n\t    {\n\t      var outPt = this.AddOutPt(prevE, pt);\n\t      this.AddJoin(result, outPt, e.Top);\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n\t  {\n\t    var result = new ClipperLib.OutRec();\n\t    result.Idx = -1;\n\t    result.IsHole = false;\n\t    result.IsOpen = false;\n\t    result.FirstLeft = null;\n\t    result.Pts = null;\n\t    result.BottomPt = null;\n\t    result.PolyNode = null;\n\t    this.m_PolyOuts.push(result);\n\t    result.Idx = this.m_PolyOuts.length - 1;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n\t  {\n\t    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n\t    if (e.OutIdx < 0)\n\t    {\n\t      var outRec = this.CreateOutRec();\n\t      outRec.IsOpen = (e.WindDelta === 0);\n\t      var newOp = new ClipperLib.OutPt();\n\t      outRec.Pts = newOp;\n\t      newOp.Idx = outRec.Idx;\n\t      //newOp.Pt = pt;\n\t      newOp.Pt.X = pt.X;\n\t      newOp.Pt.Y = pt.Y;\n\t      newOp.Next = newOp;\n\t      newOp.Prev = newOp;\n\t      if (!outRec.IsOpen)\n\t        this.SetHoleState(e, outRec);\n\t      e.OutIdx = outRec.Idx;\n\t      //nb: do this after SetZ !\n\t      return newOp;\n\t    }\n\t    else\n\t    {\n\t      var outRec = this.m_PolyOuts[e.OutIdx];\n\t      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n\t      var op = outRec.Pts;\n\t      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n\t        return op;\n\t      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n\t        return op.Prev;\n\t      var newOp = new ClipperLib.OutPt();\n\t      newOp.Idx = outRec.Idx;\n\t      //newOp.Pt = pt;\n\t      newOp.Pt.X = pt.X;\n\t      newOp.Pt.Y = pt.Y;\n\t      newOp.Next = op;\n\t      newOp.Prev = op.Prev;\n\t      newOp.Prev.Next = newOp;\n\t      op.Prev = newOp;\n\t      if (ToFront)\n\t        outRec.Pts = newOp;\n\t      return newOp;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n\t  {\n\t    var tmp = new ClipperLib.IntPoint(pt1.Value);\n\t    //pt1.Value = pt2.Value;\n\t    pt1.Value.X = pt2.Value.X;\n\t    pt1.Value.Y = pt2.Value.Y;\n\t    //pt2.Value = tmp;\n\t    pt2.Value.X = tmp.X;\n\t    pt2.Value.Y = tmp.Y;\n\t  };\n\t  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t\t{\n\t\t\tvar tmp;\n\t\t\tif (seg1a > seg1b)\n\t\t\t{\n\t\t\t\ttmp = seg1a;\n\t\t\t\tseg1a = seg1b;\n\t\t\t\tseg1b = tmp;\n\t\t\t}\n\t\t\tif (seg2a > seg2b)\n\t\t\t{\n\t\t\t\ttmp = seg2a;\n\t\t\t\tseg2a = seg2b;\n\t\t\t\tseg2b = tmp;\n\t\t\t}\n\t\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t\t}\n\t\n\t  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n\t  {\n\t    var isHole = false;\n\t    var e2 = e.PrevInAEL;\n\t    while (e2 !== null)\n\t    {\n\t      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n\t      {\n\t        isHole = !isHole;\n\t        if (outRec.FirstLeft === null)\n\t          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n\t      }\n\t      e2 = e2.PrevInAEL;\n\t    }\n\t    if (isHole)\n\t      outRec.IsHole = true;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n\t  {\n\t    if (pt1.Y == pt2.Y)\n\t      return ClipperLib.ClipperBase.horizontal;\n\t    else\n\t      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n\t  };\n\t  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n\t  {\n\t    var p = btmPt1.Prev;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t      p = p.Prev;\n\t    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t    p = btmPt1.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t      p = p.Next;\n\t    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t    p = btmPt2.Prev;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t      p = p.Prev;\n\t    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t    p = btmPt2.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t      p = p.Next;\n\t    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n\t  };\n\t  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n\t  {\n\t    var dups = null;\n\t    var p = pp.Next;\n\t    while (p != pp)\n\t    {\n\t      if (p.Pt.Y > pp.Pt.Y)\n\t      {\n\t        pp = p;\n\t        dups = null;\n\t      }\n\t      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n\t      {\n\t        if (p.Pt.X < pp.Pt.X)\n\t        {\n\t          dups = null;\n\t          pp = p;\n\t        }\n\t        else\n\t        {\n\t          if (p.Next != pp && p.Prev != pp)\n\t            dups = p;\n\t        }\n\t      }\n\t      p = p.Next;\n\t    }\n\t    if (dups !== null)\n\t    {\n\t      //there appears to be at least 2 vertices at bottomPt so ...\n\t      while (dups != p)\n\t      {\n\t        if (!this.FirstIsBottomPt(p, dups))\n\t          pp = dups;\n\t        dups = dups.Next;\n\t        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n\t          dups = dups.Next;\n\t      }\n\t    }\n\t    return pp;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n\t  {\n\t    //work out which polygon fragment has the correct hole state ...\n\t    if (outRec1.BottomPt === null)\n\t      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n\t    if (outRec2.BottomPt === null)\n\t      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n\t    var bPt1 = outRec1.BottomPt;\n\t    var bPt2 = outRec2.BottomPt;\n\t    if (bPt1.Pt.Y > bPt2.Pt.Y)\n\t      return outRec1;\n\t    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n\t      return outRec2;\n\t    else if (bPt1.Pt.X < bPt2.Pt.X)\n\t      return outRec1;\n\t    else if (bPt1.Pt.X > bPt2.Pt.X)\n\t      return outRec2;\n\t    else if (bPt1.Next == bPt1)\n\t      return outRec2;\n\t    else if (bPt2.Next == bPt2)\n\t      return outRec1;\n\t    else if (this.FirstIsBottomPt(bPt1, bPt2))\n\t      return outRec1;\n\t    else\n\t      return outRec2;\n\t  };\n\t  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n\t  {\n\t    do {\n\t      outRec1 = outRec1.FirstLeft;\n\t      if (outRec1 == outRec2)\n\t        return true;\n\t    }\n\t    while (outRec1 !== null)\n\t    return false;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n\t  {\n\t    var outrec = this.m_PolyOuts[idx];\n\t    while (outrec != this.m_PolyOuts[outrec.Idx])\n\t      outrec = this.m_PolyOuts[outrec.Idx];\n\t    return outrec;\n\t  };\n\t  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n\t  {\n\t    //get the start and ends of both output polygons ...\n\t    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n\t    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n\t    var holeStateRec;\n\t    if (this.Param1RightOfParam2(outRec1, outRec2))\n\t      holeStateRec = outRec2;\n\t    else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t      holeStateRec = outRec1;\n\t    else\n\t      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t    var p1_lft = outRec1.Pts;\n\t    var p1_rt = p1_lft.Prev;\n\t    var p2_lft = outRec2.Pts;\n\t    var p2_rt = p2_lft.Prev;\n\t    var side;\n\t    //join e2 poly onto e1 poly and delete pointers to e2 ...\n\t    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n\t    {\n\t      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n\t      {\n\t        //z y x a b c\n\t        this.ReversePolyPtLinks(p2_lft);\n\t        p2_lft.Next = p1_lft;\n\t        p1_lft.Prev = p2_lft;\n\t        p1_rt.Next = p2_rt;\n\t        p2_rt.Prev = p1_rt;\n\t        outRec1.Pts = p2_rt;\n\t      }\n\t      else\n\t      {\n\t        //x y z a b c\n\t        p2_rt.Next = p1_lft;\n\t        p1_lft.Prev = p2_rt;\n\t        p2_lft.Prev = p1_rt;\n\t        p1_rt.Next = p2_lft;\n\t        outRec1.Pts = p2_lft;\n\t      }\n\t      side = ClipperLib.EdgeSide.esLeft;\n\t    }\n\t    else\n\t    {\n\t      if (e2.Side == ClipperLib.EdgeSide.esRight)\n\t      {\n\t        //a b c z y x\n\t        this.ReversePolyPtLinks(p2_lft);\n\t        p1_rt.Next = p2_rt;\n\t        p2_rt.Prev = p1_rt;\n\t        p2_lft.Next = p1_lft;\n\t        p1_lft.Prev = p2_lft;\n\t      }\n\t      else\n\t      {\n\t        //a b c x y z\n\t        p1_rt.Next = p2_lft;\n\t        p2_lft.Prev = p1_rt;\n\t        p1_lft.Prev = p2_rt;\n\t        p2_rt.Next = p1_lft;\n\t      }\n\t      side = ClipperLib.EdgeSide.esRight;\n\t    }\n\t    outRec1.BottomPt = null;\n\t    if (holeStateRec == outRec2)\n\t    {\n\t      if (outRec2.FirstLeft != outRec1)\n\t        outRec1.FirstLeft = outRec2.FirstLeft;\n\t      outRec1.IsHole = outRec2.IsHole;\n\t    }\n\t    outRec2.Pts = null;\n\t    outRec2.BottomPt = null;\n\t    outRec2.FirstLeft = outRec1;\n\t    var OKIdx = e1.OutIdx;\n\t    var ObsoleteIdx = e2.OutIdx;\n\t    e1.OutIdx = -1;\n\t    //nb: safe because we only get here via AddLocalMaxPoly\n\t    e2.OutIdx = -1;\n\t    var e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      if (e.OutIdx == ObsoleteIdx)\n\t      {\n\t        e.OutIdx = OKIdx;\n\t        e.Side = side;\n\t        break;\n\t      }\n\t      e = e.NextInAEL;\n\t    }\n\t    outRec2.Idx = outRec1.Idx;\n\t  };\n\t  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n\t  {\n\t    if (pp === null)\n\t      return;\n\t    var pp1;\n\t    var pp2;\n\t    pp1 = pp;\n\t    do {\n\t      pp2 = pp1.Next;\n\t      pp1.Next = pp1.Prev;\n\t      pp1.Prev = pp2;\n\t      pp1 = pp2;\n\t    }\n\t    while (pp1 != pp)\n\t  };\n\t  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n\t  {\n\t    var side = edge1.Side;\n\t    edge1.Side = edge2.Side;\n\t    edge2.Side = side;\n\t  };\n\t  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n\t  {\n\t    var outIdx = edge1.OutIdx;\n\t    edge1.OutIdx = edge2.OutIdx;\n\t    edge2.OutIdx = outIdx;\n\t  };\n\t  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n\t  {\n\t    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n\t    //e2 in AEL except when e1 is being inserted at the intersection point ...\n\t    var e1Contributing = (e1.OutIdx >= 0);\n\t    var e2Contributing = (e2.OutIdx >= 0);\n\t\n\t    if (use_xyz)\n\t    \tthis.SetZ(pt, e1, e2);\n\t\n\t    if (use_lines)\n\t    {\n\t      //if either edge is on an OPEN path ...\n\t      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n\t      {\n\t        //ignore subject-subject open path intersections UNLESS they\n\t        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n\t        //if intersecting a subj line with a subj poly ...\n\t        else if (e1.PolyTyp == e2.PolyTyp &&\n\t          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n\t        {\n\t          if (e1.WindDelta === 0)\n\t          {\n\t            if (e2Contributing)\n\t            {\n\t              this.AddOutPt(e1, pt);\n\t              if (e1Contributing)\n\t                e1.OutIdx = -1;\n\t            }\n\t          }\n\t          else\n\t          {\n\t            if (e1Contributing)\n\t            {\n\t              this.AddOutPt(e2, pt);\n\t              if (e2Contributing)\n\t                e2.OutIdx = -1;\n\t            }\n\t          }\n\t        }\n\t        else if (e1.PolyTyp != e2.PolyTyp)\n\t        {\n\t          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n\t            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n\t          {\n\t            this.AddOutPt(e1, pt);\n\t            if (e1Contributing)\n\t              e1.OutIdx = -1;\n\t          }\n\t          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n\t            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n\t          {\n\t            this.AddOutPt(e2, pt);\n\t            if (e2Contributing)\n\t              e2.OutIdx = -1;\n\t          }\n\t        }\n\t        return;\n\t      }\n\t    }\n\t    //update winding counts...\n\t    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n\t    if (e1.PolyTyp == e2.PolyTyp)\n\t    {\n\t      if (this.IsEvenOddFillType(e1))\n\t      {\n\t        var oldE1WindCnt = e1.WindCnt;\n\t        e1.WindCnt = e2.WindCnt;\n\t        e2.WindCnt = oldE1WindCnt;\n\t      }\n\t      else\n\t      {\n\t        if (e1.WindCnt + e2.WindDelta === 0)\n\t          e1.WindCnt = -e1.WindCnt;\n\t        else\n\t          e1.WindCnt += e2.WindDelta;\n\t        if (e2.WindCnt - e1.WindDelta === 0)\n\t          e2.WindCnt = -e2.WindCnt;\n\t        else\n\t          e2.WindCnt -= e1.WindDelta;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (!this.IsEvenOddFillType(e2))\n\t        e1.WindCnt2 += e2.WindDelta;\n\t      else\n\t        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n\t      if (!this.IsEvenOddFillType(e1))\n\t        e2.WindCnt2 -= e1.WindDelta;\n\t      else\n\t        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n\t    }\n\t    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n\t    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      e1FillType = this.m_SubjFillType;\n\t      e1FillType2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      e1FillType = this.m_ClipFillType;\n\t      e1FillType2 = this.m_SubjFillType;\n\t    }\n\t    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      e2FillType = this.m_SubjFillType;\n\t      e2FillType2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      e2FillType = this.m_ClipFillType;\n\t      e2FillType2 = this.m_SubjFillType;\n\t    }\n\t    var e1Wc, e2Wc;\n\t    switch (e1FillType)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e1Wc = e1.WindCnt;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e1Wc = -e1.WindCnt;\n\t      break;\n\t    default:\n\t      e1Wc = Math.abs(e1.WindCnt);\n\t      break;\n\t    }\n\t    switch (e2FillType)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e2Wc = e2.WindCnt;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e2Wc = -e2.WindCnt;\n\t      break;\n\t    default:\n\t      e2Wc = Math.abs(e2.WindCnt);\n\t      break;\n\t    }\n\t    if (e1Contributing && e2Contributing)\n\t    {\n\t\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t\t{\n\t\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t\t}\n\t      else\n\t      {\n\t        this.AddOutPt(e1, pt);\n\t        this.AddOutPt(e2, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t    else if (e1Contributing)\n\t    {\n\t      if (e2Wc === 0 || e2Wc == 1)\n\t      {\n\t        this.AddOutPt(e1, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t    else if (e2Contributing)\n\t    {\n\t      if (e1Wc === 0 || e1Wc == 1)\n\t      {\n\t        this.AddOutPt(e2, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n\t    {\n\t      //neither edge is currently contributing ...\n\t      var e1Wc2, e2Wc2;\n\t      switch (e1FillType2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        e1Wc2 = e1.WindCnt2;\n\t        break;\n\t      case ClipperLib.PolyFillType.pftNegative:\n\t        e1Wc2 = -e1.WindCnt2;\n\t        break;\n\t      default:\n\t        e1Wc2 = Math.abs(e1.WindCnt2);\n\t        break;\n\t      }\n\t      switch (e2FillType2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        e2Wc2 = e2.WindCnt2;\n\t        break;\n\t      case ClipperLib.PolyFillType.pftNegative:\n\t        e2Wc2 = -e2.WindCnt2;\n\t        break;\n\t      default:\n\t        e2Wc2 = Math.abs(e2.WindCnt2);\n\t        break;\n\t      }\n\t      if (e1.PolyTyp != e2.PolyTyp)\n\t      {\n\t        this.AddLocalMinPoly(e1, e2, pt);\n\t      }\n\t      else if (e1Wc == 1 && e2Wc == 1)\n\t        switch (this.m_ClipType)\n\t        {\n\t        case ClipperLib.ClipType.ctIntersection:\n\t          if (e1Wc2 > 0 && e2Wc2 > 0)\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctUnion:\n\t          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctDifference:\n\t          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n\t            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctXor:\n\t          this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        }\n\t      else\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n\t  {\n\t    var AelPrev = e.PrevInAEL;\n\t    var AelNext = e.NextInAEL;\n\t    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n\t      return;\n\t    //already deleted\n\t    if (AelPrev !== null)\n\t      AelPrev.NextInAEL = AelNext;\n\t    else\n\t      this.m_ActiveEdges = AelNext;\n\t    if (AelNext !== null)\n\t      AelNext.PrevInAEL = AelPrev;\n\t    e.NextInAEL = null;\n\t    e.PrevInAEL = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n\t  {\n\t    var SelPrev = e.PrevInSEL;\n\t    var SelNext = e.NextInSEL;\n\t    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n\t      return;\n\t    //already deleted\n\t    if (SelPrev !== null)\n\t      SelPrev.NextInSEL = SelNext;\n\t    else\n\t      this.m_SortedEdges = SelNext;\n\t    if (SelNext !== null)\n\t      SelNext.PrevInSEL = SelPrev;\n\t    e.NextInSEL = null;\n\t    e.PrevInSEL = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n\t  {\n\t    if (e.NextInLML === null)\n\t      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n\t    var AelPrev = e.PrevInAEL;\n\t    var AelNext = e.NextInAEL;\n\t    e.NextInLML.OutIdx = e.OutIdx;\n\t    if (AelPrev !== null)\n\t      AelPrev.NextInAEL = e.NextInLML;\n\t    else\n\t      this.m_ActiveEdges = e.NextInLML;\n\t    if (AelNext !== null)\n\t      AelNext.PrevInAEL = e.NextInLML;\n\t    e.NextInLML.Side = e.Side;\n\t    e.NextInLML.WindDelta = e.WindDelta;\n\t    e.NextInLML.WindCnt = e.WindCnt;\n\t    e.NextInLML.WindCnt2 = e.WindCnt2;\n\t    e = e.NextInLML;\n\t    //    e.Curr = e.Bot;\n\t    e.Curr.X = e.Bot.X;\n\t    e.Curr.Y = e.Bot.Y;\n\t    e.PrevInAEL = AelPrev;\n\t    e.NextInAEL = AelNext;\n\t    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n\t      this.InsertScanbeam(e.Top.Y);\n\t    return e;\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n\t  {\n\t    var horzEdge = this.m_SortedEdges;\n\t    while (horzEdge !== null)\n\t    {\n\t      this.DeleteFromSEL(horzEdge);\n\t      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n\t      horzEdge = this.m_SortedEdges;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n\t  {\n\t    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n\t    {\n\t        $var.Left = HorzEdge.Bot.X;\n\t        $var.Right = HorzEdge.Top.X;\n\t        $var.Dir = ClipperLib.Direction.dLeftToRight;\n\t    }\n\t    else\n\t    {\n\t        $var.Left = HorzEdge.Top.X;\n\t        $var.Right = HorzEdge.Bot.X;\n\t        $var.Dir = ClipperLib.Direction.dRightToLeft;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n\t  {\n\t    var $var = {Dir: null, Left: null, Right: null};\n\t    this.GetHorzDirection(horzEdge, $var);\n\t    var dir = $var.Dir;\n\t    var horzLeft = $var.Left;\n\t    var horzRight = $var.Right;\n\t\n\t    var eLastHorz = horzEdge,\n\t      eMaxPair = null;\n\t    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n\t      eLastHorz = eLastHorz.NextInLML;\n\t    if (eLastHorz.NextInLML === null)\n\t      eMaxPair = this.GetMaximaPair(eLastHorz);\n\t    for (;;)\n\t    {\n\t      var IsLastHorz = (horzEdge == eLastHorz);\n\t      var e = this.GetNextInAEL(horzEdge, dir);\n\t      while (e !== null)\n\t      {\n\t        //Break if we've got to the end of an intermediate horizontal edge ...\n\t        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n\t        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n\t          break;\n\t        var eNext = this.GetNextInAEL(e, dir);\n\t        //saves eNext for later\n\t        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n\t        {\n\t          //so far we're still in range of the horizontal Edge  but make sure\n\t          //we're at the last of consec. horizontals when matching with eMaxPair\n\t          if (e == eMaxPair && IsLastHorz)\n\t          {\n\t\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t            return;\n\t          }\n\t          else if (dir == ClipperLib.Direction.dLeftToRight)\n\t          {\n\t            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t            this.IntersectEdges(horzEdge, e, Pt);\n\t          }\n\t          else\n\t          {\n\t            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t            this.IntersectEdges(e, horzEdge, Pt);\n\t          }\n\t          this.SwapPositionsInAEL(horzEdge, e);\n\t        }\n\t        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n\t          break;\n\t        e = eNext;\n\t      }\n\t      //end while\n\t      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n\t      {\n\t        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t        if (horzEdge.OutIdx >= 0)\n\t          this.AddOutPt(horzEdge, horzEdge.Bot);\n\t\n\t          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n\t          this.GetHorzDirection(horzEdge, $var);\n\t          dir = $var.Dir;\n\t          horzLeft = $var.Left;\n\t          horzRight = $var.Right;\n\t      }\n\t      else\n\t        break;\n\t    }\n\t    //end for (;;)\n\t    if (horzEdge.NextInLML !== null)\n\t    {\n\t      if (horzEdge.OutIdx >= 0)\n\t      {\n\t        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n\t        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t        if (horzEdge.WindDelta === 0)\n\t          return;\n\t        //nb: HorzEdge is no longer horizontal here\n\t        var ePrev = horzEdge.PrevInAEL;\n\t        var eNext = horzEdge.NextInAEL;\n\t        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n\t          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n\t          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n\t        {\n\t          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n\t          this.AddJoin(op1, op2, horzEdge.Top);\n\t        }\n\t        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n\t          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n\t          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n\t        {\n\t          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n\t          this.AddJoin(op1, op2, horzEdge.Top);\n\t        }\n\t      }\n\t      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t    }\n\t  \telse\n\t    {\n\t      if (horzEdge.OutIdx >= 0)\n\t        this.AddOutPt(horzEdge, horzEdge.Top);\n\t      this.DeleteFromAEL(horzEdge);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n\t  {\n\t    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsMinima = function (e)\n\t  {\n\t    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n\t  };\n\t  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n\t  {\n\t    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n\t  };\n\t  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n\t  {\n\t    return (e.Top.Y == Y && e.NextInLML !== null);\n\t  };\n\t  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n\t  {\n\t    var result = null;\n\t    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n\t      result = e.Next;\n\t    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n\t      result = e.Prev;\n\t    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n\t      return null;\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n\t  {\n\t    if (this.m_ActiveEdges == null)\n\t      return true;\n\t    try\n\t    {\n\t      this.BuildIntersectList(topY);\n\t      if (this.m_IntersectList.length == 0)\n\t        return true;\n\t      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n\t        this.ProcessIntersectList();\n\t      else\n\t        return false;\n\t    }\n\t    catch ($$e2)\n\t    {\n\t      this.m_SortedEdges = null;\n\t      this.m_IntersectList.length = 0;\n\t      ClipperLib.Error(\"ProcessIntersections error\");\n\t    }\n\t    this.m_SortedEdges = null;\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n\t  {\n\t    if (this.m_ActiveEdges === null)\n\t      return;\n\t    //prepare for sorting ...\n\t    var e = this.m_ActiveEdges;\n\t    //console.log(JSON.stringify(JSON.decycle( e )));\n\t    this.m_SortedEdges = e;\n\t    while (e !== null)\n\t    {\n\t      e.PrevInSEL = e.PrevInAEL;\n\t      e.NextInSEL = e.NextInAEL;\n\t      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t      e = e.NextInAEL;\n\t    }\n\t    //bubblesort ...\n\t    var isModified = true;\n\t    while (isModified && this.m_SortedEdges !== null)\n\t    {\n\t      isModified = false;\n\t      e = this.m_SortedEdges;\n\t      while (e.NextInSEL !== null)\n\t      {\n\t        var eNext = e.NextInSEL;\n\t        var pt = new ClipperLib.IntPoint();\n\t        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n\t        if (e.Curr.X > eNext.Curr.X)\n\t        {\n\t\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n\t          var newNode = new ClipperLib.IntersectNode();\n\t          newNode.Edge1 = e;\n\t          newNode.Edge2 = eNext;\n\t          //newNode.Pt = pt;\n\t          newNode.Pt.X = pt.X;\n\t          newNode.Pt.Y = pt.Y;\n\t          this.m_IntersectList.push(newNode);\n\t          this.SwapPositionsInSEL(e, eNext);\n\t          isModified = true;\n\t        }\n\t        else\n\t          e = eNext;\n\t      }\n\t      if (e.PrevInSEL !== null)\n\t        e.PrevInSEL.NextInSEL = null;\n\t      else\n\t        break;\n\t    }\n\t    this.m_SortedEdges = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n\t  {\n\t    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n\t  };\n\t  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n\t  {\n\t    //the following typecast is safe because the differences in Pt.Y will\n\t    //be limited to the height of the scanbeam.\n\t    return (node2.Pt.Y - node1.Pt.Y);\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n\t  {\n\t    //pre-condition: intersections are sorted bottom-most first.\n\t    //Now it's crucial that intersections are made only between adjacent edges,\n\t    //so to ensure this the order of intersections may need adjusting ...\n\t    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n\t    this.CopyAELToSEL();\n\t    var cnt = this.m_IntersectList.length;\n\t    for (var i = 0; i < cnt; i++)\n\t    {\n\t      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n\t      {\n\t        var j = i + 1;\n\t        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n\t          j++;\n\t        if (j == cnt)\n\t          return false;\n\t        var tmp = this.m_IntersectList[i];\n\t        this.m_IntersectList[i] = this.m_IntersectList[j];\n\t        this.m_IntersectList[j] = tmp;\n\t      }\n\t      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n\t    {\n\t      var iNode = this.m_IntersectList[i];\n\t      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n\t      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n\t    }\n\t    this.m_IntersectList.length = 0;\n\t  };\n\t  /*\n\t  --------------------------------\n\t  Round speedtest: http://jsperf.com/fastest-round\n\t  --------------------------------\n\t  */\n\t  var R1 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n\t  };\n\t  var R2 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n\t  };\n\t  var R3 = function (a)\n\t  {\n\t    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n\t  };\n\t  var R4 = function (a)\n\t  {\n\t    if (a < 0)\n\t    {\n\t      a -= 0.5;\n\t      return a < -2147483648 ? Math.ceil(a) : a | 0;\n\t    }\n\t    else\n\t    {\n\t      a += 0.5;\n\t      return a > 2147483647 ? Math.floor(a) : a | 0;\n\t    }\n\t  };\n\t  if (browser.msie) ClipperLib.Clipper.Round = R1;\n\t  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n\t  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n\t  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n\t  ClipperLib.Clipper.TopX = function (edge, currentY)\n\t  {\n\t    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n\t    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n\t    if (currentY == edge.Top.Y)\n\t      return edge.Top.X;\n\t    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n\t  };\n\t  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n\t  {\n\t    ip.X = 0;\n\t    ip.Y = 0;\n\t    var b1, b2;\n\t    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n\t    //return false but for the edge.Dx value be equal due to double precision rounding.\n\t    if (edge1.Dx == edge2.Dx)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\t\treturn;\n\t    }\n\t    if (edge1.Delta.X === 0)\n\t    {\n\t      ip.X = edge1.Bot.X;\n\t      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n\t      {\n\t        ip.Y = edge2.Bot.Y;\n\t      }\n\t      else\n\t      {\n\t        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n\t        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n\t      }\n\t    }\n\t    else if (edge2.Delta.X === 0)\n\t    {\n\t      ip.X = edge2.Bot.X;\n\t      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n\t      {\n\t        ip.Y = edge1.Bot.Y;\n\t      }\n\t      else\n\t      {\n\t        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n\t        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n\t      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n\t      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n\t      ip.Y = ClipperLib.Clipper.Round(q);\n\t      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n\t      else\n\t        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n\t    }\n\t    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n\t    {\n\t      if (edge1.Top.Y > edge2.Top.Y)\n\t      {\n\t        ip.Y = edge1.Top.Y;\n\t        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n\t        return ip.X < edge1.Top.X;\n\t      }\n\t      else\n\t        ip.Y = edge2.Top.Y;\n\t      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t      else\n\t        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t    }\n\t\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\t\tif (ip.Y > edge1.Curr.Y)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\t\telse\n\t\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\t}\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n\t  {\n\t    var e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n\t      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n\t      var IsMaximaEdge = this.IsMaxima(e, topY);\n\t      if (IsMaximaEdge)\n\t      {\n\t        var eMaxPair = this.GetMaximaPair(e);\n\t        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n\t      }\n\t      if (IsMaximaEdge)\n\t      {\n\t        var ePrev = e.PrevInAEL;\n\t        this.DoMaxima(e);\n\t        if (ePrev === null)\n\t          e = this.m_ActiveEdges;\n\t        else\n\t          e = ePrev.NextInAEL;\n\t      }\n\t      else\n\t      {\n\t        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n\t        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n\t        {\n\t          e = this.UpdateEdgeIntoAEL(e);\n\t          if (e.OutIdx >= 0)\n\t            this.AddOutPt(e, e.Bot);\n\t          this.AddEdgeToSEL(e);\n\t        }\n\t        else\n\t        {\n\t          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t          e.Curr.Y = topY;\n\t        }\n\t        if (this.StrictlySimple)\n\t        {\n\t          var ePrev = e.PrevInAEL;\n\t          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n\t            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n\t            (ePrev.WindDelta !== 0))\n\t          {\n\t           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\t\n\t\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t\t}\n\t\n\t            var op = this.AddOutPt(ePrev, ip);\n\t            var op2 = this.AddOutPt(e, ip);\n\t            this.AddJoin(op, op2, ip);\n\t            //StrictlySimple (type-3) join\n\t          }\n\t        }\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t    //3. Process horizontals at the Top of the scanbeam ...\n\t    this.ProcessHorizontals(true);\n\t    //4. Promote intermediate vertices ...\n\t    e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      if (this.IsIntermediate(e, topY))\n\t      {\n\t        var op = null;\n\t        if (e.OutIdx >= 0)\n\t          op = this.AddOutPt(e, e.Top);\n\t        e = this.UpdateEdgeIntoAEL(e);\n\t        //if output polygons share an edge, they'll need joining later ...\n\t        var ePrev = e.PrevInAEL;\n\t        var eNext = e.NextInAEL;\n\t        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n\t          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n\t          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n\t          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n\t        {\n\t          var op2 = this.AddOutPt(ePrev, e.Bot);\n\t          this.AddJoin(op, op2, e.Top);\n\t        }\n\t        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n\t          eNext.Curr.Y == e.Bot.Y && op !== null &&\n\t          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n\t          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n\t        {\n\t          var op2 = this.AddOutPt(eNext, e.Bot);\n\t          this.AddJoin(op, op2, e.Top);\n\t        }\n\t      }\n\t      e = e.NextInAEL;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n\t  {\n\t    var eMaxPair = this.GetMaximaPair(e);\n\t    if (eMaxPair === null)\n\t    {\n\t      if (e.OutIdx >= 0)\n\t        this.AddOutPt(e, e.Top);\n\t      this.DeleteFromAEL(e);\n\t      return;\n\t    }\n\t    var eNext = e.NextInAEL;\n\t    var use_lines = true;\n\t    while (eNext !== null && eNext != eMaxPair)\n\t    {\n\t      this.IntersectEdges(e, eNext, e.Top);\n\t      this.SwapPositionsInAEL(e, eNext);\n\t      eNext = e.NextInAEL;\n\t    }\n\t    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n\t    {\n\t      this.DeleteFromAEL(e);\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n\t    {\n\t    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n\t      this.DeleteFromAEL(e);\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else if (use_lines && e.WindDelta === 0)\n\t    {\n\t      if (e.OutIdx >= 0)\n\t      {\n\t        this.AddOutPt(e, e.Top);\n\t        e.OutIdx = -1;\n\t      }\n\t      this.DeleteFromAEL(e);\n\t      if (eMaxPair.OutIdx >= 0)\n\t      {\n\t        this.AddOutPt(eMaxPair, e.Top);\n\t        eMaxPair.OutIdx = -1;\n\t      }\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else\n\t      ClipperLib.Error(\"DoMaxima error\");\n\t  };\n\t  ClipperLib.Clipper.ReversePaths = function (polys)\n\t  {\n\t    for (var i = 0, len = polys.length; i < len; i++)\n\t      polys[i].reverse();\n\t  };\n\t  ClipperLib.Clipper.Orientation = function (poly)\n\t  {\n\t    return ClipperLib.Clipper.Area(poly) >= 0;\n\t  };\n\t  ClipperLib.Clipper.prototype.PointCount = function (pts)\n\t  {\n\t    if (pts === null)\n\t      return 0;\n\t    var result = 0;\n\t    var p = pts;\n\t    do {\n\t      result++;\n\t      p = p.Next;\n\t    }\n\t    while (p != pts)\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n\t  {\n\t    ClipperLib.Clear(polyg);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.Pts === null)\n\t        continue;\n\t      var p = outRec.Pts.Prev;\n\t      var cnt = this.PointCount(p);\n\t      if (cnt < 2)\n\t        continue;\n\t      var pg = new Array(cnt);\n\t      for (var j = 0; j < cnt; j++)\n\t      {\n\t        pg[j] = p.Pt;\n\t        p = p.Prev;\n\t      }\n\t      polyg.push(pg);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n\t  {\n\t    polytree.Clear();\n\t    //add each output polygon/contour to polytree ...\n\t    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      var cnt = this.PointCount(outRec.Pts);\n\t      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n\t        continue;\n\t      this.FixHoleLinkage(outRec);\n\t      var pn = new ClipperLib.PolyNode();\n\t      polytree.m_AllPolys.push(pn);\n\t      outRec.PolyNode = pn;\n\t      pn.m_polygon.length = cnt;\n\t      var op = outRec.Pts.Prev;\n\t      for (var j = 0; j < cnt; j++)\n\t      {\n\t        pn.m_polygon[j] = op.Pt;\n\t        op = op.Prev;\n\t      }\n\t    }\n\t    //fixup PolyNode links etc ...\n\t    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.PolyNode === null)\n\t        continue;\n\t      else if (outRec.IsOpen)\n\t      {\n\t        outRec.PolyNode.IsOpen = true;\n\t        polytree.AddChild(outRec.PolyNode);\n\t      }\n\t      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n\t        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n\t      else\n\t        polytree.AddChild(outRec.PolyNode);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n\t  {\n\t    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n\t    //parallel edges by removing the middle vertex.\n\t    var lastOK = null;\n\t    outRec.BottomPt = null;\n\t    var pp = outRec.Pts;\n\t    for (;;)\n\t    {\n\t      if (pp.Prev == pp || pp.Prev == pp.Next)\n\t      {\n\t        outRec.Pts = null;\n\t        return;\n\t      }\n\t      //test for duplicate points and collinear edges ...\n\t      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n\t        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n\t          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n\t      {\n\t        lastOK = null;\n\t        pp.Prev.Next = pp.Next;\n\t        pp.Next.Prev = pp.Prev;\n\t        pp = pp.Prev;\n\t      }\n\t      else if (pp == lastOK)\n\t        break;\n\t      else\n\t      {\n\t        if (lastOK === null)\n\t          lastOK = pp;\n\t        pp = pp.Next;\n\t      }\n\t    }\n\t    outRec.Pts = pp;\n\t  };\n\t  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n\t  {\n\t    var result = new ClipperLib.OutPt();\n\t    //result.Pt = outPt.Pt;\n\t    result.Pt.X = outPt.Pt.X;\n\t    result.Pt.Y = outPt.Pt.Y;\n\t    result.Idx = outPt.Idx;\n\t    if (InsertAfter)\n\t    {\n\t      result.Next = outPt.Next;\n\t      result.Prev = outPt;\n\t      outPt.Next.Prev = result;\n\t      outPt.Next = result;\n\t    }\n\t    else\n\t    {\n\t      result.Prev = outPt.Prev;\n\t      result.Next = outPt;\n\t      outPt.Prev.Next = result;\n\t      outPt.Prev = result;\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n\t  {\n\t    if (a1 < a2)\n\t    {\n\t      if (b1 < b2)\n\t      {\n\t        $val.Left = Math.max(a1, b1);\n\t        $val.Right = Math.min(a2, b2);\n\t      }\n\t      else\n\t      {\n\t        $val.Left = Math.max(a1, b2);\n\t        $val.Right = Math.min(a2, b1);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (b1 < b2)\n\t      {\n\t        $val.Left = Math.max(a2, b1);\n\t        $val.Right = Math.min(a1, b2);\n\t      }\n\t      else\n\t      {\n\t        $val.Left = Math.max(a2, b2);\n\t        $val.Right = Math.min(a1, b1);\n\t      }\n\t    }\n\t    return $val.Left < $val.Right;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n\t  {\n\t    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t    if (Dir1 == Dir2)\n\t      return false;\n\t    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n\t    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n\t    //So, to facilitate this while inserting Op1b and Op2b ...\n\t    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n\t    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n\t    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n\t    {\n\t      while (op1.Next.Pt.X <= Pt.X &&\n\t        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t        op1 = op1.Next;\n\t      if (DiscardLeft && (op1.Pt.X != Pt.X))\n\t        op1 = op1.Next;\n\t      op1b = this.DupOutPt(op1, !DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t      {\n\t        op1 = op1b;\n\t        //op1.Pt = Pt;\n\t        op1.Pt.X = Pt.X;\n\t        op1.Pt.Y = Pt.Y;\n\t        op1b = this.DupOutPt(op1, !DiscardLeft);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      while (op1.Next.Pt.X >= Pt.X &&\n\t        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t        op1 = op1.Next;\n\t      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n\t        op1 = op1.Next;\n\t      op1b = this.DupOutPt(op1, DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t      {\n\t        op1 = op1b;\n\t        //op1.Pt = Pt;\n\t        op1.Pt.X = Pt.X;\n\t        op1.Pt.Y = Pt.Y;\n\t        op1b = this.DupOutPt(op1, DiscardLeft);\n\t      }\n\t    }\n\t    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n\t    {\n\t      while (op2.Next.Pt.X <= Pt.X &&\n\t        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t        op2 = op2.Next;\n\t      if (DiscardLeft && (op2.Pt.X != Pt.X))\n\t        op2 = op2.Next;\n\t      op2b = this.DupOutPt(op2, !DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t      {\n\t        op2 = op2b;\n\t        //op2.Pt = Pt;\n\t        op2.Pt.X = Pt.X;\n\t        op2.Pt.Y = Pt.Y;\n\t        op2b = this.DupOutPt(op2, !DiscardLeft);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      while (op2.Next.Pt.X >= Pt.X &&\n\t        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t        op2 = op2.Next;\n\t      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n\t        op2 = op2.Next;\n\t      op2b = this.DupOutPt(op2, DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t      {\n\t        op2 = op2b;\n\t        //op2.Pt = Pt;\n\t        op2.Pt.X = Pt.X;\n\t        op2.Pt.Y = Pt.Y;\n\t        op2b = this.DupOutPt(op2, DiscardLeft);\n\t      }\n\t    }\n\t    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n\t    {\n\t      op1.Prev = op2;\n\t      op2.Next = op1;\n\t      op1b.Next = op2b;\n\t      op2b.Prev = op1b;\n\t    }\n\t    else\n\t    {\n\t      op1.Next = op2;\n\t      op2.Prev = op1;\n\t      op1b.Prev = op2b;\n\t      op2b.Next = op1b;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n\t  {\n\t    var op1 = j.OutPt1,\n\t      op1b = new ClipperLib.OutPt();\n\t    var op2 = j.OutPt2,\n\t      op2b = new ClipperLib.OutPt();\n\t    //There are 3 kinds of joins for output polygons ...\n\t    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n\t    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n\t    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n\t    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n\t    //3. StrictlySimple joins where edges touch but are not collinear and where\n\t    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n\t    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n\t    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n\t    {\n\t      //Strictly Simple join ...\n\t\t\t\tif (outRec1 != outRec2) return false;\n\t\n\t      op1b = j.OutPt1.Next;\n\t      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n\t        op1b = op1b.Next;\n\t      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n\t      op2b = j.OutPt2.Next;\n\t      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n\t        op2b = op2b.Next;\n\t      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n\t      if (reverse1 == reverse2)\n\t        return false;\n\t      if (reverse1)\n\t      {\n\t        op1b = this.DupOutPt(op1, false);\n\t        op2b = this.DupOutPt(op2, true);\n\t        op1.Prev = op2;\n\t        op2.Next = op1;\n\t        op1b.Next = op2b;\n\t        op2b.Prev = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t      else\n\t      {\n\t        op1b = this.DupOutPt(op1, true);\n\t        op2b = this.DupOutPt(op2, false);\n\t        op1.Next = op2;\n\t        op2.Prev = op1;\n\t        op1b.Prev = op2b;\n\t        op2b.Next = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t    }\n\t    else if (isHorizontal)\n\t    {\n\t      //treat horizontal joins differently to non-horizontal joins since with\n\t      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n\t      //may be anywhere along the horizontal edge.\n\t      op1b = op1;\n\t      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n\t        op1 = op1.Prev;\n\t      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n\t        op1b = op1b.Next;\n\t      if (op1b.Next == op1 || op1b.Next == op2)\n\t        return false;\n\t      //a flat 'polygon'\n\t      op2b = op2;\n\t      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n\t        op2 = op2.Prev;\n\t      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n\t        op2b = op2b.Next;\n\t      if (op2b.Next == op2 || op2b.Next == op1)\n\t        return false;\n\t      //a flat 'polygon'\n\t      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\t\n\t      var $val = {Left: null, Right: null};\n\t      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n\t        return false;\n\t      var Left = $val.Left;\n\t      var Right = $val.Right;\n\t\n\t      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n\t      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n\t      //on the discard Side as either may still be needed for other joins ...\n\t      var Pt = new ClipperLib.IntPoint();\n\t      var DiscardLeftSide;\n\t      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n\t      {\n\t        //Pt = op1.Pt;\n\t        Pt.X = op1.Pt.X;\n\t        Pt.Y = op1.Pt.Y;\n\t        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n\t      }\n\t      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n\t      {\n\t        //Pt = op2.Pt;\n\t        Pt.X = op2.Pt.X;\n\t        Pt.Y = op2.Pt.Y;\n\t        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n\t      }\n\t      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n\t      {\n\t        //Pt = op1b.Pt;\n\t        Pt.X = op1b.Pt.X;\n\t        Pt.Y = op1b.Pt.Y;\n\t        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n\t      }\n\t      else\n\t      {\n\t        //Pt = op2b.Pt;\n\t        Pt.X = op2b.Pt.X;\n\t        Pt.Y = op2b.Pt.Y;\n\t        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n\t      }\n\t      j.OutPt1 = op1;\n\t      j.OutPt2 = op2;\n\t      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n\t    }\n\t    else\n\t    {\n\t      //nb: For non-horizontal joins ...\n\t      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n\t      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n\t      //make sure the polygons are correctly oriented ...\n\t      op1b = op1.Next;\n\t      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t        op1b = op1b.Next;\n\t      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n\t      if (Reverse1)\n\t      {\n\t        op1b = op1.Prev;\n\t        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t          op1b = op1b.Prev;\n\t        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n\t          return false;\n\t      }\n\t      op2b = op2.Next;\n\t      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t        op2b = op2b.Next;\n\t      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n\t      if (Reverse2)\n\t      {\n\t        op2b = op2.Prev;\n\t        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t          op2b = op2b.Prev;\n\t        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n\t          return false;\n\t      }\n\t      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n\t        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n\t        return false;\n\t      if (Reverse1)\n\t      {\n\t        op1b = this.DupOutPt(op1, false);\n\t        op2b = this.DupOutPt(op2, true);\n\t        op1.Prev = op2;\n\t        op2.Next = op1;\n\t        op1b.Next = op2b;\n\t        op2b.Prev = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t      else\n\t      {\n\t        op1b = this.DupOutPt(op1, true);\n\t        op2b = this.DupOutPt(op2, false);\n\t        op1.Next = op2;\n\t        op2.Prev = op1;\n\t        op1b.Prev = op2b;\n\t        op2b.Next = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.GetBounds = function (paths)\n\t  {\n\t    var i = 0,\n\t      cnt = paths.length;\n\t    while (i < cnt && paths[i].length == 0) i++;\n\t    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n\t    var result = new ClipperLib.IntRect();\n\t    result.left = paths[i][0].X;\n\t    result.right = result.left;\n\t    result.top = paths[i][0].Y;\n\t    result.bottom = result.top;\n\t    for (; i < cnt; i++)\n\t      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n\t      {\n\t        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n\t        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n\t        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n\t        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n\t      }\n\t    return result;\n\t  }\n\t  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n\t  {\n\t    var opStart = ops;\n\t    var result = new ClipperLib.IntRect();\n\t    result.left = ops.Pt.X;\n\t    result.right = ops.Pt.X;\n\t    result.top = ops.Pt.Y;\n\t    result.bottom = ops.Pt.Y;\n\t    ops = ops.Next;\n\t    while (ops != opStart)\n\t    {\n\t      if (ops.Pt.X < result.left)\n\t        result.left = ops.Pt.X;\n\t      if (ops.Pt.X > result.right)\n\t        result.right = ops.Pt.X;\n\t      if (ops.Pt.Y < result.top)\n\t        result.top = ops.Pt.Y;\n\t      if (ops.Pt.Y > result.bottom)\n\t        result.bottom = ops.Pt.Y;\n\t      ops = ops.Next;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n\t  {\n\t    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t    var result = 0,\n\t      cnt = path.length;\n\t    if (cnt < 3)\n\t      return 0;\n\t    var ip = path[0];\n\t    for (var i = 1; i <= cnt; ++i)\n\t    {\n\t      var ipNext = (i == cnt ? path[0] : path[i]);\n\t      if (ipNext.Y == pt.Y)\n\t      {\n\t        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n\t          return -1;\n\t      }\n\t      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n\t      {\n\t        if (ip.X >= pt.X)\n\t        {\n\t          if (ipNext.X > pt.X)\n\t            result = 1 - result;\n\t          else\n\t          {\n\t            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t            if (d == 0)\n\t              return -1;\n\t            else if ((d > 0) == (ipNext.Y > ip.Y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          if (ipNext.X > pt.X)\n\t          {\n\t            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t            if (d == 0)\n\t              return -1;\n\t            else if ((d > 0) == (ipNext.Y > ip.Y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t      }\n\t      ip = ipNext;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n\t  {\n\t    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t    var result = 0;\n\t    var startOp = op;\n\t\t\tvar ptx = pt.X, pty = pt.Y;\n\t    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n\t    do\n\t    {\n\t\t\t\top = op.Next;\n\t\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n\t      if (poly1y == pty)\n\t      {\n\t        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n\t          return -1;\n\t      }\n\t      if ((poly0y < pty) != (poly1y < pty))\n\t      {\n\t        if (poly0x >= ptx)\n\t        {\n\t          if (poly1x > ptx)\n\t            result = 1 - result;\n\t          else\n\t          {\n\t            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t            if (d == 0)\n\t              return -1;\n\t            if ((d > 0) == (poly1y > poly0y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          if (poly1x > ptx)\n\t          {\n\t            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t            if (d == 0)\n\t              return -1;\n\t            if ((d > 0) == (poly1y > poly0y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t      }\n\t      poly0x = poly1x;\n\t      poly0y = poly1y;\n\t    } while (startOp != op);\n\t\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n\t  {\n\t    var op = outPt1;\n\t    do\n\t    {\n\t\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n\t      var res = this.PointInPolygon(op.Pt, outPt2);\n\t      if (res >= 0)\n\t        return res > 0;\n\t      op = op.Next;\n\t    }\n\t    while (op != outPt1)\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n\t  {\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\t\tif (firstLeft == OldOutRec)\n\t\t\t\t{\n\t        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n\t          outRec.FirstLeft = NewOutRec;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n\t  {\n\t    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n\t      if (outRec.FirstLeft == OldOutRec)\n\t        outRec.FirstLeft = NewOutRec;\n\t  };\n\t  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n\t  {\n\t    while (FirstLeft != null && FirstLeft.Pts == null)\n\t      FirstLeft = FirstLeft.FirstLeft;\n\t    return FirstLeft;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n\t    {\n\t      var join = this.m_Joins[i];\n\t      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n\t      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n\t      if (outRec1.Pts == null || outRec2.Pts == null)\n\t        continue;\n\t      //get the polygon fragment with the correct hole state (FirstLeft)\n\t      //before calling JoinPoints() ...\n\t      var holeStateRec;\n\t      if (outRec1 == outRec2)\n\t        holeStateRec = outRec1;\n\t      else if (this.Param1RightOfParam2(outRec1, outRec2))\n\t        holeStateRec = outRec2;\n\t      else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t        holeStateRec = outRec1;\n\t      else\n\t        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t\n\t      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\t\n\t      if (outRec1 == outRec2)\n\t      {\n\t        //instead of joining two polygons, we've just created a new one by\n\t        //splitting one polygon into two.\n\t        outRec1.Pts = join.OutPt1;\n\t        outRec1.BottomPt = null;\n\t        outRec2 = this.CreateOutRec();\n\t        outRec2.Pts = join.OutPt2;\n\t        //update all OutRec2.Pts Idx's ...\n\t        this.UpdateOutPtIdxs(outRec2);\n\t        //We now need to check every OutRec.FirstLeft pointer. If it points\n\t        //to OutRec1 it may need to point to OutRec2 instead ...\n\t        if (this.m_UsingPolyTree)\n\t          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n\t          {\n\t            var oRec = this.m_PolyOuts[j];\n\t            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n\t              continue;\n\t            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n\t              oRec.FirstLeft = outRec2;\n\t          }\n\t        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n\t        {\n\t          //outRec2 is contained by outRec1 ...\n\t          outRec2.IsHole = !outRec1.IsHole;\n\t          outRec2.FirstLeft = outRec1;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts2(outRec2, outRec1);\n\t          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n\t            this.ReversePolyPtLinks(outRec2.Pts);\n\t        }\n\t        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n\t        {\n\t          //outRec1 is contained by outRec2 ...\n\t          outRec2.IsHole = outRec1.IsHole;\n\t          outRec1.IsHole = !outRec2.IsHole;\n\t          outRec2.FirstLeft = outRec1.FirstLeft;\n\t          outRec1.FirstLeft = outRec2;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts2(outRec1, outRec2);\n\t          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n\t            this.ReversePolyPtLinks(outRec1.Pts);\n\t        }\n\t        else\n\t        {\n\t          //the 2 polygons are completely separate ...\n\t          outRec2.IsHole = outRec1.IsHole;\n\t          outRec2.FirstLeft = outRec1.FirstLeft;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec2\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts1(outRec1, outRec2);\n\t        }\n\t      }\n\t      else\n\t      {\n\t        //joined 2 polygons together ...\n\t        outRec2.Pts = null;\n\t        outRec2.BottomPt = null;\n\t        outRec2.Idx = outRec1.Idx;\n\t        outRec1.IsHole = holeStateRec.IsHole;\n\t        if (holeStateRec == outRec2)\n\t          outRec1.FirstLeft = outRec2.FirstLeft;\n\t        outRec2.FirstLeft = outRec1;\n\t        //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t        if (this.m_UsingPolyTree)\n\t          this.FixupFirstLefts2(outRec2, outRec1);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n\t  {\n\t    var op = outrec.Pts;\n\t    do {\n\t      op.Idx = outrec.Idx;\n\t      op = op.Prev;\n\t    }\n\t    while (op != outrec.Pts)\n\t  };\n\t  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n\t  {\n\t    var i = 0;\n\t    while (i < this.m_PolyOuts.length)\n\t    {\n\t      var outrec = this.m_PolyOuts[i++];\n\t      var op = outrec.Pts;\n\t\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\t\tcontinue;\n\t      do //for each Pt in Polygon until duplicate found do ...\n\t      {\n\t        var op2 = op.Next;\n\t        while (op2 != outrec.Pts)\n\t        {\n\t          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n\t          {\n\t            //split the polygon into two ...\n\t            var op3 = op.Prev;\n\t            var op4 = op2.Prev;\n\t            op.Prev = op4;\n\t            op4.Next = op;\n\t            op2.Prev = op3;\n\t            op3.Next = op2;\n\t            outrec.Pts = op;\n\t            var outrec2 = this.CreateOutRec();\n\t            outrec2.Pts = op2;\n\t            this.UpdateOutPtIdxs(outrec2);\n\t            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n\t            {\n\t              //OutRec2 is contained by OutRec1 ...\n\t              outrec2.IsHole = !outrec.IsHole;\n\t              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\t\n\t            }\n\t            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n\t            {\n\t              //OutRec1 is contained by OutRec2 ...\n\t              outrec2.IsHole = outrec.IsHole;\n\t              outrec.IsHole = !outrec2.IsHole;\n\t              outrec2.FirstLeft = outrec.FirstLeft;\n\t              outrec.FirstLeft = outrec2;\n\t              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n\t            }\n\t            else\n\t            {\n\t              //the 2 polygons are separate ...\n\t              outrec2.IsHole = outrec.IsHole;\n\t              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n\t            }\n\t            op2 = op;\n\t            //ie get ready for the next iteration\n\t          }\n\t          op2 = op2.Next;\n\t        }\n\t        op = op.Next;\n\t      }\n\t      while (op != outrec.Pts)\n\t    }\n\t  };\n\t  ClipperLib.Clipper.Area = function (poly)\n\t  {\n\t    var cnt = poly.length;\n\t    if (cnt < 3)\n\t      return 0;\n\t    var a = 0;\n\t    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n\t    {\n\t      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n\t      j = i;\n\t    }\n\t    return -a * 0.5;\n\t  };\n\t  ClipperLib.Clipper.prototype.Area = function (outRec)\n\t  {\n\t    var op = outRec.Pts;\n\t    if (op == null)\n\t      return 0;\n\t    var a = 0;\n\t    do {\n\t      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n\t      op = op.Next;\n\t    }\n\t    while (op != outRec.Pts)\n\t    return a * 0.5;\n\t  };\n\t  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n\t  {\n\t    var result = new Array();\n\t    var c = new ClipperLib.Clipper(0);\n\t    c.StrictlySimple = true;\n\t    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n\t    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n\t  {\n\t    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    var result = new Array();\n\t    var c = new ClipperLib.Clipper(0);\n\t    c.StrictlySimple = true;\n\t    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n\t    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n\t  {\n\t    var dx = (pt1.X - pt2.X);\n\t    var dy = (pt1.Y - pt2.Y);\n\t    return (dx * dx + dy * dy);\n\t  };\n\t  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n\t  {\n\t    //The equation of a line in general form (Ax + By + C = 0)\n\t    //given 2 points (x¹,y¹) & (x²,y²) is ...\n\t    //(y¹ - y²)x + (x² - x¹)y + (y² - y¹)x¹ - (x² - x¹)y¹ = 0\n\t    //A = (y¹ - y²); B = (x² - x¹); C = (y² - y¹)x¹ - (x² - x¹)y¹\n\t    //perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)\n\t    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n\t    var A = ln1.Y - ln2.Y;\n\t    var B = ln2.X - ln1.X;\n\t    var C = A * ln1.X + B * ln1.Y;\n\t    C = A * pt.X + B * pt.Y - C;\n\t    return (C * C) / (A * A + B * B);\n\t  };\n\t\n\t\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t\t{\n\t\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t\t//between the other 2 points is the one that's tested for distance.\n\t\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t\t{\n\t\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\t\telse\n\t\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t\t}\n\t\t}\n\t\n\t  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n\t  {\n\t    var dx = pt1.X - pt2.X;\n\t    var dy = pt1.Y - pt2.Y;\n\t    return ((dx * dx) + (dy * dy) <= distSqrd);\n\t  };\n\t  //------------------------------------------------------------------------------\n\t  ClipperLib.Clipper.ExcludeOp = function (op)\n\t  {\n\t    var result = op.Prev;\n\t    result.Next = op.Next;\n\t    op.Next.Prev = result;\n\t    result.Idx = 0;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n\t  {\n\t    if (typeof (distance) == \"undefined\") distance = 1.415;\n\t    //distance = proximity in units/pixels below which vertices will be stripped.\n\t    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n\t    //both x & y coords within 1 unit, then the second vertex will be stripped.\n\t    var cnt = path.length;\n\t    if (cnt == 0)\n\t      return new Array();\n\t    var outPts = new Array(cnt);\n\t    for (var i = 0; i < cnt; ++i)\n\t      outPts[i] = new ClipperLib.OutPt();\n\t    for (var i = 0; i < cnt; ++i)\n\t    {\n\t      outPts[i].Pt = path[i];\n\t      outPts[i].Next = outPts[(i + 1) % cnt];\n\t      outPts[i].Next.Prev = outPts[i];\n\t      outPts[i].Idx = 0;\n\t    }\n\t    var distSqrd = distance * distance;\n\t    var op = outPts[0];\n\t    while (op.Idx == 0 && op.Next != op.Prev)\n\t    {\n\t      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n\t      {\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt--;\n\t      }\n\t      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n\t      {\n\t        ClipperLib.Clipper.ExcludeOp(op.Next);\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt -= 2;\n\t      }\n\t      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n\t      {\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt--;\n\t      }\n\t      else\n\t      {\n\t        op.Idx = 1;\n\t        op = op.Next;\n\t      }\n\t    }\n\t    if (cnt < 3)\n\t      cnt = 0;\n\t    var result = new Array(cnt);\n\t    for (var i = 0; i < cnt; ++i)\n\t    {\n\t      result[i] = new ClipperLib.IntPoint(op.Pt);\n\t      op = op.Next;\n\t    }\n\t    outPts = null;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n\t  {\n\t    var result = new Array(polys.length);\n\t    for (var i = 0, ilen = polys.length; i < ilen; i++)\n\t      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n\t  {\n\t    var delta = (IsClosed ? 1 : 0);\n\t    var polyCnt = pattern.length;\n\t    var pathCnt = path.length;\n\t    var result = new Array();\n\t    if (IsSum)\n\t      for (var i = 0; i < pathCnt; i++)\n\t      {\n\t        var p = new Array(polyCnt);\n\t        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n\t        result.push(p);\n\t      }\n\t    else\n\t      for (var i = 0; i < pathCnt; i++)\n\t      {\n\t        var p = new Array(polyCnt);\n\t        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n\t        result.push(p);\n\t      }\n\t    var quads = new Array();\n\t    for (var i = 0; i < pathCnt - 1 + delta; i++)\n\t      for (var j = 0; j < polyCnt; j++)\n\t      {\n\t        var quad = new Array();\n\t        quad.push(result[i % pathCnt][j % polyCnt]);\n\t        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n\t        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n\t        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n\t        if (!ClipperLib.Clipper.Orientation(quad))\n\t          quad.reverse();\n\t        quads.push(quad);\n\t      }\n\t\t\t\treturn quads;\n\t  };\n\t\n\t\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t\t{\n\t\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t\t{\n\t\t\t\tvar path = path_or_paths;\n\t\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\t\treturn paths;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t \t\t\tvar paths = path_or_paths;\n\t\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t\t{\n\t\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\t\tif (pathIsClosed)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\t\treturn solution;\n\t\t\t}\n\t\t}\n\t\t//------------------------------------------------------------------------------\n\t\n\t\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t\t{\n\t\t\tvar outPath = new ClipperLib.Path();\n\t\t\tfor (var i = 0; i < path.length; i++)\n\t\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\t\treturn outPath;\n\t\t}\n\t\t//------------------------------------------------------------------------------\n\t\n\t\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t\t{\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\n\t  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n\t  {\n\t    var result = new Array();\n\t    //result.set_Capacity(polytree.get_Total());\n\t    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n\t  {\n\t    var match = true;\n\t    switch (nt)\n\t    {\n\t    case ClipperLib.Clipper.NodeType.ntOpen:\n\t      return;\n\t    case ClipperLib.Clipper.NodeType.ntClosed:\n\t      match = !polynode.IsOpen;\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t    if (polynode.m_polygon.length > 0 && match)\n\t      paths.push(polynode.m_polygon);\n\t    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n\t      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n\t  };\n\t  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n\t  {\n\t    var result = new ClipperLib.Paths();\n\t    //result.set_Capacity(polytree.ChildCount());\n\t    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n\t      if (polytree.Childs()[i].IsOpen)\n\t        result.push(polytree.Childs()[i].m_polygon);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n\t  {\n\t    var result = new ClipperLib.Paths();\n\t    //result.set_Capacity(polytree.Total());\n\t    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n\t    return result;\n\t  };\n\t  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n\t  ClipperLib.Clipper.NodeType = {\n\t    ntAny: 0,\n\t    ntOpen: 1,\n\t    ntClosed: 2\n\t  };\n\t  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n\t  {\n\t    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n\t    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    this.m_destPolys = new ClipperLib.Paths();\n\t    this.m_srcPoly = new ClipperLib.Path();\n\t    this.m_destPoly = new ClipperLib.Path();\n\t    this.m_normals = new Array();\n\t    this.m_delta = 0;\n\t    this.m_sinA = 0;\n\t    this.m_sin = 0;\n\t    this.m_cos = 0;\n\t    this.m_miterLim = 0;\n\t    this.m_StepsPerRad = 0;\n\t    this.m_lowest = new ClipperLib.IntPoint();\n\t    this.m_polyNodes = new ClipperLib.PolyNode();\n\t    this.MiterLimit = miterLimit;\n\t    this.ArcTolerance = arcTolerance;\n\t    this.m_lowest.X = -1;\n\t  };\n\t  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n\t  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n\t  ClipperLib.ClipperOffset.prototype.Clear = function ()\n\t  {\n\t    ClipperLib.Clear(this.m_polyNodes.Childs());\n\t    this.m_lowest.X = -1;\n\t  };\n\t  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n\t  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n\t  {\n\t    var highI = path.length - 1;\n\t    if (highI < 0)\n\t      return;\n\t    var newNode = new ClipperLib.PolyNode();\n\t    newNode.m_jointype = joinType;\n\t    newNode.m_endtype = endType;\n\t    //strip duplicate points from path and also get index to the lowest point ...\n\t    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n\t      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n\t        highI--;\n\t    //newNode.m_polygon.set_Capacity(highI + 1);\n\t    newNode.m_polygon.push(path[0]);\n\t    var j = 0,\n\t      k = 0;\n\t    for (var i = 1; i <= highI; i++)\n\t      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n\t      {\n\t        j++;\n\t        newNode.m_polygon.push(path[i]);\n\t        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n\t          k = j;\n\t      }\n\t    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\t\n\t    this.m_polyNodes.AddChild(newNode);\n\t    //if this path's lowest pt is lower than all the others then update m_lowest\n\t    if (endType != ClipperLib.EndType.etClosedPolygon)\n\t      return;\n\t    if (this.m_lowest.X < 0)\n\t      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n\t    else\n\t    {\n\t      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n\t      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n\t        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n\t  {\n\t    for (var i = 0, ilen = paths.length; i < ilen; i++)\n\t      this.AddPath(paths[i], joinType, endType);\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n\t  {\n\t    //fixup orientations of all closed paths if the orientation of the\n\t    //closed path with the lowermost vertex is wrong ...\n\t    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n\t    {\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n\t          node.m_polygon.reverse();\n\t      }\n\t    }\n\t    else\n\t    {\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n\t          node.m_polygon.reverse();\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n\t  {\n\t    var dx = (pt2.X - pt1.X);\n\t    var dy = (pt2.Y - pt1.Y);\n\t    if ((dx == 0) && (dy == 0))\n\t      return new ClipperLib.DoublePoint(0, 0);\n\t    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n\t    dx *= f;\n\t    dy *= f;\n\t    return new ClipperLib.DoublePoint(dy, -dx);\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n\t  {\n\t    this.m_destPolys = new Array();\n\t    this.m_delta = delta;\n\t    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n\t    if (ClipperLib.ClipperBase.near_zero(delta))\n\t    {\n\t      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t          this.m_destPolys.push(node.m_polygon);\n\t      }\n\t      return;\n\t    }\n\t    //see offset_triginometry3.svg in the documentation folder ...\n\t    if (this.MiterLimit > 2)\n\t      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n\t    else\n\t      this.m_miterLim = 0.5;\n\t    var y;\n\t    if (this.ArcTolerance <= 0)\n\t      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n\t      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    else\n\t      y = this.ArcTolerance;\n\t    //see offset_triginometry2.svg in the documentation folder ...\n\t    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n\t    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n\t    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n\t    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n\t    if (delta < 0)\n\t      this.m_sin = -this.m_sin;\n\t    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n\t    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t    {\n\t      var node = this.m_polyNodes.Childs()[i];\n\t      this.m_srcPoly = node.m_polygon;\n\t      var len = this.m_srcPoly.length;\n\t      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n\t        continue;\n\t      this.m_destPoly = new Array();\n\t      if (len == 1)\n\t      {\n\t        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n\t        {\n\t          var X = 1,\n\t            Y = 0;\n\t          for (var j = 1; j <= steps; j++)\n\t          {\n\t            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t            var X2 = X;\n\t            X = X * this.m_cos - this.m_sin * Y;\n\t            Y = X2 * this.m_sin + Y * this.m_cos;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          var X = -1,\n\t            Y = -1;\n\t          for (var j = 0; j < 4; ++j)\n\t          {\n\t            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t            if (X < 0)\n\t              X = 1;\n\t            else if (Y < 0)\n\t              Y = 1;\n\t            else\n\t              X = -1;\n\t          }\n\t        }\n\t        this.m_destPolys.push(this.m_destPoly);\n\t        continue;\n\t      }\n\t      //build m_normals ...\n\t      this.m_normals.length = 0;\n\t      //this.m_normals.set_Capacity(len);\n\t      for (var j = 0; j < len - 1; j++)\n\t        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n\t      else\n\t        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t      {\n\t        var k = len - 1;\n\t        for (var j = 0; j < len; j++)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n\t      {\n\t        var k = len - 1;\n\t        for (var j = 0; j < len; j++)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t        this.m_destPoly = new Array();\n\t        //re-build m_normals ...\n\t        var n = this.m_normals[len - 1];\n\t        for (var j = len - 1; j > 0; j--)\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n\t        k = 0;\n\t        for (var j = len - 1; j >= 0; j--)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t      else\n\t      {\n\t        var k = 0;\n\t        for (var j = 1; j < len - 1; ++j)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        var pt1;\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t        {\n\t          var j = len - 1;\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t        }\n\t        else\n\t        {\n\t          var j = len - 1;\n\t          k = len - 2;\n\t          this.m_sinA = 0;\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n\t          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t            this.DoSquare(j, k);\n\t          else\n\t            this.DoRound(j, k);\n\t        }\n\t        //re-build m_normals ...\n\t        for (var j = len - 1; j > 0; j--)\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n\t        k = len - 1;\n\t        for (var j = k - 1; j > 0; --j)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t        {\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t        }\n\t        else\n\t        {\n\t          k = 1;\n\t          this.m_sinA = 0;\n\t          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t            this.DoSquare(0, 1);\n\t          else\n\t            this.DoRound(0, 1);\n\t        }\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.Execute = function ()\n\t  {\n\t    var a = arguments,\n\t      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n\t    if (!ispolytree) // function (solution, delta)\n\t    {\n\t      var solution = a[0],\n\t        delta = a[1];\n\t      ClipperLib.Clear(solution);\n\t      this.FixOrientations();\n\t      this.DoOffset(delta);\n\t      //now clean up 'corners' ...\n\t      var clpr = new ClipperLib.Clipper(0);\n\t      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t      if (delta > 0)\n\t      {\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t      }\n\t      else\n\t      {\n\t        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t        var outer = new ClipperLib.Path();\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t        clpr.ReverseSolution = true;\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t        if (solution.length > 0)\n\t          solution.splice(0, 1);\n\t      }\n\t      //console.log(JSON.stringify(solution));\n\t    }\n\t    else // function (polytree, delta)\n\t    {\n\t      var solution = a[0],\n\t        delta = a[1];\n\t      solution.Clear();\n\t      this.FixOrientations();\n\t      this.DoOffset(delta);\n\t      //now clean up 'corners' ...\n\t      var clpr = new ClipperLib.Clipper(0);\n\t      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t      if (delta > 0)\n\t      {\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t      }\n\t      else\n\t      {\n\t        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t        var outer = new ClipperLib.Path();\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t        clpr.ReverseSolution = true;\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t        //remove the outer PolyNode rectangle ...\n\t        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n\t        {\n\t          var outerNode = solution.Childs()[0];\n\t          //solution.Childs.set_Capacity(outerNode.ChildCount);\n\t          solution.Childs()[0] = outerNode.Childs()[0];\n\t          solution.Childs()[0].m_Parent = solution;\n\t          for (var i = 1; i < outerNode.ChildCount(); i++)\n\t            solution.AddChild(outerNode.Childs()[i]);\n\t        }\n\t        else\n\t          solution.Clear();\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n\t  {\n\t\t\t//cross product ...\n\t\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\t\n\t\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t\t{\n\t\t\t\t//dot product ...\n\t\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t\t{\n\t\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\t\treturn k;\n\t\t\t\t}\n\t\t\t\t//else angle ==> 180 degrees\n\t\t\t}\n\t    else if (this.m_sinA > 1)\n\t      this.m_sinA = 1.0;\n\t    else if (this.m_sinA < -1)\n\t      this.m_sinA = -1.0;\n\t    if (this.m_sinA * this.m_delta < 0)\n\t    {\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t    }\n\t    else\n\t      switch (jointype)\n\t      {\n\t      case ClipperLib.JoinType.jtMiter:\n\t        {\n\t          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t          if (r >= this.m_miterLim)\n\t            this.DoMiter(j, k, r);\n\t          else\n\t            this.DoSquare(j, k);\n\t          break;\n\t        }\n\t      case ClipperLib.JoinType.jtSquare:\n\t        this.DoSquare(j, k);\n\t        break;\n\t      case ClipperLib.JoinType.jtRound:\n\t        this.DoRound(j, k);\n\t        break;\n\t      }\n\t    k = j;\n\t    return k;\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n\t  {\n\t    var dx = Math.tan(Math.atan2(this.m_sinA,\n\t      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n\t  {\n\t    var q = this.m_delta / r;\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n\t  {\n\t    var a = Math.atan2(this.m_sinA,\n\t      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\t\n\t    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\t\n\t    var X = this.m_normals[k].X,\n\t      Y = this.m_normals[k].Y,\n\t      X2;\n\t    for (var i = 0; i < steps; ++i)\n\t    {\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n\t      X2 = X;\n\t      X = X * this.m_cos - this.m_sin * Y;\n\t      Y = X2 * this.m_sin + Y * this.m_cos;\n\t    }\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t  };\n\t  ClipperLib.Error = function (message)\n\t  {\n\t    try\n\t    {\n\t      throw new Error(message);\n\t    }\n\t    catch (err)\n\t    {\n\t      alert(err.message);\n\t    }\n\t  };\n\t  // ---------------------------------\n\t  // JS extension by Timo 2013\n\t  ClipperLib.JS = {};\n\t  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n\t  };\n\t  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var area = 0;\n\t    for (var i = 0; i < poly.length; i++)\n\t    {\n\t      area += ClipperLib.Clipper.Area(poly[i]);\n\t    }\n\t    return area / (scale * scale);\n\t  };\n\t  ClipperLib.JS.BoundsOfPath = function (path, scale)\n\t  {\n\t    return ClipperLib.JS.BoundsOfPaths([path], scale);\n\t  };\n\t  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var bounds = ClipperLib.Clipper.GetBounds(paths);\n\t    bounds.left /= scale;\n\t    bounds.bottom /= scale;\n\t    bounds.right /= scale;\n\t    bounds.top /= scale;\n\t    return bounds;\n\t  };\n\t  // Clean() joins vertices that are too near each other\n\t  // and causes distortion to offsetted polygons without cleaning\n\t  ClipperLib.JS.Clean = function (polygon, delta)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    var isPolygons = polygon[0] instanceof Array;\n\t    var polygon = ClipperLib.JS.Clone(polygon);\n\t    if (typeof delta != \"number\" || delta === null)\n\t    {\n\t      ClipperLib.Error(\"Delta is not a number in Clean().\");\n\t      return polygon;\n\t    }\n\t    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n\t    if (!isPolygons) polygon = [polygon];\n\t    var k_length = polygon.length;\n\t    var len, poly, result, d, p, j, i;\n\t    var results = [];\n\t    for (var k = 0; k < k_length; k++)\n\t    {\n\t      poly = polygon[k];\n\t      len = poly.length;\n\t      if (len === 0) continue;\n\t      else if (len < 3)\n\t      {\n\t        result = poly;\n\t        results.push(result);\n\t        continue;\n\t      }\n\t      result = poly;\n\t      d = delta * delta;\n\t      //d = Math.floor(c_delta * c_delta);\n\t      p = poly[0];\n\t      j = 1;\n\t      for (i = 1; i < len; i++)\n\t      {\n\t        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n\t          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n\t          continue;\n\t        result[j] = poly[i];\n\t        p = poly[i];\n\t        j++;\n\t      }\n\t      p = poly[j - 1];\n\t      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n\t        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n\t        j--;\n\t      if (j < len)\n\t        result.splice(j, len - j);\n\t      if (result.length) results.push(result);\n\t    }\n\t    if (!isPolygons && results.length) results = results[0];\n\t    else if (!isPolygons && results.length === 0) results = [];\n\t    else if (isPolygons && results.length === 0) results = [\n\t      []\n\t    ];\n\t    return results;\n\t  }\n\t  // Make deep copy of Polygons or Polygon\n\t  // so that also IntPoint objects are cloned and not only referenced\n\t  // This should be the fastest way\n\t  ClipperLib.JS.Clone = function (polygon)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    if (polygon.length === 0) return [];\n\t    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n\t    var isPolygons = polygon[0] instanceof Array;\n\t    if (!isPolygons) polygon = [polygon];\n\t    var len = polygon.length,\n\t      plen, i, j, result;\n\t    var results = new Array(len);\n\t    for (i = 0; i < len; i++)\n\t    {\n\t      plen = polygon[i].length;\n\t      result = new Array(plen);\n\t      for (j = 0; j < plen; j++)\n\t      {\n\t        result[j] = {\n\t          X: polygon[i][j].X,\n\t          Y: polygon[i][j].Y\n\t        };\n\t      }\n\t      results[i] = result;\n\t    }\n\t    if (!isPolygons) results = results[0];\n\t    return results;\n\t  };\n\t  // Removes points that doesn't affect much to the visual appearance.\n\t  // If middle point is at or under certain distance (tolerance) of the line segment between\n\t  // start and end point, the middle point is removed.\n\t  ClipperLib.JS.Lighten = function (polygon, tolerance)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    if (typeof tolerance != \"number\" || tolerance === null)\n\t    {\n\t      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n\t      return ClipperLib.JS.Clone(polygon);\n\t    }\n\t    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n\t    {\n\t      return ClipperLib.JS.Clone(polygon);\n\t    }\n\t    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n\t    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n\t    var bxax, byay, l, ax, ay;\n\t    var len = polygon.length;\n\t    var toleranceSq = tolerance * tolerance;\n\t    var results = [];\n\t    for (i = 0; i < len; i++)\n\t    {\n\t      poly = polygon[i];\n\t      plen = poly.length;\n\t      if (plen == 0) continue;\n\t      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n\t      {\n\t        poly2 = [];\n\t        plen = poly.length;\n\t        // the first have to added to the end, if first and last are not the same\n\t        // this way we ensure that also the actual last point can be removed if needed\n\t        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n\t        {\n\t          addlast = 1;\n\t          poly.push(\n\t          {\n\t            X: poly[0].X,\n\t            Y: poly[0].Y\n\t          });\n\t          plen = poly.length;\n\t        }\n\t        else addlast = 0;\n\t        rem = []; // Indexes of removed points\n\t        for (j = 0; j < plen - 2; j++)\n\t        {\n\t          A = poly[j]; // Start point of line segment\n\t          P = poly[j + 1]; // Middle point. This is the one to be removed.\n\t          B = poly[j + 2]; // End point of line segment\n\t          ax = A.X;\n\t          ay = A.Y;\n\t          bxax = B.X - ax;\n\t          byay = B.Y - ay;\n\t          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n\t          {\n\t            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n\t            if (l > 1)\n\t            {\n\t              ax = B.X;\n\t              ay = B.Y;\n\t            }\n\t            else if (l > 0)\n\t            {\n\t              ax += bxax * l;\n\t              ay += byay * l;\n\t            }\n\t          }\n\t          bxax = P.X - ax;\n\t          byay = P.Y - ay;\n\t          d = bxax * bxax + byay * byay;\n\t          if (d <= toleranceSq)\n\t          {\n\t            rem[j + 1] = 1;\n\t            j++; // when removed, transfer the pointer to the next one\n\t          }\n\t        }\n\t        // add all unremoved points to poly2\n\t        poly2.push(\n\t        {\n\t          X: poly[0].X,\n\t          Y: poly[0].Y\n\t        });\n\t        for (j = 1; j < plen - 1; j++)\n\t          if (!rem[j]) poly2.push(\n\t          {\n\t            X: poly[j].X,\n\t            Y: poly[j].Y\n\t          });\n\t        poly2.push(\n\t        {\n\t          X: poly[plen - 1].X,\n\t          Y: poly[plen - 1].Y\n\t        });\n\t        // if the first point was added to the end, remove it\n\t        if (addlast) poly.pop();\n\t        // break, if there was not anymore removed points\n\t        if (!rem.length) break;\n\t        // else continue looping using poly2, to check if there are points to remove\n\t        else poly = poly2;\n\t      }\n\t      plen = poly2.length;\n\t      // remove duplicate from end, if needed\n\t      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n\t      {\n\t        poly2.pop();\n\t      }\n\t      if (poly2.length > 2) // to avoid two-point-polygons\n\t        results.push(poly2);\n\t    }\n\t    if (!(polygon[0] instanceof Array)) results = results[0];\n\t    if (typeof (results) == \"undefined\") results = [\n\t      []\n\t    ];\n\t    return results;\n\t  }\n\t  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n\t  {\n\t    if (typeof (path) == \"undefined\") return 0;\n\t    var sqrt = Math.sqrt;\n\t    var perimeter = 0.0;\n\t    var p1, p2, p1x = 0.0,\n\t      p1y = 0.0,\n\t      p2x = 0.0,\n\t      p2y = 0.0;\n\t    var j = path.length;\n\t    if (j < 2) return 0;\n\t    if (closed)\n\t    {\n\t      path[j] = path[0];\n\t      j++;\n\t    }\n\t    while (--j)\n\t    {\n\t      p1 = path[j];\n\t      p1x = p1.X;\n\t      p1y = p1.Y;\n\t      p2 = path[j - 1];\n\t      p2x = p2.X;\n\t      p2y = p2.Y;\n\t      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n\t    }\n\t    if (closed) path.pop();\n\t    return perimeter / scale;\n\t  };\n\t  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var perimeter = 0;\n\t    for (var i = 0; i < paths.length; i++)\n\t    {\n\t      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n\t    }\n\t    return perimeter;\n\t  };\n\t  ClipperLib.JS.ScaleDownPath = function (path, scale)\n\t  {\n\t    var i, p;\n\t    if (!scale) scale = 1;\n\t    i = path.length;\n\t    while (i--)\n\t    {\n\t      p = path[i];\n\t      p.X = p.X / scale;\n\t      p.Y = p.Y / scale;\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n\t  {\n\t    var i, j, p;\n\t    if (!scale) scale = 1;\n\t    i = paths.length;\n\t    while (i--)\n\t    {\n\t      j = paths[i].length;\n\t      while (j--)\n\t      {\n\t        p = paths[i][j];\n\t        p.X = p.X / scale;\n\t        p.Y = p.Y / scale;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleUpPath = function (path, scale)\n\t  {\n\t    var i, p, round = Math.round;\n\t    if (!scale) scale = 1;\n\t    i = path.length;\n\t    while (i--)\n\t    {\n\t      p = path[i];\n\t      p.X = round(p.X * scale);\n\t      p.Y = round(p.Y * scale);\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n\t  {\n\t    var i, j, p, round = Math.round;\n\t    if (!scale) scale = 1;\n\t    i = paths.length;\n\t    while (i--)\n\t    {\n\t      j = paths[i].length;\n\t      while (j--)\n\t      {\n\t        p = paths[i][j];\n\t        p.X = round(p.X * scale);\n\t        p.Y = round(p.Y * scale);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ExPolygons = function ()\n\t  {\n\t    return [];\n\t  }\n\t  ClipperLib.ExPolygon = function ()\n\t  {\n\t    this.outer = null;\n\t    this.holes = null;\n\t  };\n\t  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n\t  {\n\t    var ep = new ClipperLib.ExPolygon();\n\t    ep.outer = polynode.Contour();\n\t    var childs = polynode.Childs();\n\t    var ilen = childs.length;\n\t    ep.holes = new Array(ilen);\n\t    var node, n, i, j, childs2, jlen;\n\t    for (i = 0; i < ilen; i++)\n\t    {\n\t      node = childs[i];\n\t      ep.holes[i] = node.Contour();\n\t      //Add outer polygons contained by (nested within) holes ...\n\t      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n\t      {\n\t        n = childs2[j];\n\t        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n\t      }\n\t    }\n\t    expolygons.push(ep);\n\t  };\n\t  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n\t  {\n\t    var a, i, alen, ilen;\n\t    var paths = new ClipperLib.Paths();\n\t    for (a = 0, alen = expolygons.length; a < alen; a++)\n\t    {\n\t      paths.push(expolygons[a].outer);\n\t      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n\t      {\n\t        paths.push(expolygons[a].holes[i]);\n\t      }\n\t    }\n\t    return paths;\n\t  }\n\t  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n\t  {\n\t    var expolygons = new ClipperLib.ExPolygons();\n\t    var node, i, childs, ilen;\n\t    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n\t    {\n\t      node = childs[i];\n\t      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n\t    }\n\t    return expolygons;\n\t  };\n\t})();\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// lw.svg-parser.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a1c30d821b36694f4a69","class Point {\n    // Class constructor...\n    constructor(x, y) {\n        // Init properties\n        this.x = parseFloat(x)\n        this.y = parseFloat(y)\n\n        if (isNaN(this.x) || isNaN(this.y)) {\n            console.error('x:', x, 'y:', y)\n            throw new Error('Float value!!!')\n        }\n    }\n\n    isEqual(point) {\n        return this.x === point.x && this.y === point.y\n    }\n}\n\nclass Path {\n    // Class constructor...\n    constructor() {\n        // Init properties\n        this.points = []\n        this.length = 0\n    }\n\n    getPoints() {\n        return this.points\n    }\n\n    getFlattenPoints() {\n        let points = []\n        this.points.forEach(point => points.push(point.x, point.y))\n        return points\n    }\n\n    getClipperPoints(scaleUp = 1) {\n        let points = []\n        this.points.forEach(point => points.push({ X: parseInt(point.x * scaleUp), Y: parseInt(point.y * scaleUp) }))\n        return points\n    }\n\n    fromClipperPoints(points, scaleDown = 1) {\n        this.points = []\n        points.forEach(point => this.addPoint(parseFloat(point.X * scaleDown), parseFloat(point.Y * scaleDown)))\n        return this\n    }\n\n    getPoint(i) {\n        return this.points[i < 0 ? this.length + i : i] || null\n    }\n\n    addPoint(x, y) {\n        this.points.push(new Point(x, y))\n        this.length = this.points.length\n    }\n\n    addPoints(points) {\n        // For each couple of points\n        for (let i = 0, il = points.length; i < il; i += 2) {\n            this.addPoint(points[i], points[i + 1])\n        }\n    }\n\n    isClosed() {\n        let firstPoint = this.getPoint(0)\n        return firstPoint && firstPoint.isEqual(this.getPoint(-1))\n    }\n\n    close() {\n        if (! this.isClosed() && this.length > 2) {\n            let firstPoint = this.getPoint(0)\n            this.addPoint(firstPoint.x, firstPoint.y)\n            return true\n        }\n\n        return false\n    }\n\n    transform(matrix) {\n        this.points = this.points.map(point => {\n            return new Point(\n                matrix[0] * point.x + matrix[2] * point.y + matrix[4],\n                matrix[1] * point.x + matrix[3] * point.y + matrix[5]\n            )\n        })\n    }\n}\n\n// Exports\nexport { Path, Point }\nexport default Path\n\n\n\n// WEBPACK FOOTER //\n// ./path.js","// Imports\r\nimport { Tag } from './tag'\r\nimport { TagParser } from './tagparser'\r\n\r\n// SVG parser class\r\nclass Parser {\r\n    // Class constructor...\r\n    constructor(settings) {\r\n        // Defaults settings\r\n        settings = settings || {}\r\n\r\n        // Init properties\r\n        this.element  = null // XML document Element object\r\n        this.editor   = null // Editor info { name, version, fingerprint }\r\n        this.document = null // Document info { width, height, viewBox }\r\n        this.defs     = null // Defined <defs> (DOM) nodes list by id\r\n        this.tags     = null // Tag objects hierarchy\r\n\r\n        // Trace settings (Arc, Bezier)\r\n        this.traceSettings = Object.assign({\r\n            linear       : true, // Linear trace mode\r\n            step         : 0.01, // Step resolution if linear mode = false\r\n            resolution   : 100,  // Number of segments we use to approximate arc length\r\n            segmentLength: 1,    // Segment length\r\n        }, settings.traceSettings || {})\r\n\r\n        // Supported tags by this lib\r\n        this.supportedTags = [\r\n            'svg', 'g', 'defs', 'use',\r\n            'line', 'polyline', 'polygon',\r\n            'rect', 'circle', 'ellipse', 'path',\r\n            'title', 'desc'\r\n        ]\r\n\r\n        // Tags list to includes/excludes\r\n        this.parseTags = settings.includes || this.supportedTags\r\n        this.skipTags  = settings.excludes || ['#text', '#comment']  // silent (no warning)\r\n\r\n        // User onTag callback ?\r\n        settings.onTag && this.onTag(settings.onTag, settings.onTagContext)\r\n    }\r\n    \r\n    // Load raw XML string, XMLDocument, Element or File object\r\n    load(input) {\r\n        // Load raw XML string\r\n        if (typeof input === 'string') {\r\n            return this.loadFromString(input)\r\n        }\r\n\r\n        // Load File object\r\n        if (input instanceof File) {\r\n            return this.loadFromFile(input)\r\n        }\r\n\r\n        // Load XMLDocument object\r\n        if (input instanceof XMLDocument) {\r\n            return this.loadFromXMLDocument(input)\r\n        }\r\n\r\n        // Load Element object\r\n        if (input instanceof Element) {\r\n            return this.loadFromElement(input)\r\n        }\r\n\r\n        // Return rejected promise with an Error object\r\n        return Promise.reject(new Error('Unsupported input format.'))\r\n    }\r\n\r\n    // Load from Element object\r\n    loadFromElement(input) {\r\n        return new Promise((resolve, reject) => {\r\n            // Bad input type\r\n            if (! (input instanceof Element)) {\r\n                reject(new Error('Input param must be a Element object.'))\r\n            }\r\n\r\n            // Parser error\r\n            if (input.nodeName === 'parsererror') { // FF\r\n                reject(new Error(input.textContent))\r\n            }\r\n\r\n            if (input.nodeName === 'html' && input.getElementsByTagName('parsererror')) { // Chrome\r\n                reject(new Error(input.getElementsByTagName('parsererror')[0].textContent))\r\n            }\r\n\r\n            // Set document element\r\n            this.element = input\r\n\r\n            // Resolve promise\r\n            resolve(input)\r\n        })\r\n    }\r\n\r\n    // Load from XMLDocument object\r\n    loadFromXMLDocument(input) {\r\n        return new Promise((resolve, reject) => {\r\n            // Bad input type\r\n            if (! (input instanceof XMLDocument)) {\r\n                reject(new Error('Input param must be a XMLDocument object.'))\r\n            }\r\n\r\n            // Load from Element...\r\n            this.loadFromElement(input.documentElement).then(resolve).catch(reject)\r\n        })\r\n    }\r\n\r\n    // Load raw XML string\r\n    loadFromString(input) {\r\n        return new Promise((resolve, reject) => {\r\n            // Bad input type\r\n            if (typeof input !== 'string') {\r\n                reject(new Error('Input param must be a string.'))\r\n            }\r\n\r\n            // Parse svg editor\r\n            this._parseEditor(input)\r\n\r\n            // Parse string as DOM object\r\n            let parser = new DOMParser()\r\n            let XMLDoc = parser.parseFromString(input, 'text/xml')\r\n\r\n            // Load from XMLDocument...\r\n            this.loadFromXMLDocument(XMLDoc).then(resolve).catch(reject)\r\n        })\r\n    }\r\n\r\n    // Try to get the svg editor from input string\r\n    _parseEditor(input) {\r\n        // Reset editor\r\n        this.editor = {\r\n            name       : 'unknown',\r\n            version    : null,\r\n            fingerprint: null\r\n        }\r\n\r\n        // Fingerprint matches\r\n        let fingerprint\r\n\r\n        // Inkscape\r\n        fingerprint = input.match(/<!-- Created with Inkscape .*-->/i)\r\n\r\n        if (fingerprint) {\r\n            this.editor.name        = 'inkscape'\r\n            this.editor.fingerprint = fingerprint[0]\r\n\r\n            return this.editor\r\n        }\r\n\r\n        // Illustrator\r\n        fingerprint = input.match(/<!-- Generator: Adobe Illustrator ([0-9\\.]+), .*-->/i)\r\n\r\n        if (fingerprint) {\r\n            this.editor.name        = 'illustrator'\r\n            this.editor.version     = fingerprint[1]\r\n            this.editor.fingerprint = fingerprint[0]\r\n\r\n            return this.editor\r\n        }\r\n\r\n        // Return default\r\n        return this.editor\r\n    }\r\n\r\n    // Load from File object\r\n    loadFromFile(input) {\r\n        return new Promise((resolve, reject) => {\r\n            // Bad input type\r\n            if (! (input instanceof File)) {\r\n                reject(new Error('Input param must be a File object.'))\r\n            }\r\n\r\n            // Create file reader\r\n            let reader = new FileReader()\r\n\r\n            // Register reader events handlers\r\n            reader.onload = event => {\r\n                this.loadFromString(event.target.result).then(resolve).catch(reject)\r\n            }\r\n\r\n            reader.onerror = event => {\r\n                reject(new Error('Error reading file : ' + input.name))\r\n            }\r\n\r\n            // Finally read input file as text\r\n            reader.readAsText(input)\r\n        })\r\n    }\r\n\r\n    // Parse the (loaded) element\r\n    parse(input) {\r\n        // Reset properties\r\n        this.document = null\r\n        this.defs     = {}\r\n        this.tags     = null\r\n\r\n        // Load input if provided\r\n        if (input) {\r\n            return new Promise((resolve, reject) => {\r\n                this.load(input).then(() => {\r\n                    resolve(this.parse())\r\n                }).catch(reject)\r\n            })\r\n        }\r\n\r\n        // Start parsing element\r\n        return new Promise((resolve, reject) => {\r\n            // If no element is loaded\r\n            if (! this.element) {\r\n                reject(new Error('No element is loaded, call the load method before.'))\r\n            }\r\n\r\n            // Parse the main Element (recursive)\r\n            this.tags = this._parseElement(this.element)\r\n\r\n            if (! this.tags) {\r\n                reject(new Error('No supported tags found.'))\r\n            }\r\n\r\n            // Apply matrix (recursive)\r\n            this.tags.applyMatrix()\r\n\r\n            // Resolve the promise\r\n            resolve(this.tags)\r\n        })\r\n    }\r\n\r\n    // On tag callback\r\n    _onTag(tag) {\r\n        //console.info('onTag:', tag)\r\n    }\r\n\r\n    // Register on tag callback\r\n    onTag(callback, context) {\r\n        this._onTag = tag => callback.call(context || this, tag)\r\n    }\r\n\r\n    // Parse the provided Element and return an Tag collection (recursive)\r\n    _parseElement(element, parent) {\r\n        // Create base tag object\r\n        let tag = new Tag(element, parent)\r\n\r\n        // Exluded tag ?\r\n        if (this.skipTags.indexOf(tag.name) !== -1) {\r\n            return null // silent\r\n        }\r\n\r\n        // Supported tag ?\r\n        if (this.parseTags.indexOf(tag.name) === -1) {\r\n            return this._skipTag(tag, 'unsupported')\r\n        }\r\n\r\n        // Parse the tag\r\n        let tagParser = new TagParser(tag, this)\r\n\r\n        if (! tagParser.parse()) {\r\n            return false\r\n        }\r\n\r\n        // Call the on tag callback\r\n        this._onTag(tag)\r\n\r\n        // Parse child nodes\r\n        let childTag\r\n\r\n        element.childNodes.forEach(childNode => {\r\n            // Parse child element\r\n            if (childTag = this._parseElement(childNode, tag)) {\r\n                tag.addChild(childTag)\r\n            }\r\n        })\r\n\r\n        // Empty group\r\n        if (['svg', 'g'].indexOf(tag.name) !== -1 && ! tag.children.length) {\r\n            return this._skipTag(tag, 'empty')\r\n        }\r\n\r\n        // Return tag object\r\n        return tag\r\n    }\r\n\r\n    // Log skip tag warning message\r\n    _skipTag(tag, message) {\r\n        console.warn('Skip tag :', message + ':', tag)\r\n        return false\r\n    }\r\n\r\n    // Log skip tag attribute warning message\r\n    _skipTagAttr(tag, attr, message) {\r\n        console.warn('Skip tag attribute :', message + ':', attr, tag)\r\n        return false\r\n    }\r\n\r\n}\r\n\r\n// Exports\r\nexport { Parser }\r\nexport default Parser\r\n\n\n\n// WEBPACK FOOTER //\n// ./parser.js","import { Path, Point } from './path'\nimport clipper from 'clipper-lib'\n\nconst DEG_TO_RAD = Math.PI / 180\n\n// SVG tag class\nclass Tag {\n    // Class constructor...\n    constructor(element, parent) {\n        // Init properties\n        this.element  = element\n        this.name     = element.nodeName.toLowerCase()\n        this.parent   = parent || null\n        this.layer    = null\n        this.attrs    = {}\n        this.children = []\n        this.paths    = []\n        this.matrix   = null\n        this.path     = new Path()\n        this.point    = new Point(0, 0)\n        this.shapes   = []\n\n        // Add first path\n        this.paths.push(this.path)\n\n        // Set the matrix\n        this.setMatrix(this.parent && this.parent.matrix)\n\n        // Clone parent attributes\n        if (this.parent && (this.parent.name === 'g' || this.parent.name === 'svg')) {\n            // Inherit layer name\n            this.layer = this.parent.layer\n\n            // Inherit parent attributes\n            let excludes = ['transform', 'width', 'height']\n\n            Object.keys(this.parent.attrs).forEach(key => {\n                if (excludes.indexOf(key) === -1) {\n                    this.setAttr(key, this.parent.attrs[key])\n                }\n            })\n        }\n    }\n\n    setAttr(name, value) {\n        this.attrs[name] = value\n    }\n\n    getAttr(name, defaultValue) {\n        return this.attrs[name] !== undefined ? this.attrs[name]\n            : (defaultValue !== undefined ? defaultValue : null)\n    }\n\n    getLayerName() {\n        if (this.name === 'g') {\n            return this.getAttr('inkscape:label', this.getAttr('id', null))\n        }\n    }\n\n    setLayerName(name) {\n        if (this.name === 'g') {\n            this.layer = name || this.getLayerName()\n        }\n    }\n\n    addChild(childTag) {\n        this.children.push(childTag)\n    }\n\n    clearPath() {\n        this.path = new Path()\n    }\n\n    newPath() {\n        if (this.path.length > 0) {\n            this.clearPath()\n            this.paths.push(this.path)\n        }\n    }\n\n    closePath() {\n        return this.path.close()\n    }\n\n    addPoint(x, y, relative) {\n        // Relative from the last point\n        if (relative) {\n            x += this.point.x\n            y += this.point.y\n        }\n\n        // Add current point\n        this.path.addPoint(x, y)\n\n        // Update current point\n        this.point = this.path.getPoint(-1)\n    }\n\n    addPoints(points, relative) {\n        // For each couple of points\n        for (let i = 0, il = points.length; i < il; i += 2) {\n            this.addPoint(points[i], points[i + 1], relative)\n        }\n    }\n\n    setMatrix(matrix) {\n        this.matrix = matrix || [1, 0, 0, 1, 0, 0]\n    }\n\n    addMatrix(matrix) {\n        this.matrix = [\n            this.matrix[0] * matrix[0] + this.matrix[2] * matrix[1],\n            this.matrix[1] * matrix[0] + this.matrix[3] * matrix[1],\n            this.matrix[0] * matrix[2] + this.matrix[2] * matrix[3],\n            this.matrix[1] * matrix[2] + this.matrix[3] * matrix[3],\n            this.matrix[0] * matrix[4] + this.matrix[2] * matrix[5] + this.matrix[4],\n            this.matrix[1] * matrix[4] + this.matrix[3] * matrix[5] + this.matrix[5]\n        ]\n    }\n\n    translate(x, y) {\n        y = y === undefined ? 0 : y\n        this.addMatrix([1, 0, 0, 1, x, y])\n    }\n\n    rotate(angle, x, y) {\n        angle = angle * DEG_TO_RAD\n\n        if (arguments.length == 2) {\n            this.addMatrix([1, 0, 0, 1, x, y])\n        }\n\n        this.addMatrix([Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0])\n\n        if (arguments.length == 2) {\n            this.addMatrix([1, 0, 0, 1, -x, -y])\n        }\n    }\n\n    scale(x, y) {\n        y = y === undefined ? x : y\n        this.addMatrix([x, 0, 0, y, 0, 0])\n    }\n\n    skewX(angle) {\n        this.addMatrix([1, 0, Math.tan(angle * DEG_TO_RAD), 1, 0, 0])\n    }\n\n    skewY(angle) {\n        this.addMatrix([1, Math.tan(angle * DEG_TO_RAD), 0, 1, 0, 0])\n    }\n\n    applyMatrix(matrix) {\n        matrix && this.addMatrix(matrix)\n\n        this.paths.forEach(path => {\n            path.transform(this.matrix)\n        })\n\n        this.shapes.forEach(shape => {\n            shape.outer.transform(this.matrix)\n            shape.holes.forEach(hole => {\n                hole.transform(this.matrix)\n            })\n        })\n\n        this.setMatrix(null)\n\n        this.children.forEach(tag => {\n            tag.applyMatrix(matrix)\n        })\n    }\n\n    getPaths() {\n        return this.paths\n    }\n\n    getShapes() {\n        // No shapes...\n        if (this.getAttr('fill', 'none') === 'none' || ! this.paths[0].length) {\n            return this.shapes\n        }\n\n        // Get fill rule\n        let fillRule = this.getAttr('fill-rule', 'nonzero')\n            fillRule = fillRule === 'nonzero' ? clipper.PolyFillType.pftNonZero : clipper.PolyFillType.pftEvenOdd\n\n        // Create clipper path\n        let cPolyTree    = new clipper.PolyTree()\n        let cClipper     = new clipper.Clipper()\n        let clipperScale = 10000000\n        let clipperPaths = []\n\n        this.paths.forEach(path => {\n            clipperPaths.push(path.getClipperPoints(clipperScale))\n        })\n\n        cClipper.AddPaths(clipperPaths, clipper.PolyType.ptSubject, true)\n        cClipper.Execute(clipper.ClipType.ctUnion, cPolyTree, fillRule, fillRule)\n\n        let paths     = clipper.Clipper.PolyTreeToPaths(cPolyTree)\n        let polygones = clipper.Clipper.SimplifyPolygons(paths, fillRule)\n\n        // Single path (no hole)\n        if (this.paths.length > 1) {\n            cClipper.Clear()\n            cClipper.StrictlySimple = true\n            cPolyTree = new clipper.PolyTree()\n            cClipper.AddPaths(polygones, clipper.PolyType.ptSubject, true)\n            cClipper.Execute(clipper.ClipType.ctUnion, cPolyTree, fillRule, fillRule)\n        }\n\n        // PolyTree to ExPolygons\n        let toPath     = path => new Path().fromClipperPoints(path, 1 / clipperScale)\n        let exPolygons = clipper.JS.PolyTreeToExPolygons(cPolyTree)\n        this.shapes    = exPolygons.map(exPolygon => {\n            return {\n                outer: toPath(exPolygon.outer),\n                holes: exPolygon.holes.map(toPath)\n            }\n        })\n\n        // Return shapes...\n        return this.shapes\n    }\n}\n\n// Exports\nexport { Tag }\nexport default Tag\n\n\n\n// WEBPACK FOOTER //\n// ./tag.js","import { Arc, CubicBezier, QuadricBezier } from './trace'\nimport { Point, Path } from './path'\n\n// SVG tag parser\nclass TagParser {\n    // Class constructor...\n    constructor(tag, parser) {\n        // Init properties\n        this.tag            = tag\n        this.parser         = parser\n        this.currentCommand = null\n        this.lastCommand    = null\n        this.pathData       = null\n        this.traceSettings  = parser.traceSettings\n    }\n\n    parse() {\n        // Get internal parser from node name\n        let handler = this['_' + this.tag.name]\n\n        // Implemented tag handler?\n        if (! handler || typeof handler !== 'function') {\n            return this.parser._skipTag(this.tag, 'not yet implemented')\n        }\n\n        // Parse tag attributes\n        this._parseTagAttrs()\n\n        // Parse tag\n        return handler.call(this)\n    }\n\n    // Parse the tag attributes\n    _parseTagAttrs() {\n        // Get tag attributes\n        let attrs = this.tag.element.attributes\n\n        if (! attrs) {\n            return null\n        }\n\n        // For each attribute\n        let attr, value, style\n\n        Object.keys(attrs).some(key => {\n            // Current attribute\n            attr = attrs[key]\n\n            // Normalize attribute value\n            value = this._normalizeTagAttr(attr)\n\n            if (value === false) {\n                return false // continue\n            }\n\n            // Special case\n            if (attr.nodeName === 'style') {\n                style = value\n            }\n            else {\n                // Set new attribute name/value\n                this.tag.setAttr(attr.nodeName, value)\n            }\n        })\n\n        // If style attribute (override tag attributes)\n        // TODO get/parse global style and override this one...\n        style && style.replace(/;$/, '').split(';').some(attr => {\n            // Current style\n            attr = attr.split(':')\n            attr = { nodeName: attr[0], nodeValue: attr[1] }\n\n            // Normalize attribute value\n            value = this._normalizeTagAttr(attr)\n\n            if (value === false) {\n                return false // continue\n            }\n\n            // Set new attribute name/value\n            this.tag.setAttr(attr.nodeName, value)\n        })\n\n        // Set inherited color\n        let colorsAttrs = ['fill', 'stroke', 'color']\n\n        colorsAttrs.forEach(attrName => {\n            if (this.tag.getAttr(attrName) === 'inherit') {\n                this.tag.setAttr(attrName, this.tag.parent.getAttr(attrName, 'none'))\n            }\n        })\n\n        // Parse viewBox attribute\n        this._parseViewBoxAttr()\n\n        // Parse transform attribute\n        this._parseTransformAttr()\n    }\n\n    // Normalize tag attribute\n    _normalizeTagAttr(attr) {\n        // Normalize whitespaces\n        let value = attr.nodeValue\n            .replace(/(\\r?\\n|\\r)+/gm, ' ') // Remove all new line chars\n            .replace(/\\s+/gm, ' ')         // Reduce multiple whitespaces\n            .trim()                        // Remove trailing whitespaces\n\n        if (! value.length) {\n            return this.parser._skipTagAttr(this.tag, attr, 'empty')\n        }\n\n        // Filters\n        switch (attr.nodeName) {\n            // Normalize size unit -> to px\n            case 'x':\n            case 'y':\n            case 'x1':\n            case 'y1':\n            case 'x2':\n            case 'y2':\n            case 'r':\n            case 'rx':\n            case 'ry':\n            case 'cx':\n            case 'cy':\n            case 'width':\n            case 'height':\n            case 'fontSize':\n            case 'strokeWidth':\n                value = this._normalizeTagAttrUnit(attr)\n            break\n\n            // Normalize points attribute\n            case 'points':\n            case 'viewBox':\n                value = this._normalizeTagAttrPoints(attr)\n            break\n\n            // Range limit to [0 - 1]\n            case 'opacity':\n            case 'fillOpacity':\n            case 'strokeOpacity':\n                value = this._normalizeTagAttrRange(attr, 0, 1)\n            break\n\n            case 'preserveAspectRatio':\n                value = this._normalizeTagAttrPreserveAspectRatio(attr)\n            break\n        }\n\n        // Return normalized value\n        return value\n    }\n\n    // Normalize attribute unit to px\n    _normalizeTagAttrUnit(attr) {\n        let stringValue = attr.nodeValue.toLowerCase()\n        let floatValue  = parseFloat(stringValue)\n\n        if (isNaN(floatValue)) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric value allowed')\n        }\n\n        if (stringValue.indexOf('mm') !== -1) {\n            return floatValue * 3.5433070869\n        }\n\n        if (stringValue.indexOf('cm') !== -1) {\n            return floatValue * 35.433070869\n        }\n\n        if (stringValue.indexOf('in') !== -1) {\n            return floatValue * 90.0\n        }\n\n        if (stringValue.indexOf('pt') !== -1) {\n            return floatValue * 1.25\n        }\n\n        if (stringValue.indexOf('pc') !== -1) {\n            return floatValue * 15.0\n        }\n\n        return floatValue\n    }\n\n    // Normalize points attribute\n    _normalizeTagAttrPoints(attr) {\n        let points = this._parseNumbers(attr.nodeValue)\n\n        if (points === false) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed')\n        }\n\n        if (! points.length) {\n            return this.parser._skipTagAttr(this.tag, attr, 'empty points list')\n        }\n\n        if (points.length % 0) {\n            return this.parser._skipTagAttr(this.tag, attr, 'the number of points must be even')\n        }\n\n        return points\n    }\n\n    // Normalize range attribute like \"opacity\"\n    _normalizeTagAttrRange(attr, min, max) {\n        let stringValue = attr.nodeValue.trim()\n        let floatValue  = parseFloat(stringValue)\n\n        if (isNaN(floatValue)) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed')\n        }\n\n        if (floatValue < min || floatValue > max) {\n            return this.parser._skipTagAttr(this.tag, attr, 'out of range [' + min + ', ' + max + ']')\n        }\n\n        return floatValue\n    }\n\n    // Parse points string as numbers array\n    _parseNumbers(points) {\n        // http://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly\n        if (typeof points === 'string') {\n            points = points.split(/([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/g)\n            .filter(point => {\n                return point && ['', ','].indexOf(point.trim()) === -1\n            })\n        }\n\n        // Normalize to float values\n        points = points.map(parseFloat)\n\n        // Test if all numbers is valid\n        if (points.some(isNaN)) {\n            return false\n        }\n\n        return points\n    }\n\n    // Normalize the preserveAspectRatio attribute\n    _normalizeTagAttrPreserveAspectRatio(attr) {\n        let params = {\n            defer: false,\n            align: 'none',\n            meet : true,\n            slice: false\n        }\n\n        let rawParams = attr.nodeValue\n\n        if (rawParams.indexOf('defer') === 0) {\n            rawParams    = rawParams.substr(6)\n            params.defer = true\n        }\n\n        rawParams    = rawParams.split(' ')\n        params.align = rawParams[0]\n        params.meet  = rawParams[1] || 'meet'\n        params.meet  = params.meet === 'meet'\n        params.slice = ! params.meet\n\n        return params\n    }\n\n    // Parse viewBox attribute and set transformations\n    _parseViewBoxAttr() {\n        // Get viewBox attribute\n        let viewBox = this.tag.getAttr('viewBox', null)\n\n        // No viewBox...\n        if (viewBox === null) {\n            return null\n        }\n\n        // Update size attributes\n        let width  = this.tag.getAttr('width', viewBox[2])\n        let height = this.tag.getAttr('height', viewBox[3])\n\n        this.tag.setAttr('width' , width)\n        this.tag.setAttr('height', height)\n\n        // Scale to match viewBox\n        // TODO clip path if preserveAspectRatio.slice\n        let scaleX     = width  / viewBox[2]\n        let scaleY     = height / viewBox[3]\n        let translateX = viewBox[0]\n        let translateY = viewBox[1]\n\n        let preserveAspectRatio = this.tag.getAttr('preserveAspectRatio', 'meet xMidYMid')\n\n        if (preserveAspectRatio) {\n            let newWidth, newHeight\n\n            if (preserveAspectRatio.meet) {\n                if (scaleX > scaleY) {\n                    scaleX   = scaleY\n                    newWidth = viewBox[2] * scaleX\n                }\n                else if (scaleX < scaleY) {\n                    scaleY    = scaleX\n                    newHeight = viewBox[3] * scaleY\n                }\n            }\n            else if (preserveAspectRatio.slice) {\n                if (scaleX < scaleY) {\n                    scaleX   = scaleY\n                    newWidth = viewBox[2] * scaleX\n                }\n                else if (scaleX > scaleY) {\n                    scaleY    = scaleX\n                    newHeight = viewBox[3] * scaleY\n                }\n            }\n\n            if (newWidth !== undefined) {\n                if (preserveAspectRatio.align === 'xMidYMid') {\n                    this.tag.translate((width - newWidth) / 2, 0)\n                }\n                else if (preserveAspectRatio.align === 'xMaxYMax') {\n                    this.tag.translate(width - newWidth, 0)\n                }\n            }\n            else if (newHeight !== undefined) {\n                if (preserveAspectRatio.align === 'xMidYMid') {\n                    this.tag.translate(0, (height - newHeight) / 2)\n                }\n                else if (preserveAspectRatio.align === 'xMaxYMax') {\n                    this.tag.translate(0, height - newHeight)\n                }\n            }\n        }\n\n        this.tag.scale(scaleX, scaleY)\n        this.tag.translate(-translateX, -translateY)\n    }\n\n    // Parse transform attribute and set transformations\n    _parseTransformAttr() {\n        // Get transform attribute\n        let transformAttr = this.tag.getAttr('transform', null)\n\n        // No transformation...\n        if (transformAttr === null || ! transformAttr.length) {\n            return null\n        }\n\n        // Parse attribute (split group on closing parenthesis)\n        let transformations = transformAttr.split(')')\n\n        // Remove last entry due to last \")\" found\n        transformations.pop()\n\n        // For each transformation\n        let transform, type, params\n\n        transformations.some(raw => {\n            // Split name and value on opening parenthesis\n            transform = raw.split('(')\n\n            // Invalid parts number\n            if (transform.length !== 2) {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'malformed') // continue\n            }\n\n            type = transform[0].trim()\n\n            // Quik hack 1/2\n            let func = type\n            if (func === 'matrix') {\n                func = 'addMatrix'\n            }\n\n            // Get tag transform method\n            let tagTransform = this.tag[func]\n\n            if (typeof tagTransform !== 'function') {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'unsupported transform type :' + type)\n            }\n\n            params = transform[1].trim()\n            params = this._parseNumbers(params)\n\n            // Skip empty value\n            if (! params.length) {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'malformed transform type :' + type)\n            }\n\n            // Quik hack 2/2\n            if (func == 'addMatrix') {\n                params = [params]\n            }\n\n            // Call tag transform method like \"tag.translate(param1, ..., paramN)\"\n            tagTransform.apply(this.tag, params)\n        })\n    }\n\n    _newPath() {\n        this.tag.newPath()\n    }\n\n    _clearPath() {\n        this.tag.clearPath()\n    }\n\n    _closePath() {\n        return this.tag.closePath()\n    }\n\n    _addPoints(points, relative) {\n        if (! points.length) {\n            return this.parser._skipTag(this.tag, 'empty points list')\n        }\n\n        if (points.length % 0) {\n            return this.parser._skipTag(this.tag, 'the number of points must be even')\n        }\n\n        relative = arguments.length < 2 && this.currentCommand.relative\n\n        this.tag.addPoints(points, relative)\n        return true\n    }\n\n    // SVG specs at https://www.w3.org/TR/SVG11/\n\n    _svg() {\n        // Only parse the root SVG tag as main document\n        if (this.parser.document) {\n            // Handled tag\n            return true\n        }\n\n        // Get the document size\n        let width  = this.tag.getAttr('width')\n        let height = this.tag.getAttr('height')\n\n        // Invalid size\n        if (! width || width < 0 || ! height || height < 0) {\n            throw new Error('Invalid document size: ' + width + ' / ' + height)\n        }\n\n        // Set document size\n        this.parser.document = {\n            width : width,\n            height: height\n        }\n\n        // Get document viewBox or set default to document size\n        let viewBox = this.tag.getAttr('viewBox', [0, 0, width, height])\n\n        this.parser.document.viewBox = {\n            x     : viewBox[0],\n            y     : viewBox[1],\n            width : viewBox[2],\n            height: viewBox[3]\n        }\n\n        // Check inkscape version\n        if (this.parser.editor.name === 'inkscape') {\n            this.parser.editor.version = this.tag.getAttr('inkscape:version')\n        }\n\n        // Handled tag\n        return true\n    }\n\n    _title() {\n        // Register the first encountered title tag as document title\n        if (this.parser.document && ! this.parser.document.title) {\n            this.parser.document.title = this.tag.element.textContent\n        }\n\n        // Skipped tag\n        return false\n    }\n\n    _desc() {\n        // Register the first encountered desc tag as document description\n        if (this.parser.document && ! this.parser.document.description) {\n            this.parser.document.description = this.tag.element.textContent\n        }\n\n        // Skipped tag\n        return false\n    }\n\n    _defs() {\n        // Register all child element with an id attribute\n        this.tag.element.childNodes.forEach(childNode => {\n            childNode.id && (this.parser.defs[childNode.id] = childNode)\n        })\n\n        // Skipped tag\n        return false\n    }\n\n    _use() {\n        // Get the target id\n        let target  = this.tag.getAttr('xlink:href').replace(/^#/, '')\n\n        // Try to get the defined element\n        let element = this.parser.defs[target]\n\n        if (! element) {\n            return this.parser._skipTag(this.tag, 'undefined reference [' + target + ']')\n        }\n\n        // Parse the defined element and set new parent from <use> tag parent\n        let useTag = this.parser._parseElement(element, this.tag.parent)\n\n        if (! useTag) {\n            return this.parser._skipTag(this.tag, 'empty reference [' + target + ']')\n        }\n\n        // Set matrix from real parent (<use>)\n        useTag.setMatrix(this.tag.matrix)\n\n        // Replace the use tag with new one\n        this.tag.parent.addChild(useTag)\n\n        // Skipped tag\n        return false\n    }\n\n    _g() {\n        // Set the tag layer name\n        this.tag.setLayerName()\n\n        // Handled tag\n        return true\n    }\n\n    _line() {\n        // Handled tag\n        return this._path([\n            'M', this.tag.getAttr('x1'), this.tag.getAttr('y1'),\n            'L', this.tag.getAttr('x2'), this.tag.getAttr('y2')\n        ])\n    }\n\n    _polyline(close=false) {\n        let points = this.tag.getAttr('points')\n        let path   = ['M', points.shift(), points.shift(), 'L']\n\n        path = path.concat(points)\n        close && path.push('Z')\n\n        // Handled tag\n        return this._path(path)\n    }\n\n    _polygon() {\n        // Handled like polyline but closed\n        return this._polyline(true)\n    }\n\n    _rect() {\n        // Get rectangle attributes\n        let w  = this.tag.getAttr('width')\n        let h  = this.tag.getAttr('height')\n        let x  = this.tag.getAttr('x', 0)\n        let y  = this.tag.getAttr('y', 0)\n        let rx = this.tag.getAttr('rx', null)\n        let ry = this.tag.getAttr('ry', null)\n\n        // Simple rect\n        if (!rx && !ry) {\n            // Handled tag\n            return this._path(['M', x, y, 'h', w, 'v', h, 'h', -w, 'z'])\n        }\n\n        // If a properly specified value is provided for ‘rx’, but not for ‘ry’,\n        // then set both rx and ry to the value of ‘rx’ and vis-vera...\n        if (rx === null) rx = ry\n        if (ry === null) ry = rx\n\n        // A negative value is an error\n        if (rx === null || rx === null || rx < 0 || ry < 0) {\n            // Skip tag\n            return this.parser._skipTag(this.tag, 'negative value for \"rx/ry\" not allowed')\n        }\n\n        // If rx is greater than half of ‘width’, then set rx to half of ‘width’.\n        // If ry is greater than half of ‘height’, then set ry to half of ‘height’.\n        if (rx > w / 2) rx = w / 2\n        if (ry > h / 2) ry = h / 2\n\n        let dx = rx * 2\n        let dy = ry * 2\n\n        // Handled tag\n        return this._path([\n            'M', x + rx, y,\n            'h', w - dx,\n            'c', rx, 0, rx, ry, rx, ry,\n            'v', h - dy,\n            'c', 0, ry, -rx, ry, -rx, ry,\n            'h', -w + dx,\n            'c', -rx, 0, -rx, -ry, -rx, -ry,\n            'v', -h + dy,\n            'c', 0, 0, 0, -ry, rx, -ry,\n            'z'\n        ])\n    }\n\n    _circle() {\n        let r = this.tag.getAttr('r', 0)\n\n        if (r <= 0) {\n            // Skipped tag\n            return false\n        }\n\n        let cx = this.tag.getAttr('cx', 0)\n        let cy = this.tag.getAttr('cy', 0)\n\n        // Handled tag\n        return this._path([\n            'M', cx-r, cy,\n            'A', r, r, 0, 0, 0, cx, cy+r,\n            'A', r, r, 0, 0, 0, cx+r, cy,\n            'A', r, r, 0, 0, 0, cx, cy-r,\n            'A', r, r, 0, 0, 0, cx-r, cy,\n            'Z'\n        ])\n    }\n\n    _ellipse() {\n        let rx = this.tag.getAttr('rx', 0)\n        let ry = this.tag.getAttr('ry', 0)\n\n        if (rx <= 0 || ry <= 0) {\n            // Skipped tag\n            return false\n        }\n\n        let cx = this.tag.getAttr('cx', 0)\n        let cy = this.tag.getAttr('cy', 0)\n\n        // Handled tag\n        return this._path([\n            'M', cx-rx, cy,\n            'A', rx, ry, 0, 0, 0, cx, cy+ry,\n            'A', rx, ry, 0, 0, 0, cx+rx, cy,\n            'A', rx, ry, 0, 0, 0, cx, cy-ry,\n            'A', rx, ry, 0, 0, 0, cx-rx, cy,\n            'Z'\n        ])\n    }\n\n    _paths(type, num, points) {\n        if (points.length > num) {\n            let handler, result = true\n\n            while(result && points.length) {\n                handler = this['_path' + type]\n                result  = handler.call(this, points.splice(0, num))\n            }\n\n            return result\n        }\n\n        return null\n    }\n\n    _path(path) {\n        // Provided path\n        if (path && typeof path !== 'string') {\n            path = path.join(' ')\n        }\n\n        // Get the paths data attribute value\n        let dAttr = path || this.tag.getAttr('d', null)\n\n        if (! dAttr) {\n            // Skipped tag\n            return false\n        }\n\n        // Split on each commands\n        let commands = dAttr.match(/([M|Z|L|H|V|C|S|Q|T|A]+([^M|Z|L|H|V|C|S|Q|T|A]+)?)/gi)\n\n        if (! commands) {\n            return this.parser._skipTag(this.tag, 'malformed \"d\" attribute')\n        }\n\n        // For each command...\n        this.currentCommand = {\n            raw     : null,\n            type    : null,\n            params  : null,\n            relative: null\n        }\n        this.lastCommand = this.currentCommand\n        this.pathData    = {}\n\n        let handler    = null\n        let parseError = false\n\n        commands.some(raw => {\n            // Remove trailing whitespaces\n            raw = raw.trim()\n\n            // Extract command char and params\n            this.currentCommand.raw      = raw\n            this.currentCommand.type     = raw[0].toUpperCase()\n            this.currentCommand.params   = raw.substr(1).trim()\n            this.currentCommand.relative = this.currentCommand.type !== raw[0]\n\n            // Get path handler from command char\n            handler = this['_path' + this.currentCommand.type]\n\n            if (! handler || typeof handler !== 'function') {\n                this.parser._skipTag(this.tag, 'unsupported path command [' + raw[0] + ']')\n                return parseError = true // break\n            }\n\n            // Extract all numbers from arguments string\n            this.currentCommand.params = this._parseNumbers(this.currentCommand.params)\n\n            if (this.currentCommand.params === false) {\n                this.parser._skipTag(this.tag, 'only numeric values are allowed in [' + this.currentCommand.raw + ']')\n                return parseError = true // break\n            }\n\n            // Execute command parser\n            if (! handler.call(this, this.currentCommand.params)) {\n                return parseError = true // break\n            }\n\n            // Update last command\n            this.lastCommand = {}\n\n            Object.keys(this.currentCommand).forEach(key => {\n                this.lastCommand[key] = this.currentCommand[key]\n            })\n        })\n\n        // Skip tag\n        if (parseError) {\n            this._clearPath()\n            return false\n        }\n\n        // Handled tag\n        return true\n    }\n\n    _pathM(points) {\n        // New path\n        this._newPath()\n\n        // Set the current point (start of new path)\n        // If is followed by multiple pairs of coordinates,\n        // the subsequent pairs are treated as implicit lineto commands.\n        return this._addPoints(points)\n    }\n\n    _pathZ() {\n        this._closePath()\n        return true\n    }\n\n    _pathL(points) {\n        return this._addPoints(points)\n    }\n\n    _pathH(points) {\n        return points.every(x => {\n            return this._addPoints([x, this.currentCommand.relative ? 0 : this.tag.point.y])\n        })\n    }\n\n    _pathV(points) {\n        return points.every(y => {\n            return this._addPoints([this.currentCommand.relative ? 0 : this.tag.point.x, y])\n        })\n    }\n\n    _pathC(points) {\n        // Multiple paths\n        let result = this._paths('C', 6, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = points[0] + (rl ? p1.x : 0)\n        let y1 = points[1] + (rl ? p1.y : 0)\n        let x2 = points[2] + (rl ? p1.x : 0)\n        let y2 = points[3] + (rl ? p1.y : 0)\n        let x  = points[4] + (rl ? p1.x : 0)\n        let y  = points[5] + (rl ? p1.y : 0)\n\n        this.pathData.x2 = x2\n        this.pathData.y2 = y2\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x2, y2)\n        let p4 = new Point(x, y)\n\n        //console.log('C', p1, p2, p3, p4)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : control point\n        // p4  : end point\n        let tracer = new CubicBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3, p4 }) // => [x,y, x,y, ...]\n        // let tracer = trace(CubicBezier, this.traceSettings)\n        // let coords = tracer({ p1, p2, p3, p4 })\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathS(points) {\n        // Multiple paths\n        let result = this._paths('S', 4, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = p1.x\n        let y1 = p1.y\n\n        if (this.lastCommand.type === 'S' || this.lastCommand.type === 'C') {\n            x1 -= this.pathData.x2 - x1\n            y1 -= this.pathData.y2 - y1\n        }\n\n        let x2 = points[0] + (rl ? p1.x : 0)\n        let y2 = points[1] + (rl ? p1.y : 0)\n        let x  = points[2] + (rl ? p1.x : 0)\n        let y  = points[3] + (rl ? p1.y : 0)\n\n        this.pathData.x2 = x2\n        this.pathData.y2 = y2\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x2, y2)\n        let p4 = new Point(x, y)\n\n        //console.log('S', p1, p2, p3, p4)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : control point\n        // p4  : end point\n        let tracer = new CubicBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3, p4 }) // => [x,y, x,y, ...]\n        // let tracer = trace(CubicBezier, this.traceSettings)\n        // let coords = tracer({ p1, p2, p3, p4 })\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathQ(points) {\n        // Multiple paths\n        let result = this._paths('Q', 4, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = points[0] + (rl ? p1.x : 0)\n        let y1 = points[1] + (rl ? p1.y : 0)\n        let x  = points[2] + (rl ? p1.x : 0)\n        let y  = points[3] + (rl ? p1.y : 0)\n\n        this.pathData.x1 = x1\n        this.pathData.y1 = y1\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x, y)\n\n        //console.log('Q', p1, p2, p3)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : end point\n        let tracer = new QuadricBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathT(points) {\n        // Multiple paths\n        let result = this._paths('T', 2, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = p1.x\n        let y1 = p1.y\n\n        if (this.lastCommand.type === 'Q' || this.lastCommand.type === 'T') {\n            x1 -= this.pathData.x1 - x1\n            y1 -= this.pathData.y1 - y1\n        }\n\n        let x = points[0] + (rl ? p1.x : 0)\n        let y = points[1] + (rl ? p1.y : 0)\n\n        this.pathData.x1 = x1\n        this.pathData.y1 = y1\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x, y)\n\n        //console.log('T', p1, p2, p3)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : end point\n        let tracer = new QuadricBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathA(points) {\n        // Multiple paths\n        let result = this._paths('A', 7, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let rl    = this.currentCommand.relative\n        let p1    = this.tag.point\n        let rx    = points[0]\n        let ry    = points[1]\n        let angle = points[2]\n        let large = !!points[3]\n        let sweep = !!points[4]\n        let x     = points[5] + (rl ? p1.x : 0)\n        let y     = points[6] + (rl ? p1.y : 0)\n        let p2    = new Point(x, y)\n\n        //console.log('A', p1, rx, ry, angle, large, sweep, p2)\n\n        let tracer = new Arc(this.traceSettings)\n        let coords = tracer.trace({ p1, rx, ry, angle, large, sweep, p2 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n}\n\n// Exports\nexport { TagParser }\nexport default TagParser\n\n\n\n// WEBPACK FOOTER //\n// ./tagparser.js","// Base code from : https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js\nimport { Point } from './path'\n\nconst MATH_PI_2  = Math.PI * 2\nconst DEG_TO_RAD = Math.PI / 180\n\nfunction mod(x, m) {\n    return (x % m + m) % m\n}\n\nfunction clamp(val, min, max) {\n    return Math.min(Math.max(val, min), max)\n}\n\nfunction distance(p0, p1) {\n    return Math.sqrt(Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2))\n}\n\nfunction angle(v0, v1) {\n    let p = v0.x * v1.x + v0.y * v1.y\n    let n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)))\n    return (v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1) * Math.acos(p / n)\n}\n\n// Abstract class\nclass TraceBase {\n    constructor(settings) {\n        // Set defaults properties\n        this.path          = []   // Points collection [x,y, x,y, ...]\n        this.linear        = true // Linear trace mode\n        this.step          = 0.01 // Step resolution if linear mode = false\n        this.resolution    = 500  // Number of segments we use to approximate arc length\n        this.segmentLength = 0.1  // Segment length\n\n        // Update properties from user settings\n        Object.assign(this, settings || {})\n\n        // Arc length properties\n        this.arcLength    = null\n        this.arcLengthMap = null\n    }\n\n    _clearPath() {\n        this.path = []\n    }\n\n    getPath() {\n        return this.path\n    }\n\n    getPointAtT(t) {\n        return new Point(0, 0)\n    }\n\n    _addPoint(point) {\n        this.path.push(point.x, point.y)\n    }\n\n    _postTrace() {\n        // Do additional tasks\n    }\n\n    _approximateLength() {\n        let arcLength    = 0\n        let arcLengthMap = []\n        let prevPoint    = this.getPointAtT(0)\n\n        let i, t, nextPoint\n\n        for(i = 0; i < this.resolution; i++) {\n            t          = clamp(i * (1 / this.resolution), 0, 1)\n            nextPoint  = this.getPointAtT(t)\n            arcLength += distance(prevPoint, nextPoint)\n\n            arcLengthMap.push({ t: t, arcLength: arcLength })\n\n            prevPoint = nextPoint\n        }\n\n        // Last stretch to the endpoint\n        nextPoint  = this.getPointAtT(1)\n        arcLength += distance(prevPoint, nextPoint)\n\n        arcLengthMap.push({ t: 1, arcLength: arcLength })\n        Object.assign(this, { arcLength, arcLengthMap })\n    }\n\n    getPointAtU(u) {\n        u = clamp(u, 0, 1)\n\n        let targetDistanceFromStartingPoint = u * this.arcLength\n\n        let resultantT    = 0\n        let prevArcLength = 0\n        let prevT         = 0\n\n        this.arcLengthMap.every(entry => {\n            let t         = entry.t\n            let arcLength = entry.arcLength\n\n            // Once we go a past our target\n            // Lets interpolate from a previous to current\n            if (arcLength >= targetDistanceFromStartingPoint) {\n                let endDiff      = arcLength - targetDistanceFromStartingPoint\n                let startDiff    = targetDistanceFromStartingPoint - prevArcLength\n                let linearFactor = (startDiff / (endDiff + startDiff)) || 0\n\n                resultantT = prevT + (t - prevT) * linearFactor\n\n                // Break\n                return false\n            }\n\n            prevArcLength = arcLength\n            prevT = t\n\n            return true\n        })\n\n        return this.getPointAtT(resultantT)\n    }\n\n    trace(settings) {\n        // Update properties from user settings\n        Object.assign(this, settings || {})\n\n        // Default getPoint settings\n        let getPoint = 'getPointAtT'\n        let step     = this.step\n\n        // Linear mode ?\n        if (this.linear) {\n            this._approximateLength()\n\n            let segments = Math.round(this.arcLength / this.segmentLength)\n\n            getPoint = 'getPointAtU'\n            step     = 1 / segments\n        }\n\n        // Clear points list\n        this._clearPath()\n\n        // Trace the path\n        for (let t = 0; t <= 1; t += step) {\n            this._addPoint(this[getPoint](t))\n        }\n\n        // Do additional tasks\n        this._postTrace()\n\n        // Return the path\n        return this.getPath()\n    }\n}\n\n// Rewrite from https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js#L84\nclass Arc extends TraceBase {\n    init(settings) {\n        // Update properties from user settings\n        Object.assign(this, settings || {})\n\n        // Get angle in radians\n        this.radians = mod(this.angle, 360) * DEG_TO_RAD\n\n        // If the endpoints are identical, then this is equivalent\n        // to omitting the elliptical arc segment entirely.\n        if(this.p1.x === this.p2.x && this.p1.y === this.p2.y) {\n            return this.path\n        }\n\n        this.rx = Math.abs(this.rx)\n        this.ry = Math.abs(this.ry)\n\n        // If rx = 0 or ry = 0 then this arc is treated as\n        // a straight line segment joining the endpoints.\n        if (this.rx === 0 || this.ry === 0) {\n            this.__addPoint(this.p1)\n            this.__addPoint(this.p2)\n            return this.path\n        }\n\n        // Following \"Conversion from endpoint to center parameterization\"\n        // http://www.w3.org/TR/SVG/implnote.html#ArcConversionEndpointToCenter\n\n        // Step #1: Compute transformedPoint\n        let dx = (this.p1.x - this.p2.x) / 2\n        let dy = (this.p1.y - this.p2.y) / 2\n\n        let transformedPoint = {\n            x:  Math.cos(this.radians) * dx + Math.sin(this.radians) * dy,\n            y: -Math.sin(this.radians) * dx + Math.cos(this.radians) * dy\n        }\n\n        // Ensure radii are large enough\n        let radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(this.rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(this.ry, 2)\n\n        if (radiiCheck > 1) {\n            this.rx = Math.sqrt(radiiCheck) * this.rx\n            this.ry = Math.sqrt(radiiCheck) * this.ry\n        }\n\n        // Step #2: Compute transformedCenter\n        let cSquareNumerator = Math.pow(this.rx, 2) * Math.pow(this.ry, 2) - Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2)\n        let cSquareRootDenom = Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2)\n        let cRadicand        = cSquareNumerator / cSquareRootDenom\n\n        // Make sure this never drops below zero because of precision\n        cRadicand = cRadicand < 0 ? 0 : cRadicand\n        let cCoef = (this.large !== this.sweep ? 1 : -1) * Math.sqrt(cRadicand)\n        let transformedCenter = {\n            x: cCoef * ( (this.rx * transformedPoint.y) / this.ry),\n            y: cCoef * (-(this.ry * transformedPoint.x) / this.rx)\n        }\n\n        // Step #3: Compute center\n        this.center = {\n            x: Math.cos(this.radians) * transformedCenter.x - Math.sin(this.radians) * transformedCenter.y + ((this.p1.x + this.p2.x) / 2),\n            y: Math.sin(this.radians) * transformedCenter.x + Math.cos(this.radians) * transformedCenter.y + ((this.p1.y + this.p2.y) / 2)\n        }\n\n        // Step #4: Compute start/sweep angles\n        // Start angle of the elliptical arc prior to the stretch and rotate operations.\n        // Difference between the start and end angles\n        let startVector = {\n            x: (transformedPoint.x - transformedCenter.x) / this.rx,\n            y: (transformedPoint.y - transformedCenter.y) / this.ry\n        }\n\n        let endVector = {\n            x: (-transformedPoint.x - transformedCenter.x) / this.rx,\n            y: (-transformedPoint.y - transformedCenter.y) / this.ry\n        }\n\n        this.startAngle = angle({ x: 1, y: 0 }, startVector)\n        this.sweepAngle = angle(startVector, endVector)\n\n        if (! this.sweep && this.sweepAngle > 0) {\n            this.sweepAngle -= MATH_PI_2\n        }\n\n        else if (this.sweep && this.sweepAngle < 0) {\n            this.sweepAngle += MATH_PI_2\n        }\n\n        // We use % instead of `mod(..)` because we want it to be -360deg to 360deg(but actually in radians)\n        this.sweepAngle %= MATH_PI_2\n    }\n\n    trace(settings) {\n        this.init(settings)\n        return super.trace()\n    }\n\n    getPointAtT(t) {\n        let angle = this.startAngle + (this.sweepAngle * t)\n\n        let x = this.rx * Math.cos(angle)\n        let y = this.ry * Math.sin(angle)\n\n        return new Point(\n            Math.cos(this.radians) * x - Math.sin(this.radians) * y + this.center.x,\n            Math.sin(this.radians) * x + Math.cos(this.radians) * y + this.center.y\n        )\n    }\n\n    _postTrace() {\n        // Add last point in the path\n        this._addPoint(this.p2)\n    }\n}\n\nclass CubicBezier extends TraceBase {\n    _B1(t) { return t*t*t }\n    _B2(t) { return 3*t*t*(1-t) }\n    _B3(t) { return 3*t*(1-t)*(1-t) }\n    _B4(t) { return (1-t)*(1-t)*(1-t) }\n\n    _C1(p1, p2, p3, p4, t) {\n        return p1*this._B1(t) + p2*this._B2(t) + p3*this._B3(t) + p4*this._B4(t)\n    }\n\n    getPointAtT(t) {\n        return new Point(\n            this._C1(this.p1.x, this.p2.x, this.p3.x, this.p4.x, t),\n            this._C1(this.p1.y, this.p2.y, this.p3.y, this.p4.y, t)\n        )\n    }\n\n    _addPoint(point) {\n        this.path.unshift(point.x, point.y)\n    }\n}\n\nclass QuadricBezier extends TraceBase {\n    _B1(t) { return t*t }\n    _B2(t) { return 2*t*(1-t) }\n    _B3(t) { return (1-t)*(1-t) }\n\n    _C1(p1, p2, p3, t) {\n        return p1*this._B1(t) + p2*this._B2(t) + p3*this._B3(t)\n    }\n\n    getPointAtT(t) {\n        return new Point(\n            this._C1(this.p1.x, this.p2.x, this.p3.x, t),\n            this._C1(this.p1.y, this.p2.y, this.p3.y, t)\n        )\n    }\n\n    _addPoint(point) {\n        this.path.unshift(point.x, point.y)\n    }\n}\n\n// Exports\nexport { Arc, CubicBezier, QuadricBezier }\n\n\n\n// WEBPACK FOOTER //\n// ./trace.js","// rev 482\n/********************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.2.1                                                          *\n * Date      :  31 October 2014                                                 *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2014                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.2.1.0                                                         *\n * Date      :  17 June 2016                                                 *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n * Because Javascript lacks support for 64-bit integers, the space              *\n * is a little more restricted than in C# version.                              *\n *                                                                              *\n * C# version has support for coordinate space:                                 *\n * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n * while Javascript version has support for space:                              *\n * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n *                                                                              *\n * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n * http://jsperf.com/big-integer-library-test                                   *\n *                                                                              *\n * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Basic JavaScript BN library - subset useful for RSA encryption.              *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n * Copyright (c) 2005  Tom Wu                                                   *\n * All Rights Reserved.                                                         *\n * See \"LICENSE\" for details:                                                   *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n *                                                                              *\n *******************************************************************************/\n(function ()\n{\n  \"use strict\";\n  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n  //improve performance but coordinate values are limited to the range +/- 46340\n  var use_int32 = false;\n  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n  var use_xyz = false;\n  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n  var use_lines = true;\n\n  var ClipperLib = {};\n  var isNode = false;\n  if (typeof module !== 'undefined' && module.exports)\n  {\n    module.exports = ClipperLib;\n    isNode = true;\n  }\n  else\n  {\n    if (typeof define === 'function' && define.amd) {\n      define(ClipperLib);\n    }\n    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n    else self['ClipperLib'] = ClipperLib;\n  }\n  var navigator_appName;\n  if (!isNode)\n  {\n    var nav = navigator.userAgent.toString().toLowerCase();\n    navigator_appName = navigator.appName;\n  }\n  else\n  {\n    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n  }\n  // Browser test to speedup performance critical functions\n  var browser = {};\n  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n  else browser.chrome = 0;\n  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n  else browser.chromium = 0;\n  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n  else browser.safari = 0;\n  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n  else browser.firefox = 0;\n  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n  else browser.firefox17 = 0;\n  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n  else browser.firefox15 = 0;\n  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n  else browser.firefox3 = 0;\n  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n  else browser.opera = 0;\n  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n  else browser.msie10 = 0;\n  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n  else browser.msie9 = 0;\n  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n  else browser.msie8 = 0;\n  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n  else browser.msie7 = 0;\n  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n  else browser.msie = 0;\n  ClipperLib.biginteger_used = null;\n\n  // Copyright (c) 2005  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Basic JavaScript BN library - subset useful for RSA encryption.\n  // Bits per digit\n  var dbits;\n  // JavaScript engine analysis\n  var canary = 0xdeadbeefcafe;\n  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n  // (public) Constructor\n  function BigInteger(a, b, c)\n  {\n    // This test variable can be removed,\n    // but at least for performance tests it is useful piece of knowledge\n    // This is the only ClipperLib related variable in BigInteger library\n    ClipperLib.biginteger_used = 1;\n    if (a != null)\n      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n    else this.fromString(a, b);\n  }\n  // return new, unset BigInteger\n  function nbi()\n  {\n    return new BigInteger(null,undefined,undefined);\n  }\n  // am: Compute w_j += (x*this_i), propagate carries,\n  // c is initial carry, returns final carry.\n  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n  // We need to select the fastest one that works in this environment.\n  // am1: use a single mult and divide to get the high bits,\n  // max digit bits should be 26 because\n  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n  function am1(i, x, w, j, c, n)\n  {\n    while (--n >= 0)\n    {\n      var v = x * this[i++] + w[j] + c;\n      c = Math.floor(v / 0x4000000);\n      w[j++] = v & 0x3ffffff;\n    }\n    return c;\n  }\n  // am2 avoids a big mult-and-extract completely.\n  // Max digit bits should be <= 30 because we do bitwise ops\n  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n  function am2(i, x, w, j, c, n)\n  {\n    var xl = x & 0x7fff,\n      xh = x >> 15;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x7fff;\n      var h = this[i++] >> 15;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n      w[j++] = l & 0x3fffffff;\n    }\n    return c;\n  }\n  // Alternately, set max digit bits to 28 since some\n  // browsers slow down when dealing with 32-bit numbers.\n  function am3(i, x, w, j, c, n)\n  {\n    var xl = x & 0x3fff,\n      xh = x >> 14;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x3fff;\n      var h = this[i++] >> 14;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n      c = (l >> 28) + (m >> 14) + xh * h;\n      w[j++] = l & 0xfffffff;\n    }\n    return c;\n  }\n  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n  {\n    BigInteger.prototype.am = am2;\n    dbits = 30;\n  }\n  else if (j_lm && (navigator_appName != \"Netscape\"))\n  {\n    BigInteger.prototype.am = am1;\n    dbits = 26;\n  }\n  else\n  { // Mozilla/Netscape seems to prefer am3\n    BigInteger.prototype.am = am3;\n    dbits = 28;\n  }\n  BigInteger.prototype.DB = dbits;\n  BigInteger.prototype.DM = ((1 << dbits) - 1);\n  BigInteger.prototype.DV = (1 << dbits);\n  var BI_FP = 52;\n  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n  BigInteger.prototype.F1 = BI_FP - dbits;\n  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n  // Digit conversions\n  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n  var BI_RC = new Array();\n  var rr, vv;\n  rr = \"0\".charCodeAt(0);\n  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n  rr = \"a\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n  rr = \"A\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n  function int2char(n)\n  {\n    return BI_RM.charAt(n);\n  }\n\n  function intAt(s, i)\n  {\n    var c = BI_RC[s.charCodeAt(i)];\n    return (c == null) ? -1 : c;\n  }\n  // (protected) copy this to r\n  function bnpCopyTo(r)\n  {\n    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n    r.t = this.t;\n    r.s = this.s;\n  }\n  // (protected) set from integer value x, -DV <= x < DV\n  function bnpFromInt(x)\n  {\n    this.t = 1;\n    this.s = (x < 0) ? -1 : 0;\n    if (x > 0) this[0] = x;\n    else if (x < -1) this[0] = x + this.DV;\n    else this.t = 0;\n  }\n  // return bigint initialized to value\n  function nbv(i)\n  {\n    var r = nbi();\n    r.fromInt(i);\n    return r;\n  }\n  // (protected) set from string and radix\n  function bnpFromString(s, b)\n  {\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 256) k = 8; // byte array\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else\n    {\n      this.fromRadix(s, b);\n      return;\n    }\n    this.t = 0;\n    this.s = 0;\n    var i = s.length,\n      mi = false,\n      sh = 0;\n    while (--i >= 0)\n    {\n      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\") mi = true;\n        continue;\n      }\n      mi = false;\n      if (sh == 0)\n        this[this.t++] = x;\n      else if (sh + k > this.DB)\n      {\n        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n        this[this.t++] = (x >> (this.DB - sh));\n      }\n      else\n        this[this.t - 1] |= x << sh;\n      sh += k;\n      if (sh >= this.DB) sh -= this.DB;\n    }\n    if (k == 8 && (s[0] & 0x80) != 0)\n    {\n      this.s = -1;\n      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n    }\n    this.clamp();\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) clamp off excess high words\n  function bnpClamp()\n  {\n    var c = this.s & this.DM;\n    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n  }\n  // (public) return string representation in given radix\n  function bnToString(b)\n  {\n    if (this.s < 0) return \"-\" + this.negate().toString(b);\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else return this.toRadix(b);\n    var km = (1 << k) - 1,\n      d, m = false,\n      r = \"\",\n      i = this.t;\n    var p = this.DB - (i * this.DB) % k;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) > 0)\n      {\n        m = true;\n        r = int2char(d);\n      }\n      while (i >= 0)\n      {\n        if (p < k)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (k - p);\n          d |= this[--i] >> (p += this.DB - k);\n        }\n        else\n        {\n          d = (this[i] >> (p -= k)) & km;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if (d > 0) m = true;\n        if (m) r += int2char(d);\n      }\n    }\n    return m ? r : \"0\";\n  }\n  // (public) -this\n  function bnNegate()\n  {\n    var r = nbi();\n    BigInteger.ZERO.subTo(this, r);\n    return r;\n  }\n  // (public) |this|\n  function bnAbs()\n  {\n    return (this.s < 0) ? this.negate() : this;\n  }\n  // (public) return + if this > a, - if this < a, 0 if equal\n  function bnCompareTo(a)\n  {\n    var r = this.s - a.s;\n    if (r != 0) return r;\n    var i = this.t;\n    r = i - a.t;\n    if (r != 0) return (this.s < 0) ? -r : r;\n    while (--i >= 0)\n      if ((r = this[i] - a[i]) != 0) return r;\n    return 0;\n  }\n  // returns bit length of the integer x\n  function nbits(x)\n  {\n    var r = 1,\n      t;\n    if ((t = x >>> 16) != 0)\n    {\n      x = t;\n      r += 16;\n    }\n    if ((t = x >> 8) != 0)\n    {\n      x = t;\n      r += 8;\n    }\n    if ((t = x >> 4) != 0)\n    {\n      x = t;\n      r += 4;\n    }\n    if ((t = x >> 2) != 0)\n    {\n      x = t;\n      r += 2;\n    }\n    if ((t = x >> 1) != 0)\n    {\n      x = t;\n      r += 1;\n    }\n    return r;\n  }\n  // (public) return the number of bits in \"this\"\n  function bnBitLength()\n  {\n    if (this.t <= 0) return 0;\n    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n  }\n  // (protected) r = this << n*DB\n  function bnpDLShiftTo(n, r)\n  {\n    var i;\n    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n    for (i = n - 1; i >= 0; --i) r[i] = 0;\n    r.t = this.t + n;\n    r.s = this.s;\n  }\n  // (protected) r = this >> n*DB\n  function bnpDRShiftTo(n, r)\n  {\n    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n    r.t = Math.max(this.t - n, 0);\n    r.s = this.s;\n  }\n  // (protected) r = this << n\n  function bnpLShiftTo(n, r)\n  {\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << cbs) - 1;\n    var ds = Math.floor(n / this.DB),\n      c = (this.s << bs) & this.DM,\n      i;\n    for (i = this.t - 1; i >= 0; --i)\n    {\n      r[i + ds + 1] = (this[i] >> cbs) | c;\n      c = (this[i] & bm) << bs;\n    }\n    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n    r[ds] = c;\n    r.t = this.t + ds + 1;\n    r.s = this.s;\n    r.clamp();\n  }\n  // (protected) r = this >> n\n  function bnpRShiftTo(n, r)\n  {\n    r.s = this.s;\n    var ds = Math.floor(n / this.DB);\n    if (ds >= this.t)\n    {\n      r.t = 0;\n      return;\n    }\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << bs) - 1;\n    r[0] = this[ds] >> bs;\n    for (var i = ds + 1; i < this.t; ++i)\n    {\n      r[i - ds - 1] |= (this[i] & bm) << cbs;\n      r[i - ds] = this[i] >> bs;\n    }\n    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n    r.t = this.t - ds;\n    r.clamp();\n  }\n  // (protected) r = this - a\n  function bnpSubTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] - a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c -= a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c -= a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c -= a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c < -1) r[i++] = this.DV + c;\n    else if (c > 0) r[i++] = c;\n    r.t = i;\n    r.clamp();\n  }\n  // (protected) r = this * a, r != this,a (HAC 14.12)\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyTo(a, r)\n  {\n    var x = this.abs(),\n      y = a.abs();\n    var i = x.t;\n    r.t = i + y.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n    r.s = 0;\n    r.clamp();\n    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n  }\n  // (protected) r = this^2, r != this (HAC 14.16)\n  function bnpSquareTo(r)\n  {\n    var x = this.abs();\n    var i = r.t = 2 * x.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < x.t - 1; ++i)\n    {\n      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n      {\n        r[i + x.t] -= x.DV;\n        r[i + x.t + 1] = 1;\n      }\n    }\n    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n    r.s = 0;\n    r.clamp();\n  }\n  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n  // r != q, this != m.  q or r may be null.\n  function bnpDivRemTo(m, q, r)\n  {\n    var pm = m.abs();\n    if (pm.t <= 0) return;\n    var pt = this.abs();\n    if (pt.t < pm.t)\n    {\n      if (q != null) q.fromInt(0);\n      if (r != null) this.copyTo(r);\n      return;\n    }\n    if (r == null) r = nbi();\n    var y = nbi(),\n      ts = this.s,\n      ms = m.s;\n    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n    if (nsh > 0)\n    {\n      pm.lShiftTo(nsh, y);\n      pt.lShiftTo(nsh, r);\n    }\n    else\n    {\n      pm.copyTo(y);\n      pt.copyTo(r);\n    }\n    var ys = y.t;\n    var y0 = y[ys - 1];\n    if (y0 == 0) return;\n    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n    var d1 = this.FV / yt,\n      d2 = (1 << this.F1) / yt,\n      e = 1 << this.F2;\n    var i = r.t,\n      j = i - ys,\n      t = (q == null) ? nbi() : q;\n    y.dlShiftTo(j, t);\n    if (r.compareTo(t) >= 0)\n    {\n      r[r.t++] = 1;\n      r.subTo(t, r);\n    }\n    BigInteger.ONE.dlShiftTo(ys, t);\n    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n    while (y.t < ys) y[y.t++] = 0;\n    while (--j >= 0)\n    {\n      // Estimate quotient digit\n      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n      { // Try it out\n        y.dlShiftTo(j, t);\n        r.subTo(t, r);\n        while (r[i] < --qd) r.subTo(t, r);\n      }\n    }\n    if (q != null)\n    {\n      r.drShiftTo(ys, q);\n      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n    }\n    r.t = ys;\n    r.clamp();\n    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n  }\n  // (public) this mod a\n  function bnMod(a)\n  {\n    var r = nbi();\n    this.abs().divRemTo(a, null, r);\n    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n    return r;\n  }\n  // Modular reduction using \"classic\" algorithm\n  function Classic(m)\n  {\n    this.m = m;\n  }\n\n  function cConvert(x)\n  {\n    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n    else return x;\n  }\n\n  function cRevert(x)\n  {\n    return x;\n  }\n\n  function cReduce(x)\n  {\n    x.divRemTo(this.m, null, x);\n  }\n\n  function cMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n\n  function cSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  Classic.prototype.convert = cConvert;\n  Classic.prototype.revert = cRevert;\n  Classic.prototype.reduce = cReduce;\n  Classic.prototype.mulTo = cMulTo;\n  Classic.prototype.sqrTo = cSqrTo;\n  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n  // justification:\n  //         xy == 1 (mod m)\n  //         xy =  1+km\n  //   xy(2-xy) = (1+km)(1-km)\n  // x[y(2-xy)] = 1-k^2m^2\n  // x[y(2-xy)] == 1 (mod m^2)\n  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n  function bnpInvDigit()\n  {\n    if (this.t < 1) return 0;\n    var x = this[0];\n    if ((x & 1) == 0) return 0;\n    var y = x & 3; // y == 1/x mod 2^2\n    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n    // last step - calculate inverse mod DV directly;\n    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n    // we really want the negative inverse, and -DV < y < DV\n    return (y > 0) ? this.DV - y : -y;\n  }\n  // Montgomery reduction\n  function Montgomery(m)\n  {\n    this.m = m;\n    this.mp = m.invDigit();\n    this.mpl = this.mp & 0x7fff;\n    this.mph = this.mp >> 15;\n    this.um = (1 << (m.DB - 15)) - 1;\n    this.mt2 = 2 * m.t;\n  }\n  // xR mod m\n  function montConvert(x)\n  {\n    var r = nbi();\n    x.abs().dlShiftTo(this.m.t, r);\n    r.divRemTo(this.m, null, r);\n    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n    return r;\n  }\n  // x/R mod m\n  function montRevert(x)\n  {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n  }\n  // x = x/R mod m (HAC 14.32)\n  function montReduce(x)\n  {\n    while (x.t <= this.mt2) // pad x so am has enough room later\n      x[x.t++] = 0;\n    for (var i = 0; i < this.m.t; ++i)\n    {\n      // faster way of calculating u0 = x[i]*mp mod DV\n      var j = x[i] & 0x7fff;\n      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n      // use am to combine the multiply-shift-add into one call\n      j = i + this.m.t;\n      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n      // propagate carry\n      while (x[j] >= x.DV)\n      {\n        x[j] -= x.DV;\n        x[++j]++;\n      }\n    }\n    x.clamp();\n    x.drShiftTo(this.m.t, x);\n    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = \"x^2/R mod m\"; x != r\n  function montSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = \"xy/R mod m\"; x,y != r\n  function montMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Montgomery.prototype.convert = montConvert;\n  Montgomery.prototype.revert = montRevert;\n  Montgomery.prototype.reduce = montReduce;\n  Montgomery.prototype.mulTo = montMulTo;\n  Montgomery.prototype.sqrTo = montSqrTo;\n  // (protected) true iff this is even\n  function bnpIsEven()\n  {\n    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n  }\n  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n  function bnpExp(e, z)\n  {\n    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n    var r = nbi(),\n      r2 = nbi(),\n      g = z.convert(this),\n      i = nbits(e) - 1;\n    g.copyTo(r);\n    while (--i >= 0)\n    {\n      z.sqrTo(r, r2);\n      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n      else\n      {\n        var t = r;\n        r = r2;\n        r2 = t;\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) this^e % m, 0 <= e < 2^32\n  function bnModPowInt(e, m)\n  {\n    var z;\n    if (e < 256 || m.isEven()) z = new Classic(m);\n    else z = new Montgomery(m);\n    return this.exp(e, z);\n  }\n  // protected\n  BigInteger.prototype.copyTo = bnpCopyTo;\n  BigInteger.prototype.fromInt = bnpFromInt;\n  BigInteger.prototype.fromString = bnpFromString;\n  BigInteger.prototype.clamp = bnpClamp;\n  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n  BigInteger.prototype.subTo = bnpSubTo;\n  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n  BigInteger.prototype.squareTo = bnpSquareTo;\n  BigInteger.prototype.divRemTo = bnpDivRemTo;\n  BigInteger.prototype.invDigit = bnpInvDigit;\n  BigInteger.prototype.isEven = bnpIsEven;\n  BigInteger.prototype.exp = bnpExp;\n  // public\n  BigInteger.prototype.toString = bnToString;\n  BigInteger.prototype.negate = bnNegate;\n  BigInteger.prototype.abs = bnAbs;\n  BigInteger.prototype.compareTo = bnCompareTo;\n  BigInteger.prototype.bitLength = bnBitLength;\n  BigInteger.prototype.mod = bnMod;\n  BigInteger.prototype.modPowInt = bnModPowInt;\n  // \"constants\"\n  BigInteger.ZERO = nbv(0);\n  BigInteger.ONE = nbv(1);\n  // Copyright (c) 2005-2009  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Extended JavaScript BN functions, required for RSA private ops.\n  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n  // Version 1.2: square() API, isProbablePrime fix\n  // (public)\n  function bnClone()\n  {\n    var r = nbi();\n    this.copyTo(r);\n    return r;\n  }\n  // (public) return value as integer\n  function bnIntValue()\n  {\n    if (this.s < 0)\n    {\n      if (this.t == 1) return this[0] - this.DV;\n      else if (this.t == 0) return -1;\n    }\n    else if (this.t == 1) return this[0];\n    else if (this.t == 0) return 0;\n    // assumes 16 < DB < 32\n    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n  }\n  // (public) return value as byte\n  function bnByteValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n  }\n  // (public) return value as short (assumes DB>=16)\n  function bnShortValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n  }\n  // (protected) return x s.t. r^x < DV\n  function bnpChunkSize(r)\n  {\n    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n  }\n  // (public) 0 if this == 0, 1 if this > 0\n  function bnSigNum()\n  {\n    if (this.s < 0) return -1;\n    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n    else return 1;\n  }\n  // (protected) convert to radix string\n  function bnpToRadix(b)\n  {\n    if (b == null) b = 10;\n    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n    var cs = this.chunkSize(b);\n    var a = Math.pow(b, cs);\n    var d = nbv(a),\n      y = nbi(),\n      z = nbi(),\n      r = \"\";\n    this.divRemTo(d, y, z);\n    while (y.signum() > 0)\n    {\n      r = (a + z.intValue()).toString(b).substr(1) + r;\n      y.divRemTo(d, y, z);\n    }\n    return z.intValue().toString(b) + r;\n  }\n  // (protected) convert from radix string\n  function bnpFromRadix(s, b)\n  {\n    this.fromInt(0);\n    if (b == null) b = 10;\n    var cs = this.chunkSize(b);\n    var d = Math.pow(b, cs),\n      mi = false,\n      j = 0,\n      w = 0;\n    for (var i = 0; i < s.length; ++i)\n    {\n      var x = intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n        continue;\n      }\n      w = b * w + x;\n      if (++j >= cs)\n      {\n        this.dMultiply(d);\n        this.dAddOffset(w, 0);\n        j = 0;\n        w = 0;\n      }\n    }\n    if (j > 0)\n    {\n      this.dMultiply(Math.pow(b, j));\n      this.dAddOffset(w, 0);\n    }\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) alternate constructor\n  function bnpFromNumber(a, b, c)\n  {\n    if (\"number\" == typeof b)\n    {\n      // new BigInteger(int,int,RNG)\n      if (a < 2) this.fromInt(1);\n      else\n      {\n        this.fromNumber(a, c);\n        if (!this.testBit(a - 1)) // force MSB set\n          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n        while (!this.isProbablePrime(b))\n        {\n          this.dAddOffset(2, 0);\n          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n        }\n      }\n    }\n    else\n    {\n      // new BigInteger(int,RNG)\n      var x = new Array(),\n        t = a & 7;\n      x.length = (a >> 3) + 1;\n      b.nextBytes(x);\n      if (t > 0) x[0] &= ((1 << t) - 1);\n      else x[0] = 0;\n      this.fromString(x, 256);\n    }\n  }\n  // (public) convert to bigendian byte array\n  function bnToByteArray()\n  {\n    var i = this.t,\n      r = new Array();\n    r[0] = this.s;\n    var p = this.DB - (i * this.DB) % 8,\n      d, k = 0;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n        r[k++] = d | (this.s << (this.DB - p));\n      while (i >= 0)\n      {\n        if (p < 8)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n          d |= this[--i] >> (p += this.DB - 8);\n        }\n        else\n        {\n          d = (this[i] >> (p -= 8)) & 0xff;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if ((d & 0x80) != 0) d |= -256;\n        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n        if (k > 0 || d != this.s) r[k++] = d;\n      }\n    }\n    return r;\n  }\n\n  function bnEquals(a)\n  {\n    return (this.compareTo(a) == 0);\n  }\n\n  function bnMin(a)\n  {\n    return (this.compareTo(a) < 0) ? this : a;\n  }\n\n  function bnMax(a)\n  {\n    return (this.compareTo(a) > 0) ? this : a;\n  }\n  // (protected) r = this op a (bitwise)\n  function bnpBitwiseTo(a, op, r)\n  {\n    var i, f, m = Math.min(a.t, this.t);\n    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n    if (a.t < this.t)\n    {\n      f = a.s & this.DM;\n      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n      r.t = this.t;\n    }\n    else\n    {\n      f = this.s & this.DM;\n      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n      r.t = a.t;\n    }\n    r.s = op(this.s, a.s);\n    r.clamp();\n  }\n  // (public) this & a\n  function op_and(x, y)\n  {\n    return x & y;\n  }\n\n  function bnAnd(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_and, r);\n    return r;\n  }\n  // (public) this | a\n  function op_or(x, y)\n  {\n    return x | y;\n  }\n\n  function bnOr(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_or, r);\n    return r;\n  }\n  // (public) this ^ a\n  function op_xor(x, y)\n  {\n    return x ^ y;\n  }\n\n  function bnXor(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_xor, r);\n    return r;\n  }\n  // (public) this & ~a\n  function op_andnot(x, y)\n  {\n    return x & ~y;\n  }\n\n  function bnAndNot(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_andnot, r);\n    return r;\n  }\n  // (public) ~this\n  function bnNot()\n  {\n    var r = nbi();\n    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n    r.t = this.t;\n    r.s = ~this.s;\n    return r;\n  }\n  // (public) this << n\n  function bnShiftLeft(n)\n  {\n    var r = nbi();\n    if (n < 0) this.rShiftTo(-n, r);\n    else this.lShiftTo(n, r);\n    return r;\n  }\n  // (public) this >> n\n  function bnShiftRight(n)\n  {\n    var r = nbi();\n    if (n < 0) this.lShiftTo(-n, r);\n    else this.rShiftTo(n, r);\n    return r;\n  }\n  // return index of lowest 1-bit in x, x < 2^31\n  function lbit(x)\n  {\n    if (x == 0) return -1;\n    var r = 0;\n    if ((x & 0xffff) == 0)\n    {\n      x >>= 16;\n      r += 16;\n    }\n    if ((x & 0xff) == 0)\n    {\n      x >>= 8;\n      r += 8;\n    }\n    if ((x & 0xf) == 0)\n    {\n      x >>= 4;\n      r += 4;\n    }\n    if ((x & 3) == 0)\n    {\n      x >>= 2;\n      r += 2;\n    }\n    if ((x & 1) == 0)++r;\n    return r;\n  }\n  // (public) returns index of lowest 1-bit (or -1 if none)\n  function bnGetLowestSetBit()\n  {\n    for (var i = 0; i < this.t; ++i)\n      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n    if (this.s < 0) return this.t * this.DB;\n    return -1;\n  }\n  // return number of 1 bits in x\n  function cbit(x)\n  {\n    var r = 0;\n    while (x != 0)\n    {\n      x &= x - 1;\n      ++r;\n    }\n    return r;\n  }\n  // (public) return number of set bits\n  function bnBitCount()\n  {\n    var r = 0,\n      x = this.s & this.DM;\n    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n    return r;\n  }\n  // (public) true iff nth bit is set\n  function bnTestBit(n)\n  {\n    var j = Math.floor(n / this.DB);\n    if (j >= this.t) return (this.s != 0);\n    return ((this[j] & (1 << (n % this.DB))) != 0);\n  }\n  // (protected) this op (1<<n)\n  function bnpChangeBit(n, op)\n  {\n    var r = BigInteger.ONE.shiftLeft(n);\n    this.bitwiseTo(r, op, r);\n    return r;\n  }\n  // (public) this | (1<<n)\n  function bnSetBit(n)\n  {\n    return this.changeBit(n, op_or);\n  }\n  // (public) this & ~(1<<n)\n  function bnClearBit(n)\n  {\n    return this.changeBit(n, op_andnot);\n  }\n  // (public) this ^ (1<<n)\n  function bnFlipBit(n)\n  {\n    return this.changeBit(n, op_xor);\n  }\n  // (protected) r = this + a\n  function bnpAddTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] + a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c += a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c += a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c > 0) r[i++] = c;\n    else if (c < -1) r[i++] = this.DV + c;\n    r.t = i;\n    r.clamp();\n  }\n  // (public) this + a\n  function bnAdd(a)\n  {\n    var r = nbi();\n    this.addTo(a, r);\n    return r;\n  }\n  // (public) this - a\n  function bnSubtract(a)\n  {\n    var r = nbi();\n    this.subTo(a, r);\n    return r;\n  }\n  // (public) this * a\n  function bnMultiply(a)\n  {\n    var r = nbi();\n    this.multiplyTo(a, r);\n    return r;\n  }\n  // (public) this^2\n  function bnSquare()\n  {\n    var r = nbi();\n    this.squareTo(r);\n    return r;\n  }\n  // (public) this / a\n  function bnDivide(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, r, null);\n    return r;\n  }\n  // (public) this % a\n  function bnRemainder(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, null, r);\n    return r;\n  }\n  // (public) [this/a,this%a]\n  function bnDivideAndRemainder(a)\n  {\n    var q = nbi(),\n      r = nbi();\n    this.divRemTo(a, q, r);\n    return new Array(q, r);\n  }\n  // (protected) this *= n, this >= 0, 1 < n < DV\n  function bnpDMultiply(n)\n  {\n    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n    ++this.t;\n    this.clamp();\n  }\n  // (protected) this += n << w words, this >= 0\n  function bnpDAddOffset(n, w)\n  {\n    if (n == 0) return;\n    while (this.t <= w) this[this.t++] = 0;\n    this[w] += n;\n    while (this[w] >= this.DV)\n    {\n      this[w] -= this.DV;\n      if (++w >= this.t) this[this.t++] = 0;\n      ++this[w];\n    }\n  }\n  // A \"null\" reducer\n  function NullExp()\n  {}\n\n  function nNop(x)\n  {\n    return x;\n  }\n\n  function nMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n  }\n\n  function nSqrTo(x, r)\n  {\n    x.squareTo(r);\n  }\n  NullExp.prototype.convert = nNop;\n  NullExp.prototype.revert = nNop;\n  NullExp.prototype.mulTo = nMulTo;\n  NullExp.prototype.sqrTo = nSqrTo;\n  // (public) this^e\n  function bnPow(e)\n  {\n    return this.exp(e, new NullExp());\n  }\n  // (protected) r = lower n words of \"this * a\", a.t <= n\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyLowerTo(a, n, r)\n  {\n    var i = Math.min(this.t + a.t, n);\n    r.s = 0; // assumes a,this >= 0\n    r.t = i;\n    while (i > 0) r[--i] = 0;\n    var j;\n    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n    r.clamp();\n  }\n  // (protected) r = \"this * a\" without lower n words, n > 0\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyUpperTo(a, n, r)\n  {\n    --n;\n    var i = r.t = this.t + a.t - n;\n    r.s = 0; // assumes a,this >= 0\n    while (--i >= 0) r[i] = 0;\n    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n    r.clamp();\n    r.drShiftTo(1, r);\n  }\n  // Barrett modular reduction\n  function Barrett(m)\n  {\n    // setup Barrett\n    this.r2 = nbi();\n    this.q3 = nbi();\n    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n    this.mu = this.r2.divide(m);\n    this.m = m;\n  }\n\n  function barrettConvert(x)\n  {\n    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n    else if (x.compareTo(this.m) < 0) return x;\n    else\n    {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n  }\n\n  function barrettRevert(x)\n  {\n    return x;\n  }\n  // x = x mod m (HAC 14.42)\n  function barrettReduce(x)\n  {\n    x.drShiftTo(this.m.t - 1, this.r2);\n    if (x.t > this.m.t + 1)\n    {\n      x.t = this.m.t + 1;\n      x.clamp();\n    }\n    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n    x.subTo(this.r2, x);\n    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = x^2 mod m; x != r\n  function barrettSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = x*y mod m; x,y != r\n  function barrettMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Barrett.prototype.convert = barrettConvert;\n  Barrett.prototype.revert = barrettRevert;\n  Barrett.prototype.reduce = barrettReduce;\n  Barrett.prototype.mulTo = barrettMulTo;\n  Barrett.prototype.sqrTo = barrettSqrTo;\n  // (public) this^e % m (HAC 14.85)\n  function bnModPow(e, m)\n  {\n    var i = e.bitLength(),\n      k, r = nbv(1),\n      z;\n    if (i <= 0) return r;\n    else if (i < 18) k = 1;\n    else if (i < 48) k = 3;\n    else if (i < 144) k = 4;\n    else if (i < 768) k = 5;\n    else k = 6;\n    if (i < 8)\n      z = new Classic(m);\n    else if (m.isEven())\n      z = new Barrett(m);\n    else\n      z = new Montgomery(m);\n    // precomputation\n    var g = new Array(),\n      n = 3,\n      k1 = k - 1,\n      km = (1 << k) - 1;\n    g[1] = z.convert(this);\n    if (k > 1)\n    {\n      var g2 = nbi();\n      z.sqrTo(g[1], g2);\n      while (n <= km)\n      {\n        g[n] = nbi();\n        z.mulTo(g2, g[n - 2], g[n]);\n        n += 2;\n      }\n    }\n    var j = e.t - 1,\n      w, is1 = true,\n      r2 = nbi(),\n      t;\n    i = nbits(e[j]) - 1;\n    while (j >= 0)\n    {\n      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n      else\n      {\n        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n      }\n      n = k;\n      while ((w & 1) == 0)\n      {\n        w >>= 1;\n        --n;\n      }\n      if ((i -= n) < 0)\n      {\n        i += this.DB;\n        --j;\n      }\n      if (is1)\n      { // ret == 1, don't bother squaring or multiplying it\n        g[w].copyTo(r);\n        is1 = false;\n      }\n      else\n      {\n        while (n > 1)\n        {\n          z.sqrTo(r, r2);\n          z.sqrTo(r2, r);\n          n -= 2;\n        }\n        if (n > 0) z.sqrTo(r, r2);\n        else\n        {\n          t = r;\n          r = r2;\n          r2 = t;\n        }\n        z.mulTo(r2, g[w], r);\n      }\n      while (j >= 0 && (e[j] & (1 << i)) == 0)\n      {\n        z.sqrTo(r, r2);\n        t = r;\n        r = r2;\n        r2 = t;\n        if (--i < 0)\n        {\n          i = this.DB - 1;\n          --j;\n        }\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) gcd(this,a) (HAC 14.54)\n  function bnGCD(a)\n  {\n    var x = (this.s < 0) ? this.negate() : this.clone();\n    var y = (a.s < 0) ? a.negate() : a.clone();\n    if (x.compareTo(y) < 0)\n    {\n      var t = x;\n      x = y;\n      y = t;\n    }\n    var i = x.getLowestSetBit(),\n      g = y.getLowestSetBit();\n    if (g < 0) return x;\n    if (i < g) g = i;\n    if (g > 0)\n    {\n      x.rShiftTo(g, x);\n      y.rShiftTo(g, y);\n    }\n    while (x.signum() > 0)\n    {\n      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n      if (x.compareTo(y) >= 0)\n      {\n        x.subTo(y, x);\n        x.rShiftTo(1, x);\n      }\n      else\n      {\n        y.subTo(x, y);\n        y.rShiftTo(1, y);\n      }\n    }\n    if (g > 0) y.lShiftTo(g, y);\n    return y;\n  }\n  // (protected) this % n, n < 2^26\n  function bnpModInt(n)\n  {\n    if (n <= 0) return 0;\n    var d = this.DV % n,\n      r = (this.s < 0) ? n - 1 : 0;\n    if (this.t > 0)\n      if (d == 0) r = this[0] % n;\n      else\n        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n    return r;\n  }\n  // (public) 1/this % m (HAC 14.61)\n  function bnModInverse(m)\n  {\n    var ac = m.isEven();\n    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n    var u = m.clone(),\n      v = this.clone();\n    var a = nbv(1),\n      b = nbv(0),\n      c = nbv(0),\n      d = nbv(1);\n    while (u.signum() != 0)\n    {\n      while (u.isEven())\n      {\n        u.rShiftTo(1, u);\n        if (ac)\n        {\n          if (!a.isEven() || !b.isEven())\n          {\n            a.addTo(this, a);\n            b.subTo(m, b);\n          }\n          a.rShiftTo(1, a);\n        }\n        else if (!b.isEven()) b.subTo(m, b);\n        b.rShiftTo(1, b);\n      }\n      while (v.isEven())\n      {\n        v.rShiftTo(1, v);\n        if (ac)\n        {\n          if (!c.isEven() || !d.isEven())\n          {\n            c.addTo(this, c);\n            d.subTo(m, d);\n          }\n          c.rShiftTo(1, c);\n        }\n        else if (!d.isEven()) d.subTo(m, d);\n        d.rShiftTo(1, d);\n      }\n      if (u.compareTo(v) >= 0)\n      {\n        u.subTo(v, u);\n        if (ac) a.subTo(c, a);\n        b.subTo(d, b);\n      }\n      else\n      {\n        v.subTo(u, v);\n        if (ac) c.subTo(a, c);\n        d.subTo(b, d);\n      }\n    }\n    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n    if (d.compareTo(m) >= 0) return d.subtract(m);\n    if (d.signum() < 0) d.addTo(m, d);\n    else return d;\n    if (d.signum() < 0) return d.add(m);\n    else return d;\n  }\n  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n  // (public) test primality with certainty >= 1-.5^t\n  function bnIsProbablePrime(t)\n  {\n    var i, x = this.abs();\n    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n    {\n      for (i = 0; i < lowprimes.length; ++i)\n        if (x[0] == lowprimes[i]) return true;\n      return false;\n    }\n    if (x.isEven()) return false;\n    i = 1;\n    while (i < lowprimes.length)\n    {\n      var m = lowprimes[i],\n        j = i + 1;\n      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n      m = x.modInt(m);\n      while (i < j)\n        if (m % lowprimes[i++] == 0) return false;\n    }\n    return x.millerRabin(t);\n  }\n  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n  function bnpMillerRabin(t)\n  {\n    var n1 = this.subtract(BigInteger.ONE);\n    var k = n1.getLowestSetBit();\n    if (k <= 0) return false;\n    var r = n1.shiftRight(k);\n    t = (t + 1) >> 1;\n    if (t > lowprimes.length) t = lowprimes.length;\n    var a = nbi();\n    for (var i = 0; i < t; ++i)\n    {\n      //Pick bases at random, instead of starting at 2\n      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n      var y = a.modPow(r, this);\n      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n      {\n        var j = 1;\n        while (j++ < k && y.compareTo(n1) != 0)\n        {\n          y = y.modPowInt(2, this);\n          if (y.compareTo(BigInteger.ONE) == 0) return false;\n        }\n        if (y.compareTo(n1) != 0) return false;\n      }\n    }\n    return true;\n  }\n  // protected\n  BigInteger.prototype.chunkSize = bnpChunkSize;\n  BigInteger.prototype.toRadix = bnpToRadix;\n  BigInteger.prototype.fromRadix = bnpFromRadix;\n  BigInteger.prototype.fromNumber = bnpFromNumber;\n  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n  BigInteger.prototype.changeBit = bnpChangeBit;\n  BigInteger.prototype.addTo = bnpAddTo;\n  BigInteger.prototype.dMultiply = bnpDMultiply;\n  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n  BigInteger.prototype.modInt = bnpModInt;\n  BigInteger.prototype.millerRabin = bnpMillerRabin;\n  // public\n  BigInteger.prototype.clone = bnClone;\n  BigInteger.prototype.intValue = bnIntValue;\n  BigInteger.prototype.byteValue = bnByteValue;\n  BigInteger.prototype.shortValue = bnShortValue;\n  BigInteger.prototype.signum = bnSigNum;\n  BigInteger.prototype.toByteArray = bnToByteArray;\n  BigInteger.prototype.equals = bnEquals;\n  BigInteger.prototype.min = bnMin;\n  BigInteger.prototype.max = bnMax;\n  BigInteger.prototype.and = bnAnd;\n  BigInteger.prototype.or = bnOr;\n  BigInteger.prototype.xor = bnXor;\n  BigInteger.prototype.andNot = bnAndNot;\n  BigInteger.prototype.not = bnNot;\n  BigInteger.prototype.shiftLeft = bnShiftLeft;\n  BigInteger.prototype.shiftRight = bnShiftRight;\n  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n  BigInteger.prototype.bitCount = bnBitCount;\n  BigInteger.prototype.testBit = bnTestBit;\n  BigInteger.prototype.setBit = bnSetBit;\n  BigInteger.prototype.clearBit = bnClearBit;\n  BigInteger.prototype.flipBit = bnFlipBit;\n  BigInteger.prototype.add = bnAdd;\n  BigInteger.prototype.subtract = bnSubtract;\n  BigInteger.prototype.multiply = bnMultiply;\n  BigInteger.prototype.divide = bnDivide;\n  BigInteger.prototype.remainder = bnRemainder;\n  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n  BigInteger.prototype.modPow = bnModPow;\n  BigInteger.prototype.modInverse = bnModInverse;\n  BigInteger.prototype.pow = bnPow;\n  BigInteger.prototype.gcd = bnGCD;\n  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n  // JSBN-specific extension\n  BigInteger.prototype.square = bnSquare;\n  var Int128 = BigInteger;\n  // BigInteger interfaces not implemented in jsbn:\n  // BigInteger(int signum, byte[] magnitude)\n  // double doubleValue()\n  // float floatValue()\n  // int hashCode()\n  // long longValue()\n  // static BigInteger valueOf(long val)\n  // Helper functions to make BigInteger functions callable with two parameters\n  // as in original C# Clipper\n  Int128.prototype.IsNegative = function ()\n  {\n    if (this.compareTo(Int128.ZERO) == -1) return true;\n    else return false;\n  };\n  Int128.op_Equality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) == 0) return true;\n    else return false;\n  };\n  Int128.op_Inequality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) != 0) return true;\n    else return false;\n  };\n  Int128.op_GreaterThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) > 0) return true;\n    else return false;\n  };\n  Int128.op_LessThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) < 0) return true;\n    else return false;\n  };\n  Int128.op_Addition = function (lhs, rhs)\n  {\n    return new Int128(lhs).add(new Int128(rhs));\n  };\n  Int128.op_Subtraction = function (lhs, rhs)\n  {\n    return new Int128(lhs).subtract(new Int128(rhs));\n  };\n  Int128.Int128Mul = function (lhs, rhs)\n  {\n    return new Int128(lhs).multiply(new Int128(rhs));\n  };\n  Int128.op_Division = function (lhs, rhs)\n  {\n    return lhs.divide(rhs);\n  };\n  Int128.prototype.ToDouble = function ()\n  {\n    return parseFloat(this.toString()); // This could be something faster\n  };\n  // end of Int128 section\n  /*\n  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n  else self.Int128 = Int128;\n  */\n\n\n  // ---------------------------------------------\n  // Here starts the actual Clipper library:\n  // Helper function to support Inheritance in Javascript\n\tvar Inherit = function (ce, ce2)\n\t{\n\t\tvar p;\n\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t{\n\t\t\tfor (p in ce2.prototype)\n\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t};\n  ClipperLib.Path = function ()\n  {\n    return [];\n  };\n  ClipperLib.Paths = function ()\n  {\n    return []; // Was previously [[]], but caused problems when pushed\n  };\n  // Preserves the calling way of original C# Clipper\n  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n  ClipperLib.DoublePoint = function ()\n  {\n    var a = arguments;\n    this.X = 0;\n    this.Y = 0;\n    // public DoublePoint(DoublePoint dp)\n    // public DoublePoint(IntPoint ip)\n    if (a.length == 1)\n    {\n      this.X = a[0].X;\n      this.Y = a[0].Y;\n    }\n    else if (a.length == 2)\n    {\n      this.X = a[0];\n      this.Y = a[1];\n    }\n  }; // This is internal faster function when called without arguments\n  ClipperLib.DoublePoint0 = function ()\n  {\n    this.X = 0;\n    this.Y = 0;\n  };\n  // This is internal faster function when called with 1 argument (dp or ip)\n  ClipperLib.DoublePoint1 = function (dp)\n  {\n    this.X = dp.X;\n    this.Y = dp.Y;\n  };\n  // This is internal faster function when called with 2 arguments (x and y)\n  ClipperLib.DoublePoint2 = function (x, y)\n  {\n    this.X = x;\n    this.Y = y;\n  };\n  // PolyTree & PolyNode start\n  // -------------------------------\n  ClipperLib.PolyNode = function ()\n  {\n    this.m_Parent = null;\n    this.m_polygon = new ClipperLib.Path();\n    this.m_Index = 0;\n    this.m_jointype = 0;\n    this.m_endtype = 0;\n    this.m_Childs = [];\n    this.IsOpen = false;\n  };\n  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n  {\n    var result = true;\n    var node = this.m_Parent;\n    while (node !== null)\n    {\n      result = !result;\n      node = node.m_Parent;\n    }\n    return result;\n  };\n  ClipperLib.PolyNode.prototype.ChildCount = function ()\n  {\n    return this.m_Childs.length;\n  };\n  ClipperLib.PolyNode.prototype.Contour = function ()\n  {\n    return this.m_polygon;\n  };\n  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n  {\n    var cnt = this.m_Childs.length;\n    this.m_Childs.push(Child);\n    Child.m_Parent = this;\n    Child.m_Index = cnt;\n  };\n  ClipperLib.PolyNode.prototype.GetNext = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return this.GetNextSiblingUp();\n  };\n  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n  {\n    if (this.m_Parent === null)\n      return null;\n    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n      return this.m_Parent.GetNextSiblingUp();\n    else\n      return this.m_Parent.m_Childs[this.m_Index + 1];\n  };\n  ClipperLib.PolyNode.prototype.Childs = function ()\n  {\n    return this.m_Childs;\n  };\n  ClipperLib.PolyNode.prototype.Parent = function ()\n  {\n    return this.m_Parent;\n  };\n  ClipperLib.PolyNode.prototype.IsHole = function ()\n  {\n    return this.IsHoleNode();\n  };\n  // PolyTree : PolyNode\n  ClipperLib.PolyTree = function ()\n  {\n    this.m_AllPolys = [];\n    ClipperLib.PolyNode.call(this);\n  };\n  ClipperLib.PolyTree.prototype.Clear = function ()\n  {\n    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n      this.m_AllPolys[i] = null;\n    this.m_AllPolys.length = 0;\n    this.m_Childs.length = 0;\n  };\n  ClipperLib.PolyTree.prototype.GetFirst = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return null;\n  };\n  ClipperLib.PolyTree.prototype.Total = function ()\n  {\n\t\tvar result = this.m_AllPolys.length;\n\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\treturn result;\n  };\n  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n  // -------------------------------\n  // PolyTree & PolyNode end\n  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n  {\n    return Math.abs(a);\n  };\n  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n  {\n    return Math.max(a, b);\n  };\n  /*\n  -----------------------------------\n  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n  -----------------------------------\n  */\n  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n  {\n    return a | 0;\n  };\n  else ClipperLib.Cast_Int32 = function (a)\n  { // eg. browser.chrome || browser.chromium || browser.firefox\n    return~~ a;\n  };\n  /*\n  --------------------------\n  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n  Chrome: bitwise_not_floor\n  Firefox17: toInteger (typeof test)\n  IE9: bitwise_or_floor\n  IE7 and IE8: to_parseint\n  Chromium: to_floor_or_ceil\n  Firefox3: to_floor_or_ceil\n  Firefox15: to_floor_or_ceil\n  Opera: to_floor_or_ceil\n  Safari: to_floor_or_ceil\n  --------------------------\n  */\n  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    else return~~ a;\n  };\n  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n  {\n    return Number.toInteger(a);\n  };\n  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n  {\n    return parseInt(a, 10);\n  };\n  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    return a | 0;\n  };\n  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n  else ClipperLib.Cast_Int64 = function (a)\n  {\n    return a < 0 ? Math.ceil(a) : Math.floor(a);\n  };\n  ClipperLib.Clear = function (a)\n  {\n    a.length = 0;\n  };\n  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n  ClipperLib.PI = 3.141592653589793;\n  ClipperLib.PI2 = 2 * 3.141592653589793;\n  ClipperLib.IntPoint = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    this.X = 0;\n    this.Y = 0;\n    if (use_xyz)\n    {\n      this.Z = 0;\n      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = a[2];\n      }\n      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = 0;\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n          this.Z = 0;\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n          this.X = pt.X;\n          this.Y = pt.Y;\n          this.Z = pt.Z;\n        }\n      }\n      else // public IntPoint()\n      {\n        this.X = 0;\n        this.Y = 0;\n        this.Z = 0;\n      }\n    }\n    else // if (!use_xyz)\n    {\n      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          this.X = pt.X;\n          this.Y = pt.Y;\n        }\n      }\n      else // public IntPoint(IntPoint pt)\n      {\n        this.X = 0;\n        this.Y = 0;\n      }\n    }\n  };\n  ClipperLib.IntPoint.op_Equality = function (a, b)\n  {\n    //return a == b;\n    return a.X == b.X && a.Y == b.Y;\n  };\n  ClipperLib.IntPoint.op_Inequality = function (a, b)\n  {\n    //return a != b;\n    return a.X != b.X || a.Y != b.Y;\n  };\n  /*\n  ClipperLib.IntPoint.prototype.Equals = function (obj)\n  {\n    if (obj === null)\n        return false;\n    if (obj instanceof ClipperLib.IntPoint)\n    {\n        var a = Cast(obj, ClipperLib.IntPoint);\n        return (this.X == a.X) && (this.Y == a.Y);\n    }\n    else\n        return false;\n  };\n*/\n  if (use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n      this.Z = pt.Z;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint3 = function (x, y, z)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = z;\n    };\n  }\n  else // if (!use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n    };\n  }\n  ClipperLib.IntRect = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    if (alen == 4) // function (l, t, r, b)\n    {\n      this.left = a[0];\n      this.top = a[1];\n      this.right = a[2];\n      this.bottom = a[3];\n    }\n    else if (alen == 1) // function (ir)\n    {\n      this.left = ir.left;\n      this.top = ir.top;\n      this.right = ir.right;\n      this.bottom = ir.bottom;\n    }\n    else // function ()\n    {\n      this.left = 0;\n      this.top = 0;\n      this.right = 0;\n      this.bottom = 0;\n    }\n  };\n  ClipperLib.IntRect0 = function ()\n  {\n    this.left = 0;\n    this.top = 0;\n    this.right = 0;\n    this.bottom = 0;\n  };\n  ClipperLib.IntRect1 = function (ir)\n  {\n    this.left = ir.left;\n    this.top = ir.top;\n    this.right = ir.right;\n    this.bottom = ir.bottom;\n  };\n  ClipperLib.IntRect4 = function (l, t, r, b)\n  {\n    this.left = l;\n    this.top = t;\n    this.right = r;\n    this.bottom = b;\n  };\n  ClipperLib.ClipType = {\n    ctIntersection: 0,\n    ctUnion: 1,\n    ctDifference: 2,\n    ctXor: 3\n  };\n  ClipperLib.PolyType = {\n    ptSubject: 0,\n    ptClip: 1\n  };\n  ClipperLib.PolyFillType = {\n    pftEvenOdd: 0,\n    pftNonZero: 1,\n    pftPositive: 2,\n    pftNegative: 3\n  };\n  ClipperLib.JoinType = {\n    jtSquare: 0,\n    jtRound: 1,\n    jtMiter: 2\n  };\n  ClipperLib.EndType = {\n    etOpenSquare: 0,\n    etOpenRound: 1,\n    etOpenButt: 2,\n    etClosedLine: 3,\n    etClosedPolygon: 4\n  };\n  ClipperLib.EdgeSide = {\n    esLeft: 0,\n    esRight: 1\n  };\n  ClipperLib.Direction = {\n    dRightToLeft: 0,\n    dLeftToRight: 1\n  };\n  ClipperLib.TEdge = function ()\n  {\n    this.Bot = new ClipperLib.IntPoint();\n    this.Curr = new ClipperLib.IntPoint();\n    this.Top = new ClipperLib.IntPoint();\n    this.Delta = new ClipperLib.IntPoint();\n    this.Dx = 0;\n    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n    this.Side = ClipperLib.EdgeSide.esLeft;\n    this.WindDelta = 0;\n    this.WindCnt = 0;\n    this.WindCnt2 = 0;\n    this.OutIdx = 0;\n    this.Next = null;\n    this.Prev = null;\n    this.NextInLML = null;\n    this.NextInAEL = null;\n    this.PrevInAEL = null;\n    this.NextInSEL = null;\n    this.PrevInSEL = null;\n  };\n  ClipperLib.IntersectNode = function ()\n  {\n    this.Edge1 = null;\n    this.Edge2 = null;\n    this.Pt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.MyIntersectNodeSort = function () {};\n  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n  {\n    var i = node2.Pt.Y - node1.Pt.Y;\n    if (i > 0) return 1;\n    else if (i < 0) return -1;\n    else return 0;\n  };\n\n  ClipperLib.LocalMinima = function ()\n  {\n    this.Y = 0;\n    this.LeftBound = null;\n    this.RightBound = null;\n    this.Next = null;\n  };\n  ClipperLib.Scanbeam = function ()\n  {\n    this.Y = 0;\n    this.Next = null;\n  };\n  ClipperLib.OutRec = function ()\n  {\n    this.Idx = 0;\n    this.IsHole = false;\n    this.IsOpen = false;\n    this.FirstLeft = null;\n    this.Pts = null;\n    this.BottomPt = null;\n    this.PolyNode = null;\n  };\n  ClipperLib.OutPt = function ()\n  {\n    this.Idx = 0;\n    this.Pt = new ClipperLib.IntPoint();\n    this.Next = null;\n    this.Prev = null;\n  };\n  ClipperLib.Join = function ()\n  {\n    this.OutPt1 = null;\n    this.OutPt2 = null;\n    this.OffPt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.ClipperBase = function ()\n  {\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_edges = new Array();\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n    this.PreserveCollinear = false;\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n  // protected const double horizontal = -3.4E+38;\n  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n  // So had to adjust them to more suitable for Javascript.\n  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n  ClipperLib.ClipperBase.Skip = -2;\n  ClipperLib.ClipperBase.Unassigned = -1;\n  ClipperLib.ClipperBase.tolerance = 1E-20;\n  if (use_int32)\n  {\n    ClipperLib.ClipperBase.loRange = 0x7FFF;\n    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n  }\n  else\n  {\n    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n  }\n\n  ClipperLib.ClipperBase.near_zero = function (val)\n  {\n    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n  };\n  ClipperLib.ClipperBase.IsHorizontal = function (e)\n  {\n    return e.Delta.Y === 0;\n  };\n  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n  {\n    var pp2 = pp;\n    do {\n      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n        return true;\n      pp2 = pp2.Next;\n    }\n    while (pp2 != pp)\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n  {\n    if (UseFullRange)\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n    else\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n  };\n  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n  {\n    var pp2 = pp;\n    while (true)\n    {\n      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n        return true;\n      pp2 = pp2.Next;\n      if (pp2 == pp)\n        break;\n    }\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n    if (alen == 3) // function (e1, e2, UseFullRange)\n    {\n      e1 = a[0];\n      e2 = a[1];\n      UseFullRange = a[2];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n      else\n        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n    }\n    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      UseFullRange = a[3];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n    }\n    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      pt4 = a[3];\n      UseFullRange = a[4];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n    }\n  };\n  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n    else\n      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n  };\n  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.prototype.Clear = function ()\n  {\n    this.DisposeLocalMinimaList();\n    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n    {\n      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n        this.m_edges[i][j] = null;\n      ClipperLib.Clear(this.m_edges[i]);\n    }\n    ClipperLib.Clear(this.m_edges);\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n  {\n    while (this.m_MinimaList !== null)\n    {\n      var tmpLm = this.m_MinimaList.Next;\n      this.m_MinimaList = null;\n      this.m_MinimaList = tmpLm;\n    }\n    this.m_CurrentLM = null;\n  };\n  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n  {\n    if (useFullRange.Value)\n    {\n      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n    }\n    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n    {\n      useFullRange.Value = true;\n      this.RangeTest(Pt, useFullRange);\n    }\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n  {\n    e.Next = eNext;\n    e.Prev = ePrev;\n    //e.Curr = pt;\n    e.Curr.X = pt.X;\n    e.Curr.Y = pt.Y;\n    e.OutIdx = -1;\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n  {\n    if (e.Curr.Y >= e.Next.Curr.Y)\n    {\n      //e.Bot = e.Curr;\n      e.Bot.X = e.Curr.X;\n      e.Bot.Y = e.Curr.Y;\n      //e.Top = e.Next.Curr;\n      e.Top.X = e.Next.Curr.X;\n      e.Top.Y = e.Next.Curr.Y;\n    }\n    else\n    {\n      //e.Top = e.Curr;\n      e.Top.X = e.Curr.X;\n      e.Top.Y = e.Curr.Y;\n      //e.Bot = e.Next.Curr;\n      e.Bot.X = e.Next.Curr.X;\n      e.Bot.Y = e.Next.Curr.Y;\n    }\n    this.SetDx(e);\n    e.PolyTyp = polyType;\n  };\n  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n  {\n    var E2;\n    for (;;)\n    {\n      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n        E = E.Next;\n      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n        break;\n      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Prev;\n      E2 = E;\n      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Next;\n      if (E.Top.Y == E.Prev.Bot.Y)\n        continue;\n      //ie just an intermediate horz.\n      if (E2.Prev.Bot.X < E.Bot.X)\n        E = E2;\n      break;\n    }\n    return E;\n  };\n  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n  {\n    var EStart;\n    var Result = E;\n    var Horz;\n\n      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n      {\n        //check if there are edges beyond the skip edge in the bound and if so\n        //create another LocMin and calling ProcessBound once more ...\n        E = Result;\n        if (LeftBoundIsForward)\n        {\n          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n        }\n        else\n        {\n          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n        }\n        if (E == Result)\n        {\n          if (LeftBoundIsForward) Result = E.Next;\n          else Result = E.Prev;\n        }\n        else\n        {\n          //there are more edges in the bound beyond result starting with E\n          if (LeftBoundIsForward)\n            E = Result.Next;\n          else\n            E = Result.Prev;\n          var locMin = new ClipperLib.LocalMinima();\n          locMin.Next = null;\n          locMin.Y = E.Bot.Y;\n          locMin.LeftBound = null;\n          locMin.RightBound = E;\n          E.WindDelta = 0;\n          Result = this.ProcessBound(E, LeftBoundIsForward);\n          this.InsertLocalMinima(locMin);\n        }\n        return Result;\n      }\n\n      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n      {\n        //We need to be careful with open paths because this may not be a\n        //true local minima (ie E may be following a skip edge).\n        //Also, consecutive horz. edges may start heading left before going right.\n        if (LeftBoundIsForward) EStart = E.Prev;\n        else EStart = E.Next;\n        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n          {\n            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n              this.ReverseHorizontal(E);\n          }\n          else if (EStart.Bot.X != E.Bot.X)\n            this.ReverseHorizontal(E);\n        }\n      }\n\n      EStart = E;\n      if (LeftBoundIsForward)\n      {\n        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Next;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          //nb: at the top of a bound, horizontals are added to the bound\n          //only when the preceding edge attaches to the horizontal's left vertex\n          //unless a Skip edge is encountered when that becomes the top divide\n          Horz = Result;\n          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Prev;\n          if (Horz.Prev.Top.X == Result.Next.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Prev;\n          }\n          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n            Result = Horz.Prev;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Next;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Next;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Next;\n        //move to the edge just beyond current bound\n      }\n      else\n      {\n        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Prev;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          Horz = Result;\n          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Next;\n          if (Horz.Next.Top.X == Result.Prev.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Next;\n          }\n          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n            Result = Horz.Next;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Prev;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Prev;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Prev;\n        //move to the edge just beyond current bound\n      }\n\n    return Result;\n  };\n\n  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n  {\n    if (use_lines)\n    {\n      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n    }\n    else\n    {\n      if (!Closed)\n        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n    }\n    var highI = pg.length - 1;\n    if (Closed)\n      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n    --highI;\n    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n    --highI;\n    if ((Closed && highI < 2) || (!Closed && highI < 1))\n      return false;\n    //create a new edge array ...\n    var edges = new Array();\n    for (var i = 0; i <= highI; i++)\n      edges.push(new ClipperLib.TEdge());\n    var IsFlat = true;\n    //1. Basic (first) edge initialization ...\n\n    //edges[1].Curr = pg[1];\n    edges[1].Curr.X = pg[1].X;\n    edges[1].Curr.Y = pg[1].Y;\n\n    var $1 = {Value: this.m_UseFullRange};\n    this.RangeTest(pg[0], $1);\n    this.m_UseFullRange = $1.Value;\n\n    $1.Value = this.m_UseFullRange;\n    this.RangeTest(pg[highI], $1);\n    this.m_UseFullRange = $1.Value;\n\n    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n    for (var i = highI - 1; i >= 1; --i)\n    {\n      $1.Value = this.m_UseFullRange;\n      this.RangeTest(pg[i], $1);\n      this.m_UseFullRange = $1.Value;\n\n      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n    }\n\n    var eStart = edges[0];\n    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n    var E = eStart,\n      eLoopStop = eStart;\n    for (;;)\n    {\n    //console.log(E.Next, eStart);\n    \t//nb: allows matching start and end points when not Closed ...\n      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n      {\n        if (E == E.Next)\n          break;\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        eLoopStop = E;\n        continue;\n      }\n      if (E.Prev == E.Next)\n        break;\n      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n      {\n        //Collinear edges are allowed for open paths but in closed paths\n        //the default is to merge adjacent collinear edges into a single edge.\n        //However, if the PreserveCollinear property is enabled, only overlapping\n        //collinear edges (ie spikes) will be removed from closed paths.\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        E = E.Prev;\n        eLoopStop = E;\n        continue;\n      }\n      E = E.Next;\n      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n    }\n    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n      return false;\n    if (!Closed)\n    {\n      this.m_HasOpenPaths = true;\n      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n    }\n    //3. Do second stage of edge initialization ...\n    E = eStart;\n    do {\n      this.InitEdge2(E, polyType);\n      E = E.Next;\n      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n        IsFlat = false;\n    }\n    while (E != eStart)\n    //4. Finally, add edge bounds to LocalMinima list ...\n    //Totally flat paths must be handled differently when adding them\n    //to LocalMinima list to avoid endless loops etc ...\n    if (IsFlat)\n    {\n      if (Closed)\n        return false;\n      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n      if (E.Prev.Bot.X < E.Prev.Top.X)\n        this.ReverseHorizontal(E.Prev);\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      locMin.RightBound.WindDelta = 0;\n      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n      {\n        E.NextInLML = E.Next;\n        if (E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        E = E.Next;\n      }\n      this.InsertLocalMinima(locMin);\n      this.m_edges.push(edges);\n      return true;\n    }\n    this.m_edges.push(edges);\n    var leftBoundIsForward;\n    var EMin = null;\n\n\t\t//workaround to avoid an endless loop in the while loop below when\n    //open paths have matching start and end points ...\n    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n    \tE = E.Next;\n\n    for (;;)\n    {\n      E = this.FindNextLocMin(E);\n      if (E == EMin)\n        break;\n      else if (EMin == null)\n        EMin = E;\n      //E and E.Prev now share a local minima (left aligned if horizontal).\n      //Compare their slopes to find which starts which bound ...\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      if (E.Dx < E.Prev.Dx)\n      {\n        locMin.LeftBound = E.Prev;\n        locMin.RightBound = E;\n        leftBoundIsForward = false;\n        //Q.nextInLML = Q.prev\n      }\n      else\n      {\n        locMin.LeftBound = E;\n        locMin.RightBound = E.Prev;\n        leftBoundIsForward = true;\n        //Q.nextInLML = Q.next\n      }\n      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      if (!Closed)\n        locMin.LeftBound.WindDelta = 0;\n      else if (locMin.LeftBound.Next == locMin.RightBound)\n        locMin.LeftBound.WindDelta = -1;\n      else\n        locMin.LeftBound.WindDelta = 1;\n      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n      \tE = this.ProcessBound(E, leftBoundIsForward);\n      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.LeftBound = null;\n      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.RightBound = null;\n      this.InsertLocalMinima(locMin);\n      if (!leftBoundIsForward)\n        E = E2;\n    }\n    return true;\n  };\n  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n  {\n    //  console.log(\"-------------------------------------------\");\n    //  console.log(JSON.stringify(ppg));\n    var result = false;\n    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n      if (this.AddPath(ppg[i], polyType, closed))\n        result = true;\n    return result;\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n  {\n    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\n   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n   return false;\n\n    else if (pt1.X != pt3.X)\n      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n    else\n      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n  };\n  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n  {\n    //removes e from double_linked_list (but without removing from memory)\n    e.Prev.Next = e.Next;\n    e.Next.Prev = e.Prev;\n    var result = e.Next;\n    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n    return result;\n  };\n  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n  {\n    e.Delta.X = (e.Top.X - e.Bot.X);\n    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n  };\n  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n  {\n    if (this.m_MinimaList === null)\n    {\n      this.m_MinimaList = newLm;\n    }\n    else if (newLm.Y >= this.m_MinimaList.Y)\n    {\n      newLm.Next = this.m_MinimaList;\n      this.m_MinimaList = newLm;\n    }\n    else\n    {\n      var tmpLm = this.m_MinimaList;\n      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n        tmpLm = tmpLm.Next;\n      newLm.Next = tmpLm.Next;\n      tmpLm.Next = newLm;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n  {\n    if (this.m_CurrentLM === null)\n      return;\n    this.m_CurrentLM = this.m_CurrentLM.Next;\n  };\n  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n  {\n    //swap horizontal edges' top and bottom x's so they follow the natural\n    //progression of the bounds - ie so their xbots will align with the\n    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n    var tmp = e.Top.X;\n    e.Top.X = e.Bot.X;\n    e.Bot.X = tmp;\n    if (use_xyz)\n    {\n      tmp = e.Top.Z;\n      e.Top.Z = e.Bot.Z;\n      e.Bot.Z = tmp;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.Reset = function ()\n  {\n    this.m_CurrentLM = this.m_MinimaList;\n    if (this.m_CurrentLM == null)\n      return;\n    //ie nothing to process\n    //reset all edges ...\n    var lm = this.m_MinimaList;\n    while (lm != null)\n    {\n      var e = lm.LeftBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esLeft;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      e = lm.RightBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esRight;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n  {\n    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n    this.m_PolyOuts = null;\n    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = null;\n    this.m_IntersectNodeComparer = null;\n    this.m_ExecuteLocked = false;\n    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_Joins = null;\n    this.m_GhostJoins = null;\n    this.m_UsingPolyTree = false;\n    this.ReverseSolution = false;\n    this.StrictlySimple = false;\n    ClipperLib.ClipperBase.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = new Array();\n    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n    this.m_ExecuteLocked = false;\n    this.m_UsingPolyTree = false;\n    this.m_PolyOuts = new Array();\n    this.m_Joins = new Array();\n    this.m_GhostJoins = new Array();\n    this.ReverseSolution = (1 & InitOptions) !== 0;\n    this.StrictlySimple = (2 & InitOptions) !== 0;\n    this.PreserveCollinear = (4 & InitOptions) !== 0;\n    if (use_xyz)\n    {\n      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n    }\n  };\n  ClipperLib.Clipper.ioReverseSolution = 1;\n  ClipperLib.Clipper.ioStrictlySimple = 2;\n  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\n  ClipperLib.Clipper.prototype.Clear = function ()\n  {\n    if (this.m_edges.length === 0)\n      return;\n    //avoids problems with ClipperBase destructor\n    this.DisposeAllPolyPts();\n    ClipperLib.ClipperBase.prototype.Clear.call(this);\n  };\n\n  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n  {\n    while (this.m_Scanbeam !== null)\n    {\n      var sb2 = this.m_Scanbeam.Next;\n      this.m_Scanbeam = null;\n      this.m_Scanbeam = sb2;\n    }\n  };\n  ClipperLib.Clipper.prototype.Reset = function ()\n  {\n    ClipperLib.ClipperBase.prototype.Reset.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n\n    var lm = this.m_MinimaList;\n    while (lm !== null)\n    {\n      this.InsertScanbeam(lm.Y);\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n  {\n    if (this.m_Scanbeam === null)\n    {\n      this.m_Scanbeam = new ClipperLib.Scanbeam();\n      this.m_Scanbeam.Next = null;\n      this.m_Scanbeam.Y = Y;\n    }\n    else if (Y > this.m_Scanbeam.Y)\n    {\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = this.m_Scanbeam;\n      this.m_Scanbeam = newSb;\n    }\n    else\n    {\n      var sb2 = this.m_Scanbeam;\n      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n        sb2 = sb2.Next;\n      if (Y == sb2.Y)\n        return;\n      //ie ignores duplicates\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = sb2.Next;\n      sb2.Next = newSb;\n    }\n  };\n  // ************************************\n  ClipperLib.Clipper.prototype.Execute = function ()\n  {\n    var a = arguments,\n      alen = a.length,\n      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        solution = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      if (this.m_HasOpenPaths)\n        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n      this.m_ExecuteLocked = true;\n      ClipperLib.Clear(solution);\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = false;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult(solution);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        polytree = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      this.m_ExecuteLocked = true;\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = true;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult2(polytree);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n    {\n      var clipType = a[0],\n        solution = a[1];\n      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n    {\n      var clipType = a[0],\n        polytree = a[1];\n      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n  {\n    //skip if an outermost polygon or\n    //already already points to the correct FirstLeft ...\n    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n      return;\n    var orfl = outRec.FirstLeft;\n    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n      orfl = orfl.FirstLeft;\n    outRec.FirstLeft = orfl;\n  };\n  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n  {\n    try\n    {\n      this.Reset();\n      if (this.m_CurrentLM === null)\n        return false;\n      var botY = this.PopScanbeam();\n      do {\n        this.InsertLocalMinimaIntoAEL(botY);\n        ClipperLib.Clear(this.m_GhostJoins);\n        this.ProcessHorizontals(false);\n        if (this.m_Scanbeam === null)\n          break;\n        var topY = this.PopScanbeam();\n        if (!this.ProcessIntersections(topY)) return false;\n\n        this.ProcessEdgesAtTopOfScanbeam(topY);\n        botY = topY;\n      }\n      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n      //fix orientations ...\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts === null || outRec.IsOpen)\n          continue;\n        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n          this.ReversePolyPtLinks(outRec.Pts);\n      }\n      this.JoinCommonEdges();\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts !== null && !outRec.IsOpen)\n          this.FixupOutPolygon(outRec);\n      }\n      if (this.StrictlySimple)\n        this.DoSimplePolygons();\n      return true;\n    }\n    finally\n    {\n      ClipperLib.Clear(this.m_Joins);\n      ClipperLib.Clear(this.m_GhostJoins);\n    }\n  };\n  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n  {\n    var Y = this.m_Scanbeam.Y;\n    this.m_Scanbeam = this.m_Scanbeam.Next;\n    return Y;\n  };\n\n  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n      this.DisposeOutRec(i);\n    ClipperLib.Clear(this.m_PolyOuts);\n  };\n  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n  {\n    var outRec = this.m_PolyOuts[index];\n    outRec.Pts = null;\n    outRec = null;\n    this.m_PolyOuts[index] = null;\n  };\n\n  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op1;\n    j.OutPt2 = Op2;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_Joins.push(j);\n  };\n  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_GhostJoins.push(j);\n  };\n  if (use_xyz)\n  {\n    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n    {\n      if (this.ZFillFunction !== null)\n      {\n        if (pt.Z != 0 || this.ZFillFunction === null) return;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n      }\n    };\n\n    //------------------------------------------------------------------------------\n  }\n\n  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n  {\n    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n    {\n      var lb = this.m_CurrentLM.LeftBound;\n      var rb = this.m_CurrentLM.RightBound;\n      this.PopLocalMinima();\n      var Op1 = null;\n      if (lb === null)\n      {\n        this.InsertEdgeIntoAEL(rb, null);\n        this.SetWindingCount(rb);\n        if (this.IsContributing(rb))\n          Op1 = this.AddOutPt(rb, rb.Bot);\n      }\n      else if (rb == null)\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.SetWindingCount(lb);\n        if (this.IsContributing(lb))\n          Op1 = this.AddOutPt(lb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      else\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.InsertEdgeIntoAEL(rb, lb);\n        this.SetWindingCount(lb);\n        rb.WindCnt = lb.WindCnt;\n        rb.WindCnt2 = lb.WindCnt2;\n        if (this.IsContributing(lb))\n          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      if (rb != null)\n      {\n        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n          this.AddEdgeToSEL(rb);\n        else\n          this.InsertScanbeam(rb.Top.Y);\n      }\n      if (lb == null || rb == null) continue;\n      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n      {\n        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n        {\n          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n          //the 'ghost' join to a real join ready for later ...\n          var j = this.m_GhostJoins[i];\n\n\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n        }\n      }\n      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n        lb.PrevInAEL.OutIdx >= 0 &&\n        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n      {\n        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n        this.AddJoin(Op1, Op2, lb.Top);\n      }\n      if (lb.NextInAEL != rb)\n      {\n        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n        {\n          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n          this.AddJoin(Op1, Op2, rb.Top);\n        }\n        var e = lb.NextInAEL;\n        if (e !== null)\n          while (e != rb)\n          {\n            //nb: For calculating winding counts etc, IntersectEdges() assumes\n            //that param1 will be to the right of param2 ABOVE the intersection ...\n            this.IntersectEdges(rb, e, lb.Curr, false);\n            //order important here\n            e = e.NextInAEL;\n          }\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n  {\n    if (this.m_ActiveEdges === null)\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = null;\n      this.m_ActiveEdges = edge;\n    }\n    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = this.m_ActiveEdges;\n      this.m_ActiveEdges.PrevInAEL = edge;\n      this.m_ActiveEdges = edge;\n    }\n    else\n    {\n      if (startEdge === null)\n        startEdge = this.m_ActiveEdges;\n      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n        startEdge = startEdge.NextInAEL;\n      edge.NextInAEL = startEdge.NextInAEL;\n      if (startEdge.NextInAEL !== null)\n        startEdge.NextInAEL.PrevInAEL = edge;\n      edge.PrevInAEL = startEdge;\n      startEdge.NextInAEL = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n  {\n    if (e2.Curr.X == e1.Curr.X)\n    {\n      if (e2.Top.Y > e1.Top.Y)\n        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n      else\n        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n    }\n    else\n      return e2.Curr.X < e1.Curr.X;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n  {\n    var pft, pft2;\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      pft = this.m_SubjFillType;\n      pft2 = this.m_ClipFillType;\n    }\n    else\n    {\n      pft = this.m_ClipFillType;\n      pft2 = this.m_SubjFillType;\n    }\n    switch (pft)\n    {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftNonZero:\n      if (Math.abs(edge.WindCnt) != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftPositive:\n      if (edge.WindCnt != 1)\n        return false;\n      break;\n    default:\n      if (edge.WindCnt != -1)\n        return false;\n      break;\n    }\n    switch (this.m_ClipType)\n    {\n    case ClipperLib.ClipType.ctIntersection:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 !== 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 > 0);\n      default:\n        return (edge.WindCnt2 < 0);\n      }\n    case ClipperLib.ClipType.ctUnion:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 === 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 <= 0);\n      default:\n        return (edge.WindCnt2 >= 0);\n      }\n    case ClipperLib.ClipType.ctDifference:\n      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 !== 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 > 0);\n        default:\n          return (edge.WindCnt2 < 0);\n        }\n    case ClipperLib.ClipType.ctXor:\n      if (edge.WindDelta === 0)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        return true;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n  {\n    var e = edge.PrevInAEL;\n    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n      e = e.PrevInAEL;\n    if (e === null)\n    {\n      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      edge.WindCnt2 = 0;\n      e = this.m_ActiveEdges;\n      //ie get ready to calc WindCnt2\n    }\n    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n    {\n      edge.WindCnt = 1;\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else if (this.IsEvenOddFillType(edge))\n    {\n      //EvenOdd filling ...\n      if (edge.WindDelta === 0)\n      {\n        //are we inside a subj polygon ...\n        var Inside = true;\n        var e2 = e.PrevInAEL;\n        while (e2 !== null)\n        {\n          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n            Inside = !Inside;\n          e2 = e2.PrevInAEL;\n        }\n        edge.WindCnt = (Inside ? 0 : 1);\n      }\n      else\n      {\n        edge.WindCnt = edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      if (e.WindCnt * e.WindDelta < 0)\n      {\n        //prev edge is 'decreasing' WindCount (WC) toward zero\n        //so we're outside the previous polygon ...\n        if (Math.abs(e.WindCnt) > 1)\n        {\n          //outside prev poly but still inside another.\n          //when reversing direction of prev poly use the same WC\n          if (e.WindDelta * edge.WindDelta < 0)\n            edge.WindCnt = e.WindCnt;\n          else\n            edge.WindCnt = e.WindCnt + edge.WindDelta;\n        }\n        else\n          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      }\n      else\n      {\n        //prev edge is 'increasing' WindCount (WC) away from zero\n        //so we're inside the previous polygon ...\n        if (edge.WindDelta === 0)\n          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n        else if (e.WindDelta * edge.WindDelta < 0)\n          edge.WindCnt = e.WindCnt;\n        else\n          edge.WindCnt = e.WindCnt + edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    //update WindCnt2 ...\n    if (this.IsEvenOddAltFillType(edge))\n    {\n      //EvenOdd filling ...\n      while (e != edge)\n      {\n        if (e.WindDelta !== 0)\n          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n        e = e.NextInAEL;\n      }\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      while (e != edge)\n      {\n        edge.WindCnt2 += e.WindDelta;\n        e = e.NextInAEL;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n  {\n    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n    //However, we don't need to worry about order with horizontal edge processing.\n    if (this.m_SortedEdges === null)\n    {\n      this.m_SortedEdges = edge;\n      edge.PrevInSEL = null;\n      edge.NextInSEL = null;\n    }\n    else\n    {\n      edge.NextInSEL = this.m_SortedEdges;\n      edge.PrevInSEL = null;\n      this.m_SortedEdges.PrevInSEL = edge;\n      this.m_SortedEdges = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n  {\n    var e = this.m_ActiveEdges;\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n  {\n    //check that one or other edge hasn't already been removed from AEL ...\n    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n      return;\n    if (edge1.NextInAEL == edge2)\n    {\n      var next = edge2.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge1;\n      var prev = edge1.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      edge2.NextInAEL = edge1;\n      edge1.PrevInAEL = edge2;\n      edge1.NextInAEL = next;\n    }\n    else if (edge2.NextInAEL == edge1)\n    {\n      var next = edge1.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge2;\n      var prev = edge2.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge1;\n      edge1.PrevInAEL = prev;\n      edge1.NextInAEL = edge2;\n      edge2.PrevInAEL = edge1;\n      edge2.NextInAEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInAEL;\n      var prev = edge1.PrevInAEL;\n      edge1.NextInAEL = edge2.NextInAEL;\n      if (edge1.NextInAEL !== null)\n        edge1.NextInAEL.PrevInAEL = edge1;\n      edge1.PrevInAEL = edge2.PrevInAEL;\n      if (edge1.PrevInAEL !== null)\n        edge1.PrevInAEL.NextInAEL = edge1;\n      edge2.NextInAEL = next;\n      if (edge2.NextInAEL !== null)\n        edge2.NextInAEL.PrevInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      if (edge2.PrevInAEL !== null)\n        edge2.PrevInAEL.NextInAEL = edge2;\n    }\n    if (edge1.PrevInAEL === null)\n      this.m_ActiveEdges = edge1;\n    else if (edge2.PrevInAEL === null)\n      this.m_ActiveEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n  {\n    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n      return;\n    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n      return;\n    if (edge1.NextInSEL == edge2)\n    {\n      var next = edge2.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge1;\n      var prev = edge1.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      edge2.NextInSEL = edge1;\n      edge1.PrevInSEL = edge2;\n      edge1.NextInSEL = next;\n    }\n    else if (edge2.NextInSEL == edge1)\n    {\n      var next = edge1.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge2;\n      var prev = edge2.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge1;\n      edge1.PrevInSEL = prev;\n      edge1.NextInSEL = edge2;\n      edge2.PrevInSEL = edge1;\n      edge2.NextInSEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInSEL;\n      var prev = edge1.PrevInSEL;\n      edge1.NextInSEL = edge2.NextInSEL;\n      if (edge1.NextInSEL !== null)\n        edge1.NextInSEL.PrevInSEL = edge1;\n      edge1.PrevInSEL = edge2.PrevInSEL;\n      if (edge1.PrevInSEL !== null)\n        edge1.PrevInSEL.NextInSEL = edge1;\n      edge2.NextInSEL = next;\n      if (edge2.NextInSEL !== null)\n        edge2.NextInSEL.PrevInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      if (edge2.PrevInSEL !== null)\n        edge2.PrevInSEL.NextInSEL = edge2;\n    }\n    if (edge1.PrevInSEL === null)\n      this.m_SortedEdges = edge1;\n    else if (edge2.PrevInSEL === null)\n      this.m_SortedEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n  {\n    this.AddOutPt(e1, pt);\n    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n    if (e1.OutIdx == e2.OutIdx)\n    {\n      e1.OutIdx = -1;\n      e2.OutIdx = -1;\n    }\n    else if (e1.OutIdx < e2.OutIdx)\n      this.AppendPolygon(e1, e2);\n    else\n      this.AppendPolygon(e2, e1);\n  };\n  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n  {\n    var result;\n    var e, prevE;\n    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n    {\n      result = this.AddOutPt(e1, pt);\n      e2.OutIdx = e1.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esLeft;\n      e2.Side = ClipperLib.EdgeSide.esRight;\n      e = e1;\n      if (e.PrevInAEL == e2)\n        prevE = e2.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    else\n    {\n      result = this.AddOutPt(e2, pt);\n      e1.OutIdx = e2.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esRight;\n      e2.Side = ClipperLib.EdgeSide.esLeft;\n      e = e2;\n      if (e.PrevInAEL == e1)\n        prevE = e1.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n    {\n      var outPt = this.AddOutPt(prevE, pt);\n      this.AddJoin(result, outPt, e.Top);\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n  {\n    var result = new ClipperLib.OutRec();\n    result.Idx = -1;\n    result.IsHole = false;\n    result.IsOpen = false;\n    result.FirstLeft = null;\n    result.Pts = null;\n    result.BottomPt = null;\n    result.PolyNode = null;\n    this.m_PolyOuts.push(result);\n    result.Idx = this.m_PolyOuts.length - 1;\n    return result;\n  };\n  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n  {\n    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n    if (e.OutIdx < 0)\n    {\n      var outRec = this.CreateOutRec();\n      outRec.IsOpen = (e.WindDelta === 0);\n      var newOp = new ClipperLib.OutPt();\n      outRec.Pts = newOp;\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = newOp;\n      newOp.Prev = newOp;\n      if (!outRec.IsOpen)\n        this.SetHoleState(e, outRec);\n      e.OutIdx = outRec.Idx;\n      //nb: do this after SetZ !\n      return newOp;\n    }\n    else\n    {\n      var outRec = this.m_PolyOuts[e.OutIdx];\n      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n      var op = outRec.Pts;\n      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n        return op;\n      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n        return op.Prev;\n      var newOp = new ClipperLib.OutPt();\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = op;\n      newOp.Prev = op.Prev;\n      newOp.Prev.Next = newOp;\n      op.Prev = newOp;\n      if (ToFront)\n        outRec.Pts = newOp;\n      return newOp;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n  {\n    var tmp = new ClipperLib.IntPoint(pt1.Value);\n    //pt1.Value = pt2.Value;\n    pt1.Value.X = pt2.Value.X;\n    pt1.Value.Y = pt2.Value.Y;\n    //pt2.Value = tmp;\n    pt2.Value.X = tmp.X;\n    pt2.Value.Y = tmp.Y;\n  };\n  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t{\n\t\tvar tmp;\n\t\tif (seg1a > seg1b)\n\t\t{\n\t\t\ttmp = seg1a;\n\t\t\tseg1a = seg1b;\n\t\t\tseg1b = tmp;\n\t\t}\n\t\tif (seg2a > seg2b)\n\t\t{\n\t\t\ttmp = seg2a;\n\t\t\tseg2a = seg2b;\n\t\t\tseg2b = tmp;\n\t\t}\n\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t}\n\n  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n  {\n    var isHole = false;\n    var e2 = e.PrevInAEL;\n    while (e2 !== null)\n    {\n      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n      {\n        isHole = !isHole;\n        if (outRec.FirstLeft === null)\n          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n      }\n      e2 = e2.PrevInAEL;\n    }\n    if (isHole)\n      outRec.IsHole = true;\n  };\n  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n  {\n    if (pt1.Y == pt2.Y)\n      return ClipperLib.ClipperBase.horizontal;\n    else\n      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n  };\n  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n  {\n    var p = btmPt1.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Prev;\n    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt1.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Next;\n    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt2.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Prev;\n    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    p = btmPt2.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Next;\n    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n  };\n  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n  {\n    var dups = null;\n    var p = pp.Next;\n    while (p != pp)\n    {\n      if (p.Pt.Y > pp.Pt.Y)\n      {\n        pp = p;\n        dups = null;\n      }\n      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n      {\n        if (p.Pt.X < pp.Pt.X)\n        {\n          dups = null;\n          pp = p;\n        }\n        else\n        {\n          if (p.Next != pp && p.Prev != pp)\n            dups = p;\n        }\n      }\n      p = p.Next;\n    }\n    if (dups !== null)\n    {\n      //there appears to be at least 2 vertices at bottomPt so ...\n      while (dups != p)\n      {\n        if (!this.FirstIsBottomPt(p, dups))\n          pp = dups;\n        dups = dups.Next;\n        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n          dups = dups.Next;\n      }\n    }\n    return pp;\n  };\n  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n  {\n    //work out which polygon fragment has the correct hole state ...\n    if (outRec1.BottomPt === null)\n      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n    if (outRec2.BottomPt === null)\n      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n    var bPt1 = outRec1.BottomPt;\n    var bPt2 = outRec2.BottomPt;\n    if (bPt1.Pt.Y > bPt2.Pt.Y)\n      return outRec1;\n    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n      return outRec2;\n    else if (bPt1.Pt.X < bPt2.Pt.X)\n      return outRec1;\n    else if (bPt1.Pt.X > bPt2.Pt.X)\n      return outRec2;\n    else if (bPt1.Next == bPt1)\n      return outRec2;\n    else if (bPt2.Next == bPt2)\n      return outRec1;\n    else if (this.FirstIsBottomPt(bPt1, bPt2))\n      return outRec1;\n    else\n      return outRec2;\n  };\n  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n  {\n    do {\n      outRec1 = outRec1.FirstLeft;\n      if (outRec1 == outRec2)\n        return true;\n    }\n    while (outRec1 !== null)\n    return false;\n  };\n  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n  {\n    var outrec = this.m_PolyOuts[idx];\n    while (outrec != this.m_PolyOuts[outrec.Idx])\n      outrec = this.m_PolyOuts[outrec.Idx];\n    return outrec;\n  };\n  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n  {\n    //get the start and ends of both output polygons ...\n    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n    var holeStateRec;\n    if (this.Param1RightOfParam2(outRec1, outRec2))\n      holeStateRec = outRec2;\n    else if (this.Param1RightOfParam2(outRec2, outRec1))\n      holeStateRec = outRec1;\n    else\n      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n    var p1_lft = outRec1.Pts;\n    var p1_rt = p1_lft.Prev;\n    var p2_lft = outRec2.Pts;\n    var p2_rt = p2_lft.Prev;\n    var side;\n    //join e2 poly onto e1 poly and delete pointers to e2 ...\n    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n      {\n        //z y x a b c\n        this.ReversePolyPtLinks(p2_lft);\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        outRec1.Pts = p2_rt;\n      }\n      else\n      {\n        //x y z a b c\n        p2_rt.Next = p1_lft;\n        p1_lft.Prev = p2_rt;\n        p2_lft.Prev = p1_rt;\n        p1_rt.Next = p2_lft;\n        outRec1.Pts = p2_lft;\n      }\n      side = ClipperLib.EdgeSide.esLeft;\n    }\n    else\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esRight)\n      {\n        //a b c z y x\n        this.ReversePolyPtLinks(p2_lft);\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n      }\n      else\n      {\n        //a b c x y z\n        p1_rt.Next = p2_lft;\n        p2_lft.Prev = p1_rt;\n        p1_lft.Prev = p2_rt;\n        p2_rt.Next = p1_lft;\n      }\n      side = ClipperLib.EdgeSide.esRight;\n    }\n    outRec1.BottomPt = null;\n    if (holeStateRec == outRec2)\n    {\n      if (outRec2.FirstLeft != outRec1)\n        outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec1.IsHole = outRec2.IsHole;\n    }\n    outRec2.Pts = null;\n    outRec2.BottomPt = null;\n    outRec2.FirstLeft = outRec1;\n    var OKIdx = e1.OutIdx;\n    var ObsoleteIdx = e2.OutIdx;\n    e1.OutIdx = -1;\n    //nb: safe because we only get here via AddLocalMaxPoly\n    e2.OutIdx = -1;\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (e.OutIdx == ObsoleteIdx)\n      {\n        e.OutIdx = OKIdx;\n        e.Side = side;\n        break;\n      }\n      e = e.NextInAEL;\n    }\n    outRec2.Idx = outRec1.Idx;\n  };\n  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n  {\n    if (pp === null)\n      return;\n    var pp1;\n    var pp2;\n    pp1 = pp;\n    do {\n      pp2 = pp1.Next;\n      pp1.Next = pp1.Prev;\n      pp1.Prev = pp2;\n      pp1 = pp2;\n    }\n    while (pp1 != pp)\n  };\n  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n  {\n    var side = edge1.Side;\n    edge1.Side = edge2.Side;\n    edge2.Side = side;\n  };\n  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n  {\n    var outIdx = edge1.OutIdx;\n    edge1.OutIdx = edge2.OutIdx;\n    edge2.OutIdx = outIdx;\n  };\n  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n  {\n    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n    //e2 in AEL except when e1 is being inserted at the intersection point ...\n    var e1Contributing = (e1.OutIdx >= 0);\n    var e2Contributing = (e2.OutIdx >= 0);\n\n    if (use_xyz)\n    \tthis.SetZ(pt, e1, e2);\n\n    if (use_lines)\n    {\n      //if either edge is on an OPEN path ...\n      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n      {\n        //ignore subject-subject open path intersections UNLESS they\n        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n        //if intersecting a subj line with a subj poly ...\n        else if (e1.PolyTyp == e2.PolyTyp &&\n          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n        {\n          if (e1.WindDelta === 0)\n          {\n            if (e2Contributing)\n            {\n              this.AddOutPt(e1, pt);\n              if (e1Contributing)\n                e1.OutIdx = -1;\n            }\n          }\n          else\n          {\n            if (e1Contributing)\n            {\n              this.AddOutPt(e2, pt);\n              if (e2Contributing)\n                e2.OutIdx = -1;\n            }\n          }\n        }\n        else if (e1.PolyTyp != e2.PolyTyp)\n        {\n          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n          {\n            this.AddOutPt(e1, pt);\n            if (e1Contributing)\n              e1.OutIdx = -1;\n          }\n          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n          {\n            this.AddOutPt(e2, pt);\n            if (e2Contributing)\n              e2.OutIdx = -1;\n          }\n        }\n        return;\n      }\n    }\n    //update winding counts...\n    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n    if (e1.PolyTyp == e2.PolyTyp)\n    {\n      if (this.IsEvenOddFillType(e1))\n      {\n        var oldE1WindCnt = e1.WindCnt;\n        e1.WindCnt = e2.WindCnt;\n        e2.WindCnt = oldE1WindCnt;\n      }\n      else\n      {\n        if (e1.WindCnt + e2.WindDelta === 0)\n          e1.WindCnt = -e1.WindCnt;\n        else\n          e1.WindCnt += e2.WindDelta;\n        if (e2.WindCnt - e1.WindDelta === 0)\n          e2.WindCnt = -e2.WindCnt;\n        else\n          e2.WindCnt -= e1.WindDelta;\n      }\n    }\n    else\n    {\n      if (!this.IsEvenOddFillType(e2))\n        e1.WindCnt2 += e2.WindDelta;\n      else\n        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n      if (!this.IsEvenOddFillType(e1))\n        e2.WindCnt2 -= e1.WindDelta;\n      else\n        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n    }\n    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e1FillType = this.m_SubjFillType;\n      e1FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e1FillType = this.m_ClipFillType;\n      e1FillType2 = this.m_SubjFillType;\n    }\n    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e2FillType = this.m_SubjFillType;\n      e2FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e2FillType = this.m_ClipFillType;\n      e2FillType2 = this.m_SubjFillType;\n    }\n    var e1Wc, e2Wc;\n    switch (e1FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e1Wc = e1.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e1Wc = -e1.WindCnt;\n      break;\n    default:\n      e1Wc = Math.abs(e1.WindCnt);\n      break;\n    }\n    switch (e2FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e2Wc = e2.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e2Wc = -e2.WindCnt;\n      break;\n    default:\n      e2Wc = Math.abs(e2.WindCnt);\n      break;\n    }\n    if (e1Contributing && e2Contributing)\n    {\n\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t{\n\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t}\n      else\n      {\n        this.AddOutPt(e1, pt);\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e1Contributing)\n    {\n      if (e2Wc === 0 || e2Wc == 1)\n      {\n        this.AddOutPt(e1, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e2Contributing)\n    {\n      if (e1Wc === 0 || e1Wc == 1)\n      {\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n    {\n      //neither edge is currently contributing ...\n      var e1Wc2, e2Wc2;\n      switch (e1FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e1Wc2 = e1.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e1Wc2 = -e1.WindCnt2;\n        break;\n      default:\n        e1Wc2 = Math.abs(e1.WindCnt2);\n        break;\n      }\n      switch (e2FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e2Wc2 = e2.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e2Wc2 = -e2.WindCnt2;\n        break;\n      default:\n        e2Wc2 = Math.abs(e2.WindCnt2);\n        break;\n      }\n      if (e1.PolyTyp != e2.PolyTyp)\n      {\n        this.AddLocalMinPoly(e1, e2, pt);\n      }\n      else if (e1Wc == 1 && e2Wc == 1)\n        switch (this.m_ClipType)\n        {\n        case ClipperLib.ClipType.ctIntersection:\n          if (e1Wc2 > 0 && e2Wc2 > 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctUnion:\n          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctDifference:\n          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctXor:\n          this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        }\n      else\n        ClipperLib.Clipper.SwapSides(e1, e2);\n    }\n  };\n  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n  {\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n      return;\n    //already deleted\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = AelNext;\n    else\n      this.m_ActiveEdges = AelNext;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = AelPrev;\n    e.NextInAEL = null;\n    e.PrevInAEL = null;\n  };\n  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n  {\n    var SelPrev = e.PrevInSEL;\n    var SelNext = e.NextInSEL;\n    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n      return;\n    //already deleted\n    if (SelPrev !== null)\n      SelPrev.NextInSEL = SelNext;\n    else\n      this.m_SortedEdges = SelNext;\n    if (SelNext !== null)\n      SelNext.PrevInSEL = SelPrev;\n    e.NextInSEL = null;\n    e.PrevInSEL = null;\n  };\n  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n  {\n    if (e.NextInLML === null)\n      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    e.NextInLML.OutIdx = e.OutIdx;\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = e.NextInLML;\n    else\n      this.m_ActiveEdges = e.NextInLML;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = e.NextInLML;\n    e.NextInLML.Side = e.Side;\n    e.NextInLML.WindDelta = e.WindDelta;\n    e.NextInLML.WindCnt = e.WindCnt;\n    e.NextInLML.WindCnt2 = e.WindCnt2;\n    e = e.NextInLML;\n    //    e.Curr = e.Bot;\n    e.Curr.X = e.Bot.X;\n    e.Curr.Y = e.Bot.Y;\n    e.PrevInAEL = AelPrev;\n    e.NextInAEL = AelNext;\n    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n      this.InsertScanbeam(e.Top.Y);\n    return e;\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n  {\n    var horzEdge = this.m_SortedEdges;\n    while (horzEdge !== null)\n    {\n      this.DeleteFromSEL(horzEdge);\n      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n      horzEdge = this.m_SortedEdges;\n    }\n  };\n  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n  {\n    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n    {\n        $var.Left = HorzEdge.Bot.X;\n        $var.Right = HorzEdge.Top.X;\n        $var.Dir = ClipperLib.Direction.dLeftToRight;\n    }\n    else\n    {\n        $var.Left = HorzEdge.Top.X;\n        $var.Right = HorzEdge.Bot.X;\n        $var.Dir = ClipperLib.Direction.dRightToLeft;\n    }\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n  {\n    var $var = {Dir: null, Left: null, Right: null};\n    this.GetHorzDirection(horzEdge, $var);\n    var dir = $var.Dir;\n    var horzLeft = $var.Left;\n    var horzRight = $var.Right;\n\n    var eLastHorz = horzEdge,\n      eMaxPair = null;\n    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n      eLastHorz = eLastHorz.NextInLML;\n    if (eLastHorz.NextInLML === null)\n      eMaxPair = this.GetMaximaPair(eLastHorz);\n    for (;;)\n    {\n      var IsLastHorz = (horzEdge == eLastHorz);\n      var e = this.GetNextInAEL(horzEdge, dir);\n      while (e !== null)\n      {\n        //Break if we've got to the end of an intermediate horizontal edge ...\n        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n          break;\n        var eNext = this.GetNextInAEL(e, dir);\n        //saves eNext for later\n        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n        {\n          //so far we're still in range of the horizontal Edge  but make sure\n          //we're at the last of consec. horizontals when matching with eMaxPair\n          if (e == eMaxPair && IsLastHorz)\n          {\n\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n            return;\n          }\n          else if (dir == ClipperLib.Direction.dLeftToRight)\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(horzEdge, e, Pt);\n          }\n          else\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(e, horzEdge, Pt);\n          }\n          this.SwapPositionsInAEL(horzEdge, e);\n        }\n        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n          break;\n        e = eNext;\n      }\n      //end while\n      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n      {\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.OutIdx >= 0)\n          this.AddOutPt(horzEdge, horzEdge.Bot);\n\n          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n          this.GetHorzDirection(horzEdge, $var);\n          dir = $var.Dir;\n          horzLeft = $var.Left;\n          horzRight = $var.Right;\n      }\n      else\n        break;\n    }\n    //end for (;;)\n    if (horzEdge.NextInLML !== null)\n    {\n      if (horzEdge.OutIdx >= 0)\n      {\n        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.WindDelta === 0)\n          return;\n        //nb: HorzEdge is no longer horizontal here\n        var ePrev = horzEdge.PrevInAEL;\n        var eNext = horzEdge.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n        {\n          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n        {\n          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n      }\n      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    }\n  \telse\n    {\n      if (horzEdge.OutIdx >= 0)\n        this.AddOutPt(horzEdge, horzEdge.Top);\n      this.DeleteFromAEL(horzEdge);\n    }\n  };\n  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n  {\n    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n  };\n  ClipperLib.Clipper.prototype.IsMinima = function (e)\n  {\n    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n  };\n  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n  {\n    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n  };\n  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n  {\n    return (e.Top.Y == Y && e.NextInLML !== null);\n  };\n  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n  {\n    var result = null;\n    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n      result = e.Next;\n    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n      result = e.Prev;\n    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n      return null;\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n  {\n    if (this.m_ActiveEdges == null)\n      return true;\n    try\n    {\n      this.BuildIntersectList(topY);\n      if (this.m_IntersectList.length == 0)\n        return true;\n      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n        this.ProcessIntersectList();\n      else\n        return false;\n    }\n    catch ($$e2)\n    {\n      this.m_SortedEdges = null;\n      this.m_IntersectList.length = 0;\n      ClipperLib.Error(\"ProcessIntersections error\");\n    }\n    this.m_SortedEdges = null;\n    return true;\n  };\n  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n  {\n    if (this.m_ActiveEdges === null)\n      return;\n    //prepare for sorting ...\n    var e = this.m_ActiveEdges;\n    //console.log(JSON.stringify(JSON.decycle( e )));\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n      e = e.NextInAEL;\n    }\n    //bubblesort ...\n    var isModified = true;\n    while (isModified && this.m_SortedEdges !== null)\n    {\n      isModified = false;\n      e = this.m_SortedEdges;\n      while (e.NextInSEL !== null)\n      {\n        var eNext = e.NextInSEL;\n        var pt = new ClipperLib.IntPoint();\n        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n        if (e.Curr.X > eNext.Curr.X)\n        {\n\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n          var newNode = new ClipperLib.IntersectNode();\n          newNode.Edge1 = e;\n          newNode.Edge2 = eNext;\n          //newNode.Pt = pt;\n          newNode.Pt.X = pt.X;\n          newNode.Pt.Y = pt.Y;\n          this.m_IntersectList.push(newNode);\n          this.SwapPositionsInSEL(e, eNext);\n          isModified = true;\n        }\n        else\n          e = eNext;\n      }\n      if (e.PrevInSEL !== null)\n        e.PrevInSEL.NextInSEL = null;\n      else\n        break;\n    }\n    this.m_SortedEdges = null;\n  };\n  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n  {\n    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n  };\n  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n  {\n    //the following typecast is safe because the differences in Pt.Y will\n    //be limited to the height of the scanbeam.\n    return (node2.Pt.Y - node1.Pt.Y);\n  };\n  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n  {\n    //pre-condition: intersections are sorted bottom-most first.\n    //Now it's crucial that intersections are made only between adjacent edges,\n    //so to ensure this the order of intersections may need adjusting ...\n    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n    this.CopyAELToSEL();\n    var cnt = this.m_IntersectList.length;\n    for (var i = 0; i < cnt; i++)\n    {\n      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n      {\n        var j = i + 1;\n        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n          j++;\n        if (j == cnt)\n          return false;\n        var tmp = this.m_IntersectList[i];\n        this.m_IntersectList[i] = this.m_IntersectList[j];\n        this.m_IntersectList[j] = tmp;\n      }\n      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n  {\n    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n    {\n      var iNode = this.m_IntersectList[i];\n      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n    }\n    this.m_IntersectList.length = 0;\n  };\n  /*\n  --------------------------------\n  Round speedtest: http://jsperf.com/fastest-round\n  --------------------------------\n  */\n  var R1 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n  };\n  var R2 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n  };\n  var R3 = function (a)\n  {\n    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n  };\n  var R4 = function (a)\n  {\n    if (a < 0)\n    {\n      a -= 0.5;\n      return a < -2147483648 ? Math.ceil(a) : a | 0;\n    }\n    else\n    {\n      a += 0.5;\n      return a > 2147483647 ? Math.floor(a) : a | 0;\n    }\n  };\n  if (browser.msie) ClipperLib.Clipper.Round = R1;\n  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n  ClipperLib.Clipper.TopX = function (edge, currentY)\n  {\n    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n    if (currentY == edge.Top.Y)\n      return edge.Top.X;\n    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n  };\n  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n  {\n    ip.X = 0;\n    ip.Y = 0;\n    var b1, b2;\n    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n    //return false but for the edge.Dx value be equal due to double precision rounding.\n    if (edge1.Dx == edge2.Dx)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\treturn;\n    }\n    if (edge1.Delta.X === 0)\n    {\n      ip.X = edge1.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n      {\n        ip.Y = edge2.Bot.Y;\n      }\n      else\n      {\n        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n      }\n    }\n    else if (edge2.Delta.X === 0)\n    {\n      ip.X = edge2.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n      {\n        ip.Y = edge1.Bot.Y;\n      }\n      else\n      {\n        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n      }\n    }\n    else\n    {\n      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n      ip.Y = ClipperLib.Clipper.Round(q);\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n      else\n        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n    }\n    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n    {\n      if (edge1.Top.Y > edge2.Top.Y)\n      {\n        ip.Y = edge1.Top.Y;\n        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n        return ip.X < edge1.Top.X;\n      }\n      else\n        ip.Y = edge2.Top.Y;\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n      else\n        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n    }\n\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\tif (ip.Y > edge1.Curr.Y)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t}\n  };\n\n  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n  {\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n      var IsMaximaEdge = this.IsMaxima(e, topY);\n      if (IsMaximaEdge)\n      {\n        var eMaxPair = this.GetMaximaPair(e);\n        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n      }\n      if (IsMaximaEdge)\n      {\n        var ePrev = e.PrevInAEL;\n        this.DoMaxima(e);\n        if (ePrev === null)\n          e = this.m_ActiveEdges;\n        else\n          e = ePrev.NextInAEL;\n      }\n      else\n      {\n        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n        {\n          e = this.UpdateEdgeIntoAEL(e);\n          if (e.OutIdx >= 0)\n            this.AddOutPt(e, e.Bot);\n          this.AddEdgeToSEL(e);\n        }\n        else\n        {\n          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n          e.Curr.Y = topY;\n        }\n        if (this.StrictlySimple)\n        {\n          var ePrev = e.PrevInAEL;\n          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n            (ePrev.WindDelta !== 0))\n          {\n           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\n\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t}\n\n            var op = this.AddOutPt(ePrev, ip);\n            var op2 = this.AddOutPt(e, ip);\n            this.AddJoin(op, op2, ip);\n            //StrictlySimple (type-3) join\n          }\n        }\n        e = e.NextInAEL;\n      }\n    }\n    //3. Process horizontals at the Top of the scanbeam ...\n    this.ProcessHorizontals(true);\n    //4. Promote intermediate vertices ...\n    e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (this.IsIntermediate(e, topY))\n      {\n        var op = null;\n        if (e.OutIdx >= 0)\n          op = this.AddOutPt(e, e.Top);\n        e = this.UpdateEdgeIntoAEL(e);\n        //if output polygons share an edge, they'll need joining later ...\n        var ePrev = e.PrevInAEL;\n        var eNext = e.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(ePrev, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n          eNext.Curr.Y == e.Bot.Y && op !== null &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(eNext, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n      }\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n  {\n    var eMaxPair = this.GetMaximaPair(e);\n    if (eMaxPair === null)\n    {\n      if (e.OutIdx >= 0)\n        this.AddOutPt(e, e.Top);\n      this.DeleteFromAEL(e);\n      return;\n    }\n    var eNext = e.NextInAEL;\n    var use_lines = true;\n    while (eNext !== null && eNext != eMaxPair)\n    {\n      this.IntersectEdges(e, eNext, e.Top);\n      this.SwapPositionsInAEL(e, eNext);\n      eNext = e.NextInAEL;\n    }\n    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n    {\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n    {\n    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (use_lines && e.WindDelta === 0)\n    {\n      if (e.OutIdx >= 0)\n      {\n        this.AddOutPt(e, e.Top);\n        e.OutIdx = -1;\n      }\n      this.DeleteFromAEL(e);\n      if (eMaxPair.OutIdx >= 0)\n      {\n        this.AddOutPt(eMaxPair, e.Top);\n        eMaxPair.OutIdx = -1;\n      }\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else\n      ClipperLib.Error(\"DoMaxima error\");\n  };\n  ClipperLib.Clipper.ReversePaths = function (polys)\n  {\n    for (var i = 0, len = polys.length; i < len; i++)\n      polys[i].reverse();\n  };\n  ClipperLib.Clipper.Orientation = function (poly)\n  {\n    return ClipperLib.Clipper.Area(poly) >= 0;\n  };\n  ClipperLib.Clipper.prototype.PointCount = function (pts)\n  {\n    if (pts === null)\n      return 0;\n    var result = 0;\n    var p = pts;\n    do {\n      result++;\n      p = p.Next;\n    }\n    while (p != pts)\n    return result;\n  };\n  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n  {\n    ClipperLib.Clear(polyg);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null)\n        continue;\n      var p = outRec.Pts.Prev;\n      var cnt = this.PointCount(p);\n      if (cnt < 2)\n        continue;\n      var pg = new Array(cnt);\n      for (var j = 0; j < cnt; j++)\n      {\n        pg[j] = p.Pt;\n        p = p.Prev;\n      }\n      polyg.push(pg);\n    }\n  };\n  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n  {\n    polytree.Clear();\n    //add each output polygon/contour to polytree ...\n    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      var cnt = this.PointCount(outRec.Pts);\n      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n        continue;\n      this.FixHoleLinkage(outRec);\n      var pn = new ClipperLib.PolyNode();\n      polytree.m_AllPolys.push(pn);\n      outRec.PolyNode = pn;\n      pn.m_polygon.length = cnt;\n      var op = outRec.Pts.Prev;\n      for (var j = 0; j < cnt; j++)\n      {\n        pn.m_polygon[j] = op.Pt;\n        op = op.Prev;\n      }\n    }\n    //fixup PolyNode links etc ...\n    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.PolyNode === null)\n        continue;\n      else if (outRec.IsOpen)\n      {\n        outRec.PolyNode.IsOpen = true;\n        polytree.AddChild(outRec.PolyNode);\n      }\n      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n      else\n        polytree.AddChild(outRec.PolyNode);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n  {\n    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n    //parallel edges by removing the middle vertex.\n    var lastOK = null;\n    outRec.BottomPt = null;\n    var pp = outRec.Pts;\n    for (;;)\n    {\n      if (pp.Prev == pp || pp.Prev == pp.Next)\n      {\n        outRec.Pts = null;\n        return;\n      }\n      //test for duplicate points and collinear edges ...\n      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n      {\n        lastOK = null;\n        pp.Prev.Next = pp.Next;\n        pp.Next.Prev = pp.Prev;\n        pp = pp.Prev;\n      }\n      else if (pp == lastOK)\n        break;\n      else\n      {\n        if (lastOK === null)\n          lastOK = pp;\n        pp = pp.Next;\n      }\n    }\n    outRec.Pts = pp;\n  };\n  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n  {\n    var result = new ClipperLib.OutPt();\n    //result.Pt = outPt.Pt;\n    result.Pt.X = outPt.Pt.X;\n    result.Pt.Y = outPt.Pt.Y;\n    result.Idx = outPt.Idx;\n    if (InsertAfter)\n    {\n      result.Next = outPt.Next;\n      result.Prev = outPt;\n      outPt.Next.Prev = result;\n      outPt.Next = result;\n    }\n    else\n    {\n      result.Prev = outPt.Prev;\n      result.Next = outPt;\n      outPt.Prev.Next = result;\n      outPt.Prev = result;\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n  {\n    if (a1 < a2)\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a1, b1);\n        $val.Right = Math.min(a2, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a1, b2);\n        $val.Right = Math.min(a2, b1);\n      }\n    }\n    else\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a2, b1);\n        $val.Right = Math.min(a1, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a2, b2);\n        $val.Right = Math.min(a1, b1);\n      }\n    }\n    return $val.Left < $val.Right;\n  };\n  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n  {\n    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    if (Dir1 == Dir2)\n      return false;\n    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n    //So, to facilitate this while inserting Op1b and Op2b ...\n    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op1.Next.Pt.X <= Pt.X &&\n        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op1.Next.Pt.X >= Pt.X &&\n        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, DiscardLeft);\n      }\n    }\n    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op2.Next.Pt.X <= Pt.X &&\n        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op2.Next.Pt.X >= Pt.X &&\n        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, DiscardLeft);\n      }\n    }\n    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n    {\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n    }\n    else\n    {\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n  {\n    var op1 = j.OutPt1,\n      op1b = new ClipperLib.OutPt();\n    var op2 = j.OutPt2,\n      op2b = new ClipperLib.OutPt();\n    //There are 3 kinds of joins for output polygons ...\n    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n    //3. StrictlySimple joins where edges touch but are not collinear and where\n    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n    {\n      //Strictly Simple join ...\n\t\t\tif (outRec1 != outRec2) return false;\n\n      op1b = j.OutPt1.Next;\n      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n        op1b = op1b.Next;\n      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n      op2b = j.OutPt2.Next;\n      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n        op2b = op2b.Next;\n      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n      if (reverse1 == reverse2)\n        return false;\n      if (reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n    else if (isHorizontal)\n    {\n      //treat horizontal joins differently to non-horizontal joins since with\n      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n      //may be anywhere along the horizontal edge.\n      op1b = op1;\n      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n        op1 = op1.Prev;\n      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n        op1b = op1b.Next;\n      if (op1b.Next == op1 || op1b.Next == op2)\n        return false;\n      //a flat 'polygon'\n      op2b = op2;\n      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n        op2 = op2.Prev;\n      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n        op2b = op2b.Next;\n      if (op2b.Next == op2 || op2b.Next == op1)\n        return false;\n      //a flat 'polygon'\n      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n      var $val = {Left: null, Right: null};\n      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n        return false;\n      var Left = $val.Left;\n      var Right = $val.Right;\n\n      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n      //on the discard Side as either may still be needed for other joins ...\n      var Pt = new ClipperLib.IntPoint();\n      var DiscardLeftSide;\n      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n      {\n        //Pt = op1.Pt;\n        Pt.X = op1.Pt.X;\n        Pt.Y = op1.Pt.Y;\n        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n      }\n      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n      {\n        //Pt = op2.Pt;\n        Pt.X = op2.Pt.X;\n        Pt.Y = op2.Pt.Y;\n        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n      }\n      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n      {\n        //Pt = op1b.Pt;\n        Pt.X = op1b.Pt.X;\n        Pt.Y = op1b.Pt.Y;\n        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n      }\n      else\n      {\n        //Pt = op2b.Pt;\n        Pt.X = op2b.Pt.X;\n        Pt.Y = op2b.Pt.Y;\n        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n      }\n      j.OutPt1 = op1;\n      j.OutPt2 = op2;\n      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n    }\n    else\n    {\n      //nb: For non-horizontal joins ...\n      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n      //make sure the polygons are correctly oriented ...\n      op1b = op1.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n        op1b = op1b.Next;\n      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse1)\n      {\n        op1b = op1.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n          op1b = op1b.Prev;\n        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      op2b = op2.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n        op2b = op2b.Next;\n      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse2)\n      {\n        op2b = op2.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n          op2b = op2b.Prev;\n        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n        return false;\n      if (Reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n  };\n  ClipperLib.Clipper.GetBounds = function (paths)\n  {\n    var i = 0,\n      cnt = paths.length;\n    while (i < cnt && paths[i].length == 0) i++;\n    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n    var result = new ClipperLib.IntRect();\n    result.left = paths[i][0].X;\n    result.right = result.left;\n    result.top = paths[i][0].Y;\n    result.bottom = result.top;\n    for (; i < cnt; i++)\n      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n      {\n        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n      }\n    return result;\n  }\n  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n  {\n    var opStart = ops;\n    var result = new ClipperLib.IntRect();\n    result.left = ops.Pt.X;\n    result.right = ops.Pt.X;\n    result.top = ops.Pt.Y;\n    result.bottom = ops.Pt.Y;\n    ops = ops.Next;\n    while (ops != opStart)\n    {\n      if (ops.Pt.X < result.left)\n        result.left = ops.Pt.X;\n      if (ops.Pt.X > result.right)\n        result.right = ops.Pt.X;\n      if (ops.Pt.Y < result.top)\n        result.top = ops.Pt.Y;\n      if (ops.Pt.Y > result.bottom)\n        result.bottom = ops.Pt.Y;\n      ops = ops.Next;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0,\n      cnt = path.length;\n    if (cnt < 3)\n      return 0;\n    var ip = path[0];\n    for (var i = 1; i <= cnt; ++i)\n    {\n      var ipNext = (i == cnt ? path[0] : path[i]);\n      if (ipNext.Y == pt.Y)\n      {\n        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n          return -1;\n      }\n      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n      {\n        if (ip.X >= pt.X)\n        {\n          if (ipNext.X > pt.X)\n            result = 1 - result;\n          else\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (ipNext.X > pt.X)\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n      }\n      ip = ipNext;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0;\n    var startOp = op;\n\t\tvar ptx = pt.X, pty = pt.Y;\n    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n    do\n    {\n\t\t\top = op.Next;\n\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n      if (poly1y == pty)\n      {\n        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n          return -1;\n      }\n      if ((poly0y < pty) != (poly1y < pty))\n      {\n        if (poly0x >= ptx)\n        {\n          if (poly1x > ptx)\n            result = 1 - result;\n          else\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (poly1x > ptx)\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n      }\n      poly0x = poly1x;\n      poly0y = poly1y;\n    } while (startOp != op);\n\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n  {\n    var op = outPt1;\n    do\n    {\n\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n      var res = this.PointInPolygon(op.Pt, outPt2);\n      if (res >= 0)\n        return res > 0;\n      op = op.Next;\n    }\n    while (op != outPt1)\n    return true;\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\tcontinue;\n\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (firstLeft == OldOutRec)\n\t\t\t{\n        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n          outRec.FirstLeft = NewOutRec;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n  {\n    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n      if (outRec.FirstLeft == OldOutRec)\n        outRec.FirstLeft = NewOutRec;\n  };\n  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n  {\n    while (FirstLeft != null && FirstLeft.Pts == null)\n      FirstLeft = FirstLeft.FirstLeft;\n    return FirstLeft;\n  };\n  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n  {\n    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n    {\n      var join = this.m_Joins[i];\n      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n      if (outRec1.Pts == null || outRec2.Pts == null)\n        continue;\n      //get the polygon fragment with the correct hole state (FirstLeft)\n      //before calling JoinPoints() ...\n      var holeStateRec;\n      if (outRec1 == outRec2)\n        holeStateRec = outRec1;\n      else if (this.Param1RightOfParam2(outRec1, outRec2))\n        holeStateRec = outRec2;\n      else if (this.Param1RightOfParam2(outRec2, outRec1))\n        holeStateRec = outRec1;\n      else\n        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n      if (outRec1 == outRec2)\n      {\n        //instead of joining two polygons, we've just created a new one by\n        //splitting one polygon into two.\n        outRec1.Pts = join.OutPt1;\n        outRec1.BottomPt = null;\n        outRec2 = this.CreateOutRec();\n        outRec2.Pts = join.OutPt2;\n        //update all OutRec2.Pts Idx's ...\n        this.UpdateOutPtIdxs(outRec2);\n        //We now need to check every OutRec.FirstLeft pointer. If it points\n        //to OutRec1 it may need to point to OutRec2 instead ...\n        if (this.m_UsingPolyTree)\n          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n          {\n            var oRec = this.m_PolyOuts[j];\n            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n              continue;\n            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n              oRec.FirstLeft = outRec2;\n          }\n        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n        {\n          //outRec2 is contained by outRec1 ...\n          outRec2.IsHole = !outRec1.IsHole;\n          outRec2.FirstLeft = outRec1;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec2, outRec1);\n          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n            this.ReversePolyPtLinks(outRec2.Pts);\n        }\n        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n        {\n          //outRec1 is contained by outRec2 ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec1.IsHole = !outRec2.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          outRec1.FirstLeft = outRec2;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec1, outRec2);\n          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n            this.ReversePolyPtLinks(outRec1.Pts);\n        }\n        else\n        {\n          //the 2 polygons are completely separate ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          //fixup FirstLeft pointers that may need reassigning to OutRec2\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts1(outRec1, outRec2);\n        }\n      }\n      else\n      {\n        //joined 2 polygons together ...\n        outRec2.Pts = null;\n        outRec2.BottomPt = null;\n        outRec2.Idx = outRec1.Idx;\n        outRec1.IsHole = holeStateRec.IsHole;\n        if (holeStateRec == outRec2)\n          outRec1.FirstLeft = outRec2.FirstLeft;\n        outRec2.FirstLeft = outRec1;\n        //fixup FirstLeft pointers that may need reassigning to OutRec1\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec2, outRec1);\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n  {\n    var op = outrec.Pts;\n    do {\n      op.Idx = outrec.Idx;\n      op = op.Prev;\n    }\n    while (op != outrec.Pts)\n  };\n  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n  {\n    var i = 0;\n    while (i < this.m_PolyOuts.length)\n    {\n      var outrec = this.m_PolyOuts[i++];\n      var op = outrec.Pts;\n\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\tcontinue;\n      do //for each Pt in Polygon until duplicate found do ...\n      {\n        var op2 = op.Next;\n        while (op2 != outrec.Pts)\n        {\n          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n          {\n            //split the polygon into two ...\n            var op3 = op.Prev;\n            var op4 = op2.Prev;\n            op.Prev = op4;\n            op4.Next = op;\n            op2.Prev = op3;\n            op3.Next = op2;\n            outrec.Pts = op;\n            var outrec2 = this.CreateOutRec();\n            outrec2.Pts = op2;\n            this.UpdateOutPtIdxs(outrec2);\n            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n            {\n              //OutRec2 is contained by OutRec1 ...\n              outrec2.IsHole = !outrec.IsHole;\n              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\n            }\n            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n            {\n              //OutRec1 is contained by OutRec2 ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec.IsHole = !outrec2.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n              outrec.FirstLeft = outrec2;\n              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n            }\n            else\n            {\n              //the 2 polygons are separate ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n            }\n            op2 = op;\n            //ie get ready for the next iteration\n          }\n          op2 = op2.Next;\n        }\n        op = op.Next;\n      }\n      while (op != outrec.Pts)\n    }\n  };\n  ClipperLib.Clipper.Area = function (poly)\n  {\n    var cnt = poly.length;\n    if (cnt < 3)\n      return 0;\n    var a = 0;\n    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n    {\n      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n      j = i;\n    }\n    return -a * 0.5;\n  };\n  ClipperLib.Clipper.prototype.Area = function (outRec)\n  {\n    var op = outRec.Pts;\n    if (op == null)\n      return 0;\n    var a = 0;\n    do {\n      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n      op = op.Next;\n    }\n    while (op != outRec.Pts)\n    return a * 0.5;\n  };\n  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n  {\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n  {\n    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n  {\n    var dx = (pt1.X - pt2.X);\n    var dy = (pt1.Y - pt2.Y);\n    return (dx * dx + dy * dy);\n  };\n  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n  {\n    //The equation of a line in general form (Ax + By + C = 0)\n    //given 2 points (x¹,y¹) & (x²,y²) is ...\n    //(y¹ - y²)x + (x² - x¹)y + (y² - y¹)x¹ - (x² - x¹)y¹ = 0\n    //A = (y¹ - y²); B = (x² - x¹); C = (y² - y¹)x¹ - (x² - x¹)y¹\n    //perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)\n    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n    var A = ln1.Y - ln2.Y;\n    var B = ln2.X - ln1.X;\n    var C = A * ln1.X + B * ln1.Y;\n    C = A * pt.X + B * pt.Y - C;\n    return (C * C) / (A * A + B * B);\n  };\n\n\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t{\n\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t//between the other 2 points is the one that's tested for distance.\n\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t{\n\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t\telse\n\t\t{\n\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t}\n\n  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n  {\n    var dx = pt1.X - pt2.X;\n    var dy = pt1.Y - pt2.Y;\n    return ((dx * dx) + (dy * dy) <= distSqrd);\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.Clipper.ExcludeOp = function (op)\n  {\n    var result = op.Prev;\n    result.Next = op.Next;\n    op.Next.Prev = result;\n    result.Idx = 0;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n  {\n    if (typeof (distance) == \"undefined\") distance = 1.415;\n    //distance = proximity in units/pixels below which vertices will be stripped.\n    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n    //both x & y coords within 1 unit, then the second vertex will be stripped.\n    var cnt = path.length;\n    if (cnt == 0)\n      return new Array();\n    var outPts = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n      outPts[i] = new ClipperLib.OutPt();\n    for (var i = 0; i < cnt; ++i)\n    {\n      outPts[i].Pt = path[i];\n      outPts[i].Next = outPts[(i + 1) % cnt];\n      outPts[i].Next.Prev = outPts[i];\n      outPts[i].Idx = 0;\n    }\n    var distSqrd = distance * distance;\n    var op = outPts[0];\n    while (op.Idx == 0 && op.Next != op.Prev)\n    {\n      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n      {\n        ClipperLib.Clipper.ExcludeOp(op.Next);\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt -= 2;\n      }\n      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else\n      {\n        op.Idx = 1;\n        op = op.Next;\n      }\n    }\n    if (cnt < 3)\n      cnt = 0;\n    var result = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n    {\n      result[i] = new ClipperLib.IntPoint(op.Pt);\n      op = op.Next;\n    }\n    outPts = null;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n  {\n    var result = new Array(polys.length);\n    for (var i = 0, ilen = polys.length; i < ilen; i++)\n      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n    return result;\n  };\n  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n  {\n    var delta = (IsClosed ? 1 : 0);\n    var polyCnt = pattern.length;\n    var pathCnt = path.length;\n    var result = new Array();\n    if (IsSum)\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n        result.push(p);\n      }\n    else\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n        result.push(p);\n      }\n    var quads = new Array();\n    for (var i = 0; i < pathCnt - 1 + delta; i++)\n      for (var j = 0; j < polyCnt; j++)\n      {\n        var quad = new Array();\n        quad.push(result[i % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n        if (!ClipperLib.Clipper.Orientation(quad))\n          quad.reverse();\n        quads.push(quad);\n      }\n\t\t\treturn quads;\n  };\n\n\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t{\n\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t{\n\t\t\tvar path = path_or_paths;\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\telse\n\t\t{\n \t\t\tvar paths = path_or_paths;\n\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t{\n\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tif (pathIsClosed)\n\t\t\t\t{\n\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn solution;\n\t\t}\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t{\n\t\tvar outPath = new ClipperLib.Path();\n\t\tfor (var i = 0; i < path.length; i++)\n\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\treturn outPath;\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t{\n\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\tvar c = new ClipperLib.Clipper();\n\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\treturn paths;\n\t}\n\n  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n  {\n    var result = new Array();\n    //result.set_Capacity(polytree.get_Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n    return result;\n  };\n  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n  {\n    var match = true;\n    switch (nt)\n    {\n    case ClipperLib.Clipper.NodeType.ntOpen:\n      return;\n    case ClipperLib.Clipper.NodeType.ntClosed:\n      match = !polynode.IsOpen;\n      break;\n    default:\n      break;\n    }\n    if (polynode.m_polygon.length > 0 && match)\n      paths.push(polynode.m_polygon);\n    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n  };\n  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.ChildCount());\n    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n      if (polytree.Childs()[i].IsOpen)\n        result.push(polytree.Childs()[i].m_polygon);\n    return result;\n  };\n  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n    return result;\n  };\n  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n  ClipperLib.Clipper.NodeType = {\n    ntAny: 0,\n    ntOpen: 1,\n    ntClosed: 2\n  };\n  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n  {\n    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n    this.m_destPolys = new ClipperLib.Paths();\n    this.m_srcPoly = new ClipperLib.Path();\n    this.m_destPoly = new ClipperLib.Path();\n    this.m_normals = new Array();\n    this.m_delta = 0;\n    this.m_sinA = 0;\n    this.m_sin = 0;\n    this.m_cos = 0;\n    this.m_miterLim = 0;\n    this.m_StepsPerRad = 0;\n    this.m_lowest = new ClipperLib.IntPoint();\n    this.m_polyNodes = new ClipperLib.PolyNode();\n    this.MiterLimit = miterLimit;\n    this.ArcTolerance = arcTolerance;\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n  ClipperLib.ClipperOffset.prototype.Clear = function ()\n  {\n    ClipperLib.Clear(this.m_polyNodes.Childs());\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n  {\n    var highI = path.length - 1;\n    if (highI < 0)\n      return;\n    var newNode = new ClipperLib.PolyNode();\n    newNode.m_jointype = joinType;\n    newNode.m_endtype = endType;\n    //strip duplicate points from path and also get index to the lowest point ...\n    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n        highI--;\n    //newNode.m_polygon.set_Capacity(highI + 1);\n    newNode.m_polygon.push(path[0]);\n    var j = 0,\n      k = 0;\n    for (var i = 1; i <= highI; i++)\n      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n      {\n        j++;\n        newNode.m_polygon.push(path[i]);\n        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n          k = j;\n      }\n    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\n    this.m_polyNodes.AddChild(newNode);\n    //if this path's lowest pt is lower than all the others then update m_lowest\n    if (endType != ClipperLib.EndType.etClosedPolygon)\n      return;\n    if (this.m_lowest.X < 0)\n      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    else\n    {\n      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n  {\n    for (var i = 0, ilen = paths.length; i < ilen; i++)\n      this.AddPath(paths[i], joinType, endType);\n  };\n  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n  {\n    //fixup orientations of all closed paths if the orientation of the\n    //closed path with the lowermost vertex is wrong ...\n    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n          node.m_polygon.reverse();\n      }\n    }\n    else\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n          node.m_polygon.reverse();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n  {\n    var dx = (pt2.X - pt1.X);\n    var dy = (pt2.Y - pt1.Y);\n    if ((dx == 0) && (dy == 0))\n      return new ClipperLib.DoublePoint(0, 0);\n    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n    dx *= f;\n    dy *= f;\n    return new ClipperLib.DoublePoint(dy, -dx);\n  };\n  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n  {\n    this.m_destPolys = new Array();\n    this.m_delta = delta;\n    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n    if (ClipperLib.ClipperBase.near_zero(delta))\n    {\n      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n          this.m_destPolys.push(node.m_polygon);\n      }\n      return;\n    }\n    //see offset_triginometry3.svg in the documentation folder ...\n    if (this.MiterLimit > 2)\n      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n    else\n      this.m_miterLim = 0.5;\n    var y;\n    if (this.ArcTolerance <= 0)\n      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n    else\n      y = this.ArcTolerance;\n    //see offset_triginometry2.svg in the documentation folder ...\n    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n    if (delta < 0)\n      this.m_sin = -this.m_sin;\n    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      this.m_srcPoly = node.m_polygon;\n      var len = this.m_srcPoly.length;\n      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n        continue;\n      this.m_destPoly = new Array();\n      if (len == 1)\n      {\n        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n        {\n          var X = 1,\n            Y = 0;\n          for (var j = 1; j <= steps; j++)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            var X2 = X;\n            X = X * this.m_cos - this.m_sin * Y;\n            Y = X2 * this.m_sin + Y * this.m_cos;\n          }\n        }\n        else\n        {\n          var X = -1,\n            Y = -1;\n          for (var j = 0; j < 4; ++j)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            if (X < 0)\n              X = 1;\n            else if (Y < 0)\n              Y = 1;\n            else\n              X = -1;\n          }\n        }\n        this.m_destPolys.push(this.m_destPoly);\n        continue;\n      }\n      //build m_normals ...\n      this.m_normals.length = 0;\n      //this.m_normals.set_Capacity(len);\n      for (var j = 0; j < len - 1; j++)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n      else\n        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n        this.m_destPoly = new Array();\n        //re-build m_normals ...\n        var n = this.m_normals[len - 1];\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n        k = 0;\n        for (var j = len - 1; j >= 0; j--)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else\n      {\n        var k = 0;\n        for (var j = 1; j < len - 1; ++j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        var pt1;\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          var j = len - 1;\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          var j = len - 1;\n          k = len - 2;\n          this.m_sinA = 0;\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(j, k);\n          else\n            this.DoRound(j, k);\n        }\n        //re-build m_normals ...\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n        k = len - 1;\n        for (var j = k - 1; j > 0; --j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          k = 1;\n          this.m_sinA = 0;\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(0, 1);\n          else\n            this.DoRound(0, 1);\n        }\n        this.m_destPolys.push(this.m_destPoly);\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.Execute = function ()\n  {\n    var a = arguments,\n      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n    if (!ispolytree) // function (solution, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      ClipperLib.Clear(solution);\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        if (solution.length > 0)\n          solution.splice(0, 1);\n      }\n      //console.log(JSON.stringify(solution));\n    }\n    else // function (polytree, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      solution.Clear();\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        //remove the outer PolyNode rectangle ...\n        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n        {\n          var outerNode = solution.Childs()[0];\n          //solution.Childs.set_Capacity(outerNode.ChildCount);\n          solution.Childs()[0] = outerNode.Childs()[0];\n          solution.Childs()[0].m_Parent = solution;\n          for (var i = 1; i < outerNode.ChildCount(); i++)\n            solution.AddChild(outerNode.Childs()[i]);\n        }\n        else\n          solution.Clear();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n  {\n\t\t//cross product ...\n\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\n\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t{\n\t\t\t//dot product ...\n\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t{\n\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\treturn k;\n\t\t\t}\n\t\t\t//else angle ==> 180 degrees\n\t\t}\n    else if (this.m_sinA > 1)\n      this.m_sinA = 1.0;\n    else if (this.m_sinA < -1)\n      this.m_sinA = -1.0;\n    if (this.m_sinA * this.m_delta < 0)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n    }\n    else\n      switch (jointype)\n      {\n      case ClipperLib.JoinType.jtMiter:\n        {\n          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n          if (r >= this.m_miterLim)\n            this.DoMiter(j, k, r);\n          else\n            this.DoSquare(j, k);\n          break;\n        }\n      case ClipperLib.JoinType.jtSquare:\n        this.DoSquare(j, k);\n        break;\n      case ClipperLib.JoinType.jtRound:\n        this.DoRound(j, k);\n        break;\n      }\n    k = j;\n    return k;\n  };\n  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n  {\n    var dx = Math.tan(Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n  };\n  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n  {\n    var q = this.m_delta / r;\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n  };\n  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n  {\n    var a = Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\n    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\n    var X = this.m_normals[k].X,\n      Y = this.m_normals[k].Y,\n      X2;\n    for (var i = 0; i < steps; ++i)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n      X2 = X;\n      X = X * this.m_cos - this.m_sin * Y;\n      Y = X2 * this.m_sin + Y * this.m_cos;\n    }\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n  };\n  ClipperLib.Error = function (message)\n  {\n    try\n    {\n      throw new Error(message);\n    }\n    catch (err)\n    {\n      alert(err.message);\n    }\n  };\n  // ---------------------------------\n  // JS extension by Timo 2013\n  ClipperLib.JS = {};\n  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n  };\n  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    var area = 0;\n    for (var i = 0; i < poly.length; i++)\n    {\n      area += ClipperLib.Clipper.Area(poly[i]);\n    }\n    return area / (scale * scale);\n  };\n  ClipperLib.JS.BoundsOfPath = function (path, scale)\n  {\n    return ClipperLib.JS.BoundsOfPaths([path], scale);\n  };\n  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n  {\n    if (!scale) scale = 1;\n    var bounds = ClipperLib.Clipper.GetBounds(paths);\n    bounds.left /= scale;\n    bounds.bottom /= scale;\n    bounds.right /= scale;\n    bounds.top /= scale;\n    return bounds;\n  };\n  // Clean() joins vertices that are too near each other\n  // and causes distortion to offsetted polygons without cleaning\n  ClipperLib.JS.Clean = function (polygon, delta)\n  {\n    if (!(polygon instanceof Array)) return [];\n    var isPolygons = polygon[0] instanceof Array;\n    var polygon = ClipperLib.JS.Clone(polygon);\n    if (typeof delta != \"number\" || delta === null)\n    {\n      ClipperLib.Error(\"Delta is not a number in Clean().\");\n      return polygon;\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n    if (!isPolygons) polygon = [polygon];\n    var k_length = polygon.length;\n    var len, poly, result, d, p, j, i;\n    var results = [];\n    for (var k = 0; k < k_length; k++)\n    {\n      poly = polygon[k];\n      len = poly.length;\n      if (len === 0) continue;\n      else if (len < 3)\n      {\n        result = poly;\n        results.push(result);\n        continue;\n      }\n      result = poly;\n      d = delta * delta;\n      //d = Math.floor(c_delta * c_delta);\n      p = poly[0];\n      j = 1;\n      for (i = 1; i < len; i++)\n      {\n        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n          continue;\n        result[j] = poly[i];\n        p = poly[i];\n        j++;\n      }\n      p = poly[j - 1];\n      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n        j--;\n      if (j < len)\n        result.splice(j, len - j);\n      if (result.length) results.push(result);\n    }\n    if (!isPolygons && results.length) results = results[0];\n    else if (!isPolygons && results.length === 0) results = [];\n    else if (isPolygons && results.length === 0) results = [\n      []\n    ];\n    return results;\n  }\n  // Make deep copy of Polygons or Polygon\n  // so that also IntPoint objects are cloned and not only referenced\n  // This should be the fastest way\n  ClipperLib.JS.Clone = function (polygon)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (polygon.length === 0) return [];\n    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n    var isPolygons = polygon[0] instanceof Array;\n    if (!isPolygons) polygon = [polygon];\n    var len = polygon.length,\n      plen, i, j, result;\n    var results = new Array(len);\n    for (i = 0; i < len; i++)\n    {\n      plen = polygon[i].length;\n      result = new Array(plen);\n      for (j = 0; j < plen; j++)\n      {\n        result[j] = {\n          X: polygon[i][j].X,\n          Y: polygon[i][j].Y\n        };\n      }\n      results[i] = result;\n    }\n    if (!isPolygons) results = results[0];\n    return results;\n  };\n  // Removes points that doesn't affect much to the visual appearance.\n  // If middle point is at or under certain distance (tolerance) of the line segment between\n  // start and end point, the middle point is removed.\n  ClipperLib.JS.Lighten = function (polygon, tolerance)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (typeof tolerance != \"number\" || tolerance === null)\n    {\n      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n    {\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n    var bxax, byay, l, ax, ay;\n    var len = polygon.length;\n    var toleranceSq = tolerance * tolerance;\n    var results = [];\n    for (i = 0; i < len; i++)\n    {\n      poly = polygon[i];\n      plen = poly.length;\n      if (plen == 0) continue;\n      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n      {\n        poly2 = [];\n        plen = poly.length;\n        // the first have to added to the end, if first and last are not the same\n        // this way we ensure that also the actual last point can be removed if needed\n        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n        {\n          addlast = 1;\n          poly.push(\n          {\n            X: poly[0].X,\n            Y: poly[0].Y\n          });\n          plen = poly.length;\n        }\n        else addlast = 0;\n        rem = []; // Indexes of removed points\n        for (j = 0; j < plen - 2; j++)\n        {\n          A = poly[j]; // Start point of line segment\n          P = poly[j + 1]; // Middle point. This is the one to be removed.\n          B = poly[j + 2]; // End point of line segment\n          ax = A.X;\n          ay = A.Y;\n          bxax = B.X - ax;\n          byay = B.Y - ay;\n          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n          {\n            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n            if (l > 1)\n            {\n              ax = B.X;\n              ay = B.Y;\n            }\n            else if (l > 0)\n            {\n              ax += bxax * l;\n              ay += byay * l;\n            }\n          }\n          bxax = P.X - ax;\n          byay = P.Y - ay;\n          d = bxax * bxax + byay * byay;\n          if (d <= toleranceSq)\n          {\n            rem[j + 1] = 1;\n            j++; // when removed, transfer the pointer to the next one\n          }\n        }\n        // add all unremoved points to poly2\n        poly2.push(\n        {\n          X: poly[0].X,\n          Y: poly[0].Y\n        });\n        for (j = 1; j < plen - 1; j++)\n          if (!rem[j]) poly2.push(\n          {\n            X: poly[j].X,\n            Y: poly[j].Y\n          });\n        poly2.push(\n        {\n          X: poly[plen - 1].X,\n          Y: poly[plen - 1].Y\n        });\n        // if the first point was added to the end, remove it\n        if (addlast) poly.pop();\n        // break, if there was not anymore removed points\n        if (!rem.length) break;\n        // else continue looping using poly2, to check if there are points to remove\n        else poly = poly2;\n      }\n      plen = poly2.length;\n      // remove duplicate from end, if needed\n      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n      {\n        poly2.pop();\n      }\n      if (poly2.length > 2) // to avoid two-point-polygons\n        results.push(poly2);\n    }\n    if (!(polygon[0] instanceof Array)) results = results[0];\n    if (typeof (results) == \"undefined\") results = [\n      []\n    ];\n    return results;\n  }\n  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n  {\n    if (typeof (path) == \"undefined\") return 0;\n    var sqrt = Math.sqrt;\n    var perimeter = 0.0;\n    var p1, p2, p1x = 0.0,\n      p1y = 0.0,\n      p2x = 0.0,\n      p2y = 0.0;\n    var j = path.length;\n    if (j < 2) return 0;\n    if (closed)\n    {\n      path[j] = path[0];\n      j++;\n    }\n    while (--j)\n    {\n      p1 = path[j];\n      p1x = p1.X;\n      p1y = p1.Y;\n      p2 = path[j - 1];\n      p2x = p2.X;\n      p2y = p2.Y;\n      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n    }\n    if (closed) path.pop();\n    return perimeter / scale;\n  };\n  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n  {\n    if (!scale) scale = 1;\n    var perimeter = 0;\n    for (var i = 0; i < paths.length; i++)\n    {\n      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n    }\n    return perimeter;\n  };\n  ClipperLib.JS.ScaleDownPath = function (path, scale)\n  {\n    var i, p;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = p.X / scale;\n      p.Y = p.Y / scale;\n    }\n  };\n  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n  {\n    var i, j, p;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = p.X / scale;\n        p.Y = p.Y / scale;\n      }\n    }\n  };\n  ClipperLib.JS.ScaleUpPath = function (path, scale)\n  {\n    var i, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = round(p.X * scale);\n      p.Y = round(p.Y * scale);\n    }\n  };\n  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n  {\n    var i, j, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = round(p.X * scale);\n        p.Y = round(p.Y * scale);\n      }\n    }\n  };\n  ClipperLib.ExPolygons = function ()\n  {\n    return [];\n  }\n  ClipperLib.ExPolygon = function ()\n  {\n    this.outer = null;\n    this.holes = null;\n  };\n  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n  {\n    var ep = new ClipperLib.ExPolygon();\n    ep.outer = polynode.Contour();\n    var childs = polynode.Childs();\n    var ilen = childs.length;\n    ep.holes = new Array(ilen);\n    var node, n, i, j, childs2, jlen;\n    for (i = 0; i < ilen; i++)\n    {\n      node = childs[i];\n      ep.holes[i] = node.Contour();\n      //Add outer polygons contained by (nested within) holes ...\n      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n      {\n        n = childs2[j];\n        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n      }\n    }\n    expolygons.push(ep);\n  };\n  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n  {\n    var a, i, alen, ilen;\n    var paths = new ClipperLib.Paths();\n    for (a = 0, alen = expolygons.length; a < alen; a++)\n    {\n      paths.push(expolygons[a].outer);\n      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n      {\n        paths.push(expolygons[a].holes[i]);\n      }\n    }\n    return paths;\n  }\n  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n  {\n    var expolygons = new ClipperLib.ExPolygons();\n    var node, i, childs, ilen;\n    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n    {\n      node = childs[i];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n    }\n    return expolygons;\n  };\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/clipper-lib/clipper.js\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}