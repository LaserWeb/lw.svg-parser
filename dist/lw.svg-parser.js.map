{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lw.svg-parser.js","webpack:///webpack/bootstrap 269cb3ebf52074bad7fa","webpack:///./path.js","webpack:///./parser.js","webpack:///./tag.js","webpack:///./tagparser.js","webpack:///./trace.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","Point","x","y","parseFloat","isNaN","console","error","Error","point","Path","element","parent","points","forEach","push","il","addPoint","firstPoint","getPoint","isEqual","isClosed","matrix","map","default","Parser","undefined","_tag","_tagparser","settings","editor","document","defs","tags","traceSettings","assign","linear","step","resolution","segmentLength","supportedTags","parseTags","includes","skipTags","excludes","onTag","onTagContext","input","loadFromString","File","loadFromFile","XMLDocument","loadFromXMLDocument","Element","loadFromElement","Promise","reject","_this","resolve","nodeName","textContent","getElementsByTagName","_this2","documentElement","then","catch","_this3","_parseEditor","parser","DOMParser","XMLDoc","parseFromString","name","version","fingerprint","match","_this4","reader","FileReader","onload","event","result","onerror","readAsText","_this5","load","parse","_parseElement","applyMatrix","tag","info","callback","context","_this6","_onTag","_this7","Tag","indexOf","_skipTag","tagParser","TagParser","childTag","childNodes","childNode","addChild","children","message","warn","attr","_path","DEG_TO_RAD","Math","PI","toLowerCase","layer","attrs","paths","path","setMatrix","keys","setAttr","defaultValue","getAttr","getLayerName","clearPath","close","relative","addMatrix","angle","arguments","cos","sin","tan","transform","_trace","_path2","currentCommand","lastCommand","pathData","handler","_parseTagAttrs","debug","triangles","getFlattenPoints","join","attributes","style","some","_normalizeTagAttr","split","nodeValue","colorsAttrs","attrName","_parseViewBoxAttr","_parseTransformAttr","replace","trim","_skipTagAttr","_normalizeTagAttrUnit","_normalizeTagAttrPoints","_normalizeTagAttrRange","_normalizeTagAttrPreserveAspectRatio","stringValue","floatValue","_parseNumbers","min","max","filter","params","defer","align","meet","slice","rawParams","substr","viewBox","width","height","scaleX","scaleY","translateX","translateY","preserveAspectRatio","newWidth","newHeight","translate","scale","transformAttr","transformations","pop","type","raw","func","tagTransform","apply","newPath","closePath","addPoints","title","description","useTag","setLayerName","shift","concat","_polyline","w","h","rx","ry","dx","dy","r","cx","cy","num","splice","dAttr","commands","parseError","toUpperCase","_clearPath","_newPath","_addPoints","_closePath","every","_paths","p1","rl","x1","y1","x2","y2","p2","p3","p4","tracer","CubicBezier","coords","trace","QuadricBezier","large","sweep","Arc","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","mod","clamp","val","distance","p0","sqrt","pow","v0","v1","n","acos","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","getPrototypeOf","getter","MATH_PI_2","TraceBase","arcLength","arcLengthMap","t","prevPoint","getPointAtT","nextPoint","u","targetDistanceFromStartingPoint","resultantT","prevArcLength","prevT","entry","endDiff","startDiff","linearFactor","_approximateLength","segments","round","_addPoint","_postTrace","getPath","_TraceBase","radians","abs","__addPoint","transformedPoint","radiiCheck","cSquareNumerator","cSquareRootDenom","cRadicand","cCoef","transformedCenter","center","startVector","endVector","startAngle","sweepAngle","init","_TraceBase2","_B1","_B2","_B3","_B4","_C1","unshift","_TraceBase3"],"mappings":"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","file":"lw.svg-parser.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGParser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGParser\"] = factory();\n\telse\n\t\troot[\"SVGParser\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGParser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGParser\"] = factory();\n\telse\n\t\troot[\"SVGParser\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Point = function () {\n\t    // Class constructor...\n\t    function Point(x, y) {\n\t        _classCallCheck(this, Point);\n\t\n\t        // Init properties\n\t        this.x = parseFloat(x);\n\t        this.y = parseFloat(y);\n\t\n\t        if (isNaN(this.x) || isNaN(this.y)) {\n\t            console.error('x:', x, 'y:', y);\n\t            throw new Error('Float value!!!');\n\t        }\n\t    }\n\t\n\t    _createClass(Point, [{\n\t        key: 'isEqual',\n\t        value: function isEqual(point) {\n\t            return this.x === point.x && this.y === point.y;\n\t        }\n\t    }]);\n\t\n\t    return Point;\n\t}();\n\t\n\tvar Path = function () {\n\t    // Class constructor...\n\t    function Path(element, parent) {\n\t        _classCallCheck(this, Path);\n\t\n\t        // Init properties\n\t        this.points = [];\n\t        this.length = 0;\n\t    }\n\t\n\t    _createClass(Path, [{\n\t        key: 'getPoints',\n\t        value: function getPoints() {\n\t            return this.points;\n\t        }\n\t    }, {\n\t        key: 'getFlattenPoints',\n\t        value: function getFlattenPoints() {\n\t            var points = [];\n\t            this.points.forEach(function (point) {\n\t                return points.push(point.x, point.y);\n\t            });\n\t            return points;\n\t        }\n\t    }, {\n\t        key: 'getPoint',\n\t        value: function getPoint(i) {\n\t            return this.points[i < 0 ? this.length + i : i] || null;\n\t        }\n\t    }, {\n\t        key: 'addPoint',\n\t        value: function addPoint(x, y) {\n\t            this.points.push(new Point(x, y));\n\t            this.length = this.points.length;\n\t        }\n\t    }, {\n\t        key: 'addPoints',\n\t        value: function addPoints(points) {\n\t            // For each couple of points\n\t            for (var i = 0, il = points.length; i < il; i += 2) {\n\t                this.addPoint(points[i], points[i + 1]);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'isClosed',\n\t        value: function isClosed() {\n\t            var firstPoint = this.getPoint(0);\n\t            return firstPoint && firstPoint.isEqual(this.getPoint(-1));\n\t        }\n\t    }, {\n\t        key: 'close',\n\t        value: function close() {\n\t            if (!this.isClosed() && this.length > 2) {\n\t                var firstPoint = this.getPoint(0);\n\t                this.addPoint(firstPoint.x, firstPoint.y);\n\t                return true;\n\t            }\n\t\n\t            return false;\n\t        }\n\t    }, {\n\t        key: 'transform',\n\t        value: function transform(matrix) {\n\t            this.points = this.points.map(function (point) {\n\t                return new Point(matrix[0] * point.x + matrix[2] * point.y + matrix[4], matrix[1] * point.x + matrix[3] * point.y + matrix[5]);\n\t            });\n\t        }\n\t    }]);\n\t\n\t    return Path;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Path = Path;\n\texports.Point = Point;\n\texports.default = Path;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Parser = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Imports\n\t\n\t\n\tvar _tag = __webpack_require__(3);\n\t\n\tvar _tagparser = __webpack_require__(4);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// SVG parser class\n\tvar Parser = function () {\n\t    // Class constructor...\n\t    function Parser(settings) {\n\t        _classCallCheck(this, Parser);\n\t\n\t        // Defaults settings\n\t        settings = settings || {};\n\t\n\t        // Init properties\n\t        this.element = null; // XML document Element object\n\t        this.editor = null; // Editor info { name, version, fingerprint }\n\t        this.document = null; // Document info { width, height, viewBox }\n\t        this.defs = null; // Defined <defs> (DOM) nodes list by id\n\t        this.tags = null; // Tag objects hierarchy\n\t\n\t        // Trace settings (Arc, Bezier)\n\t        this.traceSettings = Object.assign({\n\t            linear: true, // Linear trace mode\n\t            step: 0.01, // Step resolution if linear mode = false\n\t            resolution: 100, // Number of segments we use to approximate arc length\n\t            segmentLength: 1 }, settings.traceSettings || {});\n\t\n\t        // Supported tags by this lib\n\t        this.supportedTags = ['svg', 'g', 'defs', 'use', 'line', 'polyline', 'polygon', 'rect', 'circle', 'ellipse', 'path', 'title', 'desc'];\n\t\n\t        // Tags list to includes/excludes\n\t        this.parseTags = settings.includes || this.supportedTags;\n\t        this.skipTags = settings.excludes || ['#text', '#comment']; // silent (no warning)\n\t\n\t        // User onTag callback ?\n\t        settings.onTag && this.onTag(settings.onTag, settings.onTagContext);\n\t    }\n\t\n\t    // Load raw XML string, XMLDocument, Element or File object\n\t\n\t\n\t    _createClass(Parser, [{\n\t        key: 'load',\n\t        value: function load(input) {\n\t            // Load raw XML string\n\t            if (typeof input === 'string') {\n\t                return this.loadFromString(input);\n\t            }\n\t\n\t            // Load File object\n\t            if (input instanceof File) {\n\t                return this.loadFromFile(input);\n\t            }\n\t\n\t            // Load XMLDocument object\n\t            if (input instanceof XMLDocument) {\n\t                return this.loadFromXMLDocument(input);\n\t            }\n\t\n\t            // Load Element object\n\t            if (input instanceof Element) {\n\t                return this.loadFromElement(input);\n\t            }\n\t\n\t            // Return rejected promise with an Error object\n\t            return Promise.reject(new Error('Unsupported input format.'));\n\t        }\n\t\n\t        // Load from Element object\n\t\n\t    }, {\n\t        key: 'loadFromElement',\n\t        value: function loadFromElement(input) {\n\t            var _this = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof Element)) {\n\t                    reject(new Error('Input param must be a Element object.'));\n\t                }\n\t\n\t                // Parser error\n\t                if (input.nodeName === 'parsererror') {\n\t                    // FF\n\t                    reject(new Error(input.textContent));\n\t                }\n\t\n\t                if (input.nodeName === 'html' && input.getElementsByTagName('parsererror')) {\n\t                    // Chrome\n\t                    reject(new Error(input.getElementsByTagName('parsererror')[0].textContent));\n\t                }\n\t\n\t                // Set document element\n\t                _this.element = input;\n\t\n\t                // Resolve promise\n\t                resolve(input);\n\t            });\n\t        }\n\t\n\t        // Load from XMLDocument object\n\t\n\t    }, {\n\t        key: 'loadFromXMLDocument',\n\t        value: function loadFromXMLDocument(input) {\n\t            var _this2 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof XMLDocument)) {\n\t                    reject(new Error('Input param must be a XMLDocument object.'));\n\t                }\n\t\n\t                // Load from Element...\n\t                _this2.loadFromElement(input.documentElement).then(resolve).catch(reject);\n\t            });\n\t        }\n\t\n\t        // Load raw XML string\n\t\n\t    }, {\n\t        key: 'loadFromString',\n\t        value: function loadFromString(input) {\n\t            var _this3 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (typeof input !== 'string') {\n\t                    reject(new Error('Input param must be a string.'));\n\t                }\n\t\n\t                // Parse svg editor\n\t                _this3._parseEditor(input);\n\t\n\t                // Parse string as DOM object\n\t                var parser = new DOMParser();\n\t                var XMLDoc = parser.parseFromString(input, 'text/xml');\n\t\n\t                // Load from XMLDocument...\n\t                _this3.loadFromXMLDocument(XMLDoc).then(resolve).catch(reject);\n\t            });\n\t        }\n\t\n\t        // Try to get the svg editor from input string\n\t\n\t    }, {\n\t        key: '_parseEditor',\n\t        value: function _parseEditor(input) {\n\t            // Reset editor\n\t            this.editor = {\n\t                name: 'unknown',\n\t                version: null,\n\t                fingerprint: null\n\t            };\n\t\n\t            // Fingerprint matches\n\t            var fingerprint = void 0;\n\t\n\t            // Inkscape\n\t            fingerprint = input.match(/<!-- Created with Inkscape .*-->/i);\n\t\n\t            if (fingerprint) {\n\t                this.editor.name = 'inkscape';\n\t                this.editor.fingerprint = fingerprint[0];\n\t\n\t                return this.editor;\n\t            }\n\t\n\t            // Illustrator\n\t            fingerprint = input.match(/<!-- Generator: Adobe Illustrator ([0-9\\.]+), .*-->/i);\n\t\n\t            if (fingerprint) {\n\t                this.editor.name = 'illustrator';\n\t                this.editor.version = fingerprint[1];\n\t                this.editor.fingerprint = fingerprint[0];\n\t\n\t                return this.editor;\n\t            }\n\t\n\t            // Return default\n\t            return this.editor;\n\t        }\n\t\n\t        // Load from File object\n\t\n\t    }, {\n\t        key: 'loadFromFile',\n\t        value: function loadFromFile(input) {\n\t            var _this4 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof File)) {\n\t                    reject(new Error('Input param must be a File object.'));\n\t                }\n\t\n\t                // Create file reader\n\t                var reader = new FileReader();\n\t\n\t                // Register reader events handlers\n\t                reader.onload = function (event) {\n\t                    _this4.loadFromString(event.target.result).then(resolve).catch(reject);\n\t                };\n\t\n\t                reader.onerror = function (event) {\n\t                    reject(new Error('Error reading file : ' + input.name));\n\t                };\n\t\n\t                // Finally read input file as text\n\t                reader.readAsText(input);\n\t            });\n\t        }\n\t\n\t        // Parse the (loaded) element\n\t\n\t    }, {\n\t        key: 'parse',\n\t        value: function parse(input) {\n\t            var _this5 = this;\n\t\n\t            // Reset properties\n\t            this.document = null;\n\t            this.defs = {};\n\t            this.tags = null;\n\t\n\t            // Load input if provided\n\t            if (input) {\n\t                return new Promise(function (resolve, reject) {\n\t                    _this5.load(input).then(function () {\n\t                        resolve(_this5.parse());\n\t                    }).catch(reject);\n\t                });\n\t            }\n\t\n\t            // Start parsing element\n\t            return new Promise(function (resolve, reject) {\n\t                // If no element is loaded\n\t                if (!_this5.element) {\n\t                    reject(new Error('No element is loaded, call the load method before.'));\n\t                }\n\t\n\t                // Parse the main Element (recursive)\n\t                _this5.tags = _this5._parseElement(_this5.element);\n\t\n\t                if (!_this5.tags) {\n\t                    reject(new Error('No supported tags found.'));\n\t                }\n\t\n\t                // Apply matrix (recursive)\n\t                _this5.tags.applyMatrix();\n\t\n\t                // Resolve the promise\n\t                resolve(_this5.tags);\n\t            });\n\t        }\n\t\n\t        // On tag callback\n\t\n\t    }, {\n\t        key: '_onTag',\n\t        value: function _onTag(tag) {\n\t            console.info('onTag:', tag);\n\t        }\n\t\n\t        // Register on tag callback\n\t\n\t    }, {\n\t        key: 'onTag',\n\t        value: function onTag(callback, context) {\n\t            var _this6 = this;\n\t\n\t            this._onTag = function (tag) {\n\t                return callback.call(context || _this6, tag);\n\t            };\n\t        }\n\t\n\t        // Parse the provided Element and return an Tag collection (recursive)\n\t\n\t    }, {\n\t        key: '_parseElement',\n\t        value: function _parseElement(element, parent) {\n\t            var _this7 = this;\n\t\n\t            // Create base tag object\n\t            var tag = new _tag.Tag(element, parent);\n\t\n\t            // Exluded tag ?\n\t            if (this.skipTags.indexOf(tag.name) !== -1) {\n\t                return null; // silent\n\t            }\n\t\n\t            // Supported tag ?\n\t            if (this.parseTags.indexOf(tag.name) === -1) {\n\t                return this._skipTag(tag, 'unsupported');\n\t            }\n\t\n\t            // Parse the tag\n\t            var tagParser = new _tagparser.TagParser(tag, this);\n\t\n\t            if (!tagParser.parse()) {\n\t                return false;\n\t            }\n\t\n\t            // Call the on tag callback\n\t            this._onTag(tag);\n\t\n\t            // Parse child nodes\n\t            var childTag = void 0;\n\t\n\t            element.childNodes.forEach(function (childNode) {\n\t                // Parse child element\n\t                if (childTag = _this7._parseElement(childNode, tag)) {\n\t                    tag.addChild(childTag);\n\t                }\n\t            });\n\t\n\t            // Empty group\n\t            if (['svg', 'g'].indexOf(tag.name) !== -1 && !tag.children.length) {\n\t                return this._skipTag(tag, 'empty');\n\t            }\n\t\n\t            // Return tag object\n\t            return tag;\n\t        }\n\t\n\t        // Log skip tag warning message\n\t\n\t    }, {\n\t        key: '_skipTag',\n\t        value: function _skipTag(tag, message) {\n\t            console.warn('Skip tag :', message + ':', tag);\n\t            return false;\n\t        }\n\t\n\t        // Log skip tag attribute warning message\n\t\n\t    }, {\n\t        key: '_skipTagAttr',\n\t        value: function _skipTagAttr(tag, attr, message) {\n\t            console.warn('Skip tag attribute :', message + ':', attr, tag);\n\t            return false;\n\t        }\n\t    }]);\n\t\n\t    return Parser;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Parser = Parser;\n\texports.default = Parser;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Tag = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _path = __webpack_require__(1);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar DEG_TO_RAD = Math.PI / 180;\n\t\n\t// SVG tag class\n\t\n\tvar Tag = function () {\n\t    // Class constructor...\n\t    function Tag(element, parent) {\n\t        var _this = this;\n\t\n\t        _classCallCheck(this, Tag);\n\t\n\t        // Init properties\n\t        this.element = element;\n\t        this.name = element.nodeName.toLowerCase();\n\t        this.parent = parent || null;\n\t        this.layer = null;\n\t        this.attrs = {};\n\t        this.children = [];\n\t        this.paths = [];\n\t        this.matrix = null;\n\t        this.path = new _path.Path();\n\t        this.point = new _path.Point(0, 0);\n\t\n\t        // Add first path\n\t        this.paths.push(this.path);\n\t\n\t        // Set the matrix\n\t        this.setMatrix(this.parent && this.parent.matrix);\n\t\n\t        // Clone parent attributes\n\t        if (this.parent && (this.parent.name === 'g' || this.parent.name === 'svg')) {\n\t            (function () {\n\t                // Inherit layer name\n\t                _this.layer = _this.parent.layer;\n\t\n\t                // Inherit parent attributes\n\t                var excludes = ['transform', 'width', 'height'];\n\t\n\t                Object.keys(_this.parent.attrs).forEach(function (key) {\n\t                    if (excludes.indexOf(key) === -1) {\n\t                        _this.setAttr(key, _this.parent.attrs[key]);\n\t                    }\n\t                });\n\t            })();\n\t        }\n\t    }\n\t\n\t    _createClass(Tag, [{\n\t        key: 'setAttr',\n\t        value: function setAttr(name, value) {\n\t            this.attrs[name] = value;\n\t        }\n\t    }, {\n\t        key: 'getAttr',\n\t        value: function getAttr(name, defaultValue) {\n\t            return this.attrs[name] !== undefined ? this.attrs[name] : defaultValue !== undefined ? defaultValue : null;\n\t        }\n\t    }, {\n\t        key: 'getLayerName',\n\t        value: function getLayerName() {\n\t            if (this.name === 'g') {\n\t                return this.getAttr('inkscape:label', this.getAttr('id', null));\n\t            }\n\t        }\n\t    }, {\n\t        key: 'setLayerName',\n\t        value: function setLayerName(name) {\n\t            if (this.name === 'g') {\n\t                this.layer = name || this.getLayerName();\n\t            }\n\t        }\n\t    }, {\n\t        key: 'addChild',\n\t        value: function addChild(childTag) {\n\t            this.children.push(childTag);\n\t        }\n\t    }, {\n\t        key: 'clearPath',\n\t        value: function clearPath() {\n\t            this.path = new _path.Path();\n\t        }\n\t    }, {\n\t        key: 'newPath',\n\t        value: function newPath() {\n\t            if (this.path.length > 0) {\n\t                this.clearPath();\n\t                this.paths.push(this.path);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'closePath',\n\t        value: function closePath() {\n\t            return this.path.close();\n\t        }\n\t    }, {\n\t        key: 'addPoint',\n\t        value: function addPoint(x, y, relative) {\n\t            // Relative from the last point\n\t            if (relative) {\n\t                x += this.point.x;\n\t                y += this.point.y;\n\t            }\n\t\n\t            // Add current point\n\t            this.path.addPoint(x, y);\n\t\n\t            // Update current point\n\t            this.point = this.path.getPoint(-1);\n\t        }\n\t    }, {\n\t        key: 'addPoints',\n\t        value: function addPoints(points, relative) {\n\t            // For each couple of points\n\t            for (var i = 0, il = points.length; i < il; i += 2) {\n\t                this.addPoint(points[i], points[i + 1], relative);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'setMatrix',\n\t        value: function setMatrix(matrix) {\n\t            this.matrix = matrix || [1, 0, 0, 1, 0, 0];\n\t        }\n\t    }, {\n\t        key: 'addMatrix',\n\t        value: function addMatrix(matrix) {\n\t            this.matrix = [this.matrix[0] * matrix[0] + this.matrix[2] * matrix[1], this.matrix[1] * matrix[0] + this.matrix[3] * matrix[1], this.matrix[0] * matrix[2] + this.matrix[2] * matrix[3], this.matrix[1] * matrix[2] + this.matrix[3] * matrix[3], this.matrix[0] * matrix[4] + this.matrix[2] * matrix[5] + this.matrix[4], this.matrix[1] * matrix[4] + this.matrix[3] * matrix[5] + this.matrix[5]];\n\t        }\n\t    }, {\n\t        key: 'translate',\n\t        value: function translate(x, y) {\n\t            y = y === undefined ? 0 : y;\n\t            this.addMatrix([1, 0, 0, 1, x, y]);\n\t        }\n\t    }, {\n\t        key: 'rotate',\n\t        value: function rotate(angle, x, y) {\n\t            angle = angle * DEG_TO_RAD;\n\t\n\t            if (arguments.length == 2) {\n\t                this.addMatrix([1, 0, 0, 1, x, y]);\n\t            }\n\t\n\t            this.addMatrix([Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0]);\n\t\n\t            if (arguments.length == 2) {\n\t                this.addMatrix([1, 0, 0, 1, -x, -y]);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'scale',\n\t        value: function scale(x, y) {\n\t            y = y === undefined ? x : y;\n\t            this.addMatrix([x, 0, 0, y, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'skewX',\n\t        value: function skewX(angle) {\n\t            this.addMatrix([1, 0, Math.tan(angle * DEG_TO_RAD), 1, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'skewY',\n\t        value: function skewY(angle) {\n\t            this.addMatrix([1, Math.tan(angle * DEG_TO_RAD), 0, 1, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'applyMatrix',\n\t        value: function applyMatrix(matrix) {\n\t            var _this2 = this;\n\t\n\t            matrix && this.addMatrix(matrix);\n\t\n\t            this.paths.forEach(function (path) {\n\t                path.transform(_this2.matrix);\n\t            });\n\t\n\t            this.setMatrix(null);\n\t\n\t            this.children.forEach(function (tag) {\n\t                tag.applyMatrix(matrix);\n\t            });\n\t        }\n\t    }]);\n\t\n\t    return Tag;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Tag = Tag;\n\texports.default = Tag;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.TagParser = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _trace = __webpack_require__(5);\n\t\n\tvar _path2 = __webpack_require__(1);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// SVG tag parser\n\tvar TagParser = function () {\n\t    // Class constructor...\n\t    function TagParser(tag, parser) {\n\t        _classCallCheck(this, TagParser);\n\t\n\t        // Init properties\n\t        this.tag = tag;\n\t        this.parser = parser;\n\t        this.currentCommand = null;\n\t        this.lastCommand = null;\n\t        this.pathData = null;\n\t        this.traceSettings = parser.traceSettings;\n\t    }\n\t\n\t    _createClass(TagParser, [{\n\t        key: 'parse',\n\t        value: function parse() {\n\t            var _this = this;\n\t\n\t            // Get internal parser from node name\n\t            var handler = this['_' + this.tag.name];\n\t\n\t            // Implemented tag handler?\n\t            if (!handler || typeof handler !== 'function') {\n\t                return this.parser._skipTag(this.tag, 'not yet implemented');\n\t            }\n\t\n\t            // Parse tag attributes\n\t            this._parseTagAttrs();\n\t\n\t            // Parse tag\n\t            var result = handler.call(this);\n\t\n\t            if (result && this.tag.getAttr('fill') && this.tag.paths[0].length) {\n\t                (function () {\n\t                    var paths = [];\n\t                    var debug = [];\n\t\n\t                    _this.tag.paths.forEach(function (path) {\n\t                        _this.tag.triangles = null;\n\t                        paths.push(path.getFlattenPoints());\n\t                        debug.push('[' + path.getFlattenPoints().join(',') + ']');\n\t                    });\n\t\n\t                    //console.log(paths.length, debug.join(','))\n\t                })();\n\t            }\n\t\n\t            return result;\n\t        }\n\t\n\t        // Parse the tag attributes\n\t\n\t    }, {\n\t        key: '_parseTagAttrs',\n\t        value: function _parseTagAttrs() {\n\t            var _this2 = this;\n\t\n\t            // Get tag attributes\n\t            var attrs = this.tag.element.attributes;\n\t\n\t            if (!attrs) {\n\t                return null;\n\t            }\n\t\n\t            // For each attribute\n\t            var attr = void 0,\n\t                value = void 0,\n\t                style = void 0;\n\t\n\t            Object.keys(attrs).some(function (key) {\n\t                // Current attribute\n\t                attr = attrs[key];\n\t\n\t                // Normalize attribute value\n\t                value = _this2._normalizeTagAttr(attr);\n\t\n\t                if (value === false) {\n\t                    return false; // continue\n\t                }\n\t\n\t                // Special case\n\t                if (attr.nodeName === 'style') {\n\t                    style = value;\n\t                } else {\n\t                    // Set new attribute name/value\n\t                    _this2.tag.setAttr(attr.nodeName, value);\n\t                }\n\t            });\n\t\n\t            // If style attribute (override tag attributes)\n\t            // TODO get/parse global style and override this one...\n\t            style && style.split(';').some(function (attr) {\n\t                // Current style\n\t                attr = attr.split(':');\n\t                attr = { nodeName: attr[0], nodeValue: attr[1] };\n\t\n\t                // Normalize attribute value\n\t                value = _this2._normalizeTagAttr(attr);\n\t\n\t                if (value === false) {\n\t                    return false; // continue\n\t                }\n\t\n\t                // Set new attribute name/value\n\t                _this2.tag.setAttr(attr.nodeName, value);\n\t            });\n\t\n\t            // Set inherited color\n\t            var colorsAttrs = ['fill', 'stroke', 'color'];\n\t\n\t            colorsAttrs.forEach(function (attrName) {\n\t                if (_this2.tag.getAttr(attrName) === 'inherit') {\n\t                    _this2.tag.setAttr(attrName, _this2.tag.parent.getAttr(attrName, 'none'));\n\t                }\n\t            });\n\t\n\t            // Parse viewBox attribute\n\t            this._parseViewBoxAttr();\n\t\n\t            // Parse transform attribute\n\t            this._parseTransformAttr();\n\t        }\n\t\n\t        // Normalize tag attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttr',\n\t        value: function _normalizeTagAttr(attr) {\n\t            // Normalize whitespaces\n\t            var value = attr.nodeValue.replace(/(\\r?\\n|\\r)+/gm, ' ') // Remove all new line chars\n\t            .replace(/\\s+/gm, ' ') // Reduce multiple whitespaces\n\t            .trim(); // Remove trailing whitespaces\n\t\n\t            if (!value.length) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'empty');\n\t            }\n\t\n\t            // Filters\n\t            switch (attr.nodeName) {\n\t                // Normalize size unit -> to px\n\t                case 'x':\n\t                case 'y':\n\t                case 'x1':\n\t                case 'y1':\n\t                case 'x2':\n\t                case 'y2':\n\t                case 'r':\n\t                case 'rx':\n\t                case 'ry':\n\t                case 'cx':\n\t                case 'cy':\n\t                case 'width':\n\t                case 'height':\n\t                case 'fontSize':\n\t                case 'strokeWidth':\n\t                    value = this._normalizeTagAttrUnit(attr);\n\t                    break;\n\t\n\t                // Normalize points attribute\n\t                case 'points':\n\t                case 'viewBox':\n\t                    value = this._normalizeTagAttrPoints(attr);\n\t                    break;\n\t\n\t                // Range limit to [0 - 1]\n\t                case 'opacity':\n\t                case 'fillOpacity':\n\t                case 'strokeOpacity':\n\t                    value = this._normalizeTagAttrRange(attr, 0, 1);\n\t                    break;\n\t\n\t                case 'preserveAspectRatio':\n\t                    value = this._normalizeTagAttrPreserveAspectRatio(attr);\n\t                    break;\n\t            }\n\t\n\t            // Return normalized value\n\t            return value;\n\t        }\n\t\n\t        // Normalize attribute unit to px\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrUnit',\n\t        value: function _normalizeTagAttrUnit(attr) {\n\t            var stringValue = attr.nodeValue.toLowerCase();\n\t            var floatValue = parseFloat(stringValue);\n\t\n\t            if (isNaN(floatValue)) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric value allowed');\n\t            }\n\t\n\t            if (stringValue.indexOf('mm') !== -1) {\n\t                return floatValue * 3.5433070869;\n\t            }\n\t\n\t            if (stringValue.indexOf('cm') !== -1) {\n\t                return floatValue * 35.433070869;\n\t            }\n\t\n\t            if (stringValue.indexOf('in') !== -1) {\n\t                return floatValue * 90.0;\n\t            }\n\t\n\t            if (stringValue.indexOf('pt') !== -1) {\n\t                return floatValue * 1.25;\n\t            }\n\t\n\t            if (stringValue.indexOf('pc') !== -1) {\n\t                return floatValue * 15.0;\n\t            }\n\t\n\t            return floatValue;\n\t        }\n\t\n\t        // Normalize points attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrPoints',\n\t        value: function _normalizeTagAttrPoints(attr) {\n\t            var points = this._parseNumbers(attr.nodeValue);\n\t\n\t            if (points === false) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed');\n\t            }\n\t\n\t            if (!points.length) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'empty points list');\n\t            }\n\t\n\t            if (points.length % 0) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'the number of points must be even');\n\t            }\n\t\n\t            return points;\n\t        }\n\t\n\t        // Normalize range attribute like \"opacity\"\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrRange',\n\t        value: function _normalizeTagAttrRange(attr, min, max) {\n\t            var stringValue = attr.nodeValue.trim();\n\t            var floatValue = parseFloat(stringValue);\n\t\n\t            if (isNaN(floatValue)) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed');\n\t            }\n\t\n\t            if (floatValue < min || floatValue > max) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'out of range [' + min + ', ' + max + ']');\n\t            }\n\t\n\t            return floatValue;\n\t        }\n\t\n\t        // Parse points string as numbers array\n\t\n\t    }, {\n\t        key: '_parseNumbers',\n\t        value: function _parseNumbers(points) {\n\t            // http://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly\n\t            if (typeof points === 'string') {\n\t                points = points.split(/([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/g).filter(function (point) {\n\t                    return point && ['', ','].indexOf(point.trim()) === -1;\n\t                });\n\t            }\n\t\n\t            // Normalize to float values\n\t            points = points.map(parseFloat);\n\t\n\t            // Test if all numbers is valid\n\t            if (points.some(isNaN)) {\n\t                return false;\n\t            }\n\t\n\t            return points;\n\t        }\n\t\n\t        // Normalize the preserveAspectRatio attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrPreserveAspectRatio',\n\t        value: function _normalizeTagAttrPreserveAspectRatio(attr) {\n\t            var params = {\n\t                defer: false,\n\t                align: 'none',\n\t                meet: true,\n\t                slice: false\n\t            };\n\t\n\t            var rawParams = attr.nodeValue;\n\t\n\t            if (rawParams.indexOf('defer') === 0) {\n\t                rawParams = rawParams.substr(6);\n\t                params.defer = true;\n\t            }\n\t\n\t            rawParams = rawParams.split(' ');\n\t            params.align = rawParams[0];\n\t            params.meet = rawParams[1] || 'meet';\n\t            params.meet = params.meet === 'meet';\n\t            params.slice = !params.meet;\n\t\n\t            return params;\n\t        }\n\t\n\t        // Parse viewBox attribute and set transformations\n\t\n\t    }, {\n\t        key: '_parseViewBoxAttr',\n\t        value: function _parseViewBoxAttr() {\n\t            // Get viewBox attribute\n\t            var viewBox = this.tag.getAttr('viewBox', null);\n\t\n\t            // No viewBox...\n\t            if (viewBox === null) {\n\t                return null;\n\t            }\n\t\n\t            // Update size attributes\n\t            var width = this.tag.getAttr('width', viewBox[2]);\n\t            var height = this.tag.getAttr('height', viewBox[3]);\n\t\n\t            this.tag.setAttr('width', width);\n\t            this.tag.setAttr('height', height);\n\t\n\t            // Scale to match viewBox\n\t            // TODO clip path if preserveAspectRatio.slice\n\t            var scaleX = width / viewBox[2];\n\t            var scaleY = height / viewBox[3];\n\t            var translateX = viewBox[0];\n\t            var translateY = viewBox[1];\n\t\n\t            var preserveAspectRatio = this.tag.getAttr('preserveAspectRatio', 'meet xMidYMid');\n\t\n\t            if (preserveAspectRatio) {\n\t                var newWidth = void 0,\n\t                    newHeight = void 0;\n\t\n\t                if (preserveAspectRatio.meet) {\n\t                    if (scaleX > scaleY) {\n\t                        scaleX = scaleY;\n\t                        newWidth = viewBox[2] * scaleX;\n\t                    } else if (scaleX < scaleY) {\n\t                        scaleY = scaleX;\n\t                        newHeight = viewBox[3] * scaleY;\n\t                    }\n\t                } else if (preserveAspectRatio.slice) {\n\t                    if (scaleX < scaleY) {\n\t                        scaleX = scaleY;\n\t                        newWidth = viewBox[2] * scaleX;\n\t                    } else if (scaleX > scaleY) {\n\t                        scaleY = scaleX;\n\t                        newHeight = viewBox[3] * scaleY;\n\t                    }\n\t                }\n\t\n\t                if (newWidth !== undefined) {\n\t                    if (preserveAspectRatio.align === 'xMidYMid') {\n\t                        this.tag.translate((width - newWidth) / 2, 0);\n\t                    } else if (preserveAspectRatio.align === 'xMaxYMax') {\n\t                        this.tag.translate(width - newWidth, 0);\n\t                    }\n\t                } else if (newHeight !== undefined) {\n\t                    if (preserveAspectRatio.align === 'xMidYMid') {\n\t                        this.tag.translate(0, (height - newHeight) / 2);\n\t                    } else if (preserveAspectRatio.align === 'xMaxYMax') {\n\t                        this.tag.translate(0, height - newHeight);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.tag.scale(scaleX, scaleY);\n\t            this.tag.translate(-translateX, -translateY);\n\t        }\n\t\n\t        // Parse transform attribute and set transformations\n\t\n\t    }, {\n\t        key: '_parseTransformAttr',\n\t        value: function _parseTransformAttr() {\n\t            var _this3 = this;\n\t\n\t            // Get transform attribute\n\t            var transformAttr = this.tag.getAttr('transform', null);\n\t\n\t            // No transformation...\n\t            if (transformAttr === null || !transformAttr.length) {\n\t                return null;\n\t            }\n\t\n\t            // Parse attribute (split group on closing parenthesis)\n\t            var transformations = transformAttr.split(')');\n\t\n\t            // Remove last entry due to last \")\" found\n\t            transformations.pop();\n\t\n\t            // For each transformation\n\t            var transform = void 0,\n\t                type = void 0,\n\t                params = void 0;\n\t\n\t            transformations.some(function (raw) {\n\t                // Split name and value on opening parenthesis\n\t                transform = raw.split('(');\n\t\n\t                // Invalid parts number\n\t                if (transform.length !== 2) {\n\t                    return _this3.parser._skipTagAttr(_this3.tag, transformAttr, 'malformed'); // continue\n\t                }\n\t\n\t                type = transform[0].trim();\n\t\n\t                // Quik hack 1/2\n\t                var func = type;\n\t                if (func === 'matrix') {\n\t                    func = 'addMatrix';\n\t                }\n\t\n\t                // Get tag transform method\n\t                var tagTransform = _this3.tag[func];\n\t\n\t                if (typeof tagTransform !== 'function') {\n\t                    return _this3.parser._skipTagAttr(_this3.tag, transformAttr, 'unsupported transform type :' + type);\n\t                }\n\t\n\t                params = transform[1].trim();\n\t                params = _this3._parseNumbers(params);\n\t\n\t                // Skip empty value\n\t                if (!params.length) {\n\t                    return _this3.parser._skipTagAttr(_this3.tag, transformAttr, 'malformed transform type :' + type);\n\t                }\n\t\n\t                // Quik hack 2/2\n\t                if (func == 'addMatrix') {\n\t                    params = [params];\n\t                }\n\t\n\t                // Call tag transform method like \"tag.translate(param1, ..., paramN)\"\n\t                tagTransform.apply(_this3.tag, params);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_newPath',\n\t        value: function _newPath() {\n\t            this.tag.newPath();\n\t        }\n\t    }, {\n\t        key: '_clearPath',\n\t        value: function _clearPath() {\n\t            this.tag.clearPath();\n\t        }\n\t    }, {\n\t        key: '_closePath',\n\t        value: function _closePath() {\n\t            return this.tag.closePath();\n\t        }\n\t    }, {\n\t        key: '_addPoints',\n\t        value: function _addPoints(points, relative) {\n\t            if (!points.length) {\n\t                return this.parser._skipTag(this.tag, 'empty points list');\n\t            }\n\t\n\t            if (points.length % 0) {\n\t                return this.parser._skipTag(this.tag, 'the number of points must be even');\n\t            }\n\t\n\t            relative = arguments.length < 2 && this.currentCommand.relative;\n\t\n\t            this.tag.addPoints(points, relative);\n\t            return true;\n\t        }\n\t\n\t        // SVG specs at https://www.w3.org/TR/SVG11/\n\t\n\t    }, {\n\t        key: '_svg',\n\t        value: function _svg() {\n\t            // Only parse the root SVG tag as main document\n\t            if (this.parser.document) {\n\t                // Handled tag\n\t                return true;\n\t            }\n\t\n\t            // Get the document size\n\t            var width = this.tag.getAttr('width');\n\t            var height = this.tag.getAttr('height');\n\t\n\t            // Invalid size\n\t            if (!width || width < 0 || !height || height < 0) {\n\t                throw new Error('Invalid document size: ' + width + ' / ' + height);\n\t            }\n\t\n\t            // Set document size\n\t            this.parser.document = {\n\t                width: width,\n\t                height: height\n\t            };\n\t\n\t            // Get document viewBox or set default to document size\n\t            var viewBox = this.tag.getAttr('viewBox', [0, 0, width, height]);\n\t\n\t            this.parser.document.viewBox = {\n\t                x: viewBox[0],\n\t                y: viewBox[1],\n\t                width: viewBox[2],\n\t                height: viewBox[3]\n\t            };\n\t\n\t            // Check inkscape version\n\t            if (this.parser.editor.name === 'inkscape') {\n\t                this.parser.editor.version = this.tag.getAttr('inkscape:version');\n\t            }\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_title',\n\t        value: function _title() {\n\t            // Register the first encountered title tag as document title\n\t            if (this.parser.document && !this.parser.document.title) {\n\t                this.parser.document.title = this.tag.element.textContent;\n\t            }\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_desc',\n\t        value: function _desc() {\n\t            // Register the first encountered desc tag as document description\n\t            if (this.parser.document && !this.parser.document.description) {\n\t                this.parser.document.description = this.tag.element.textContent;\n\t            }\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_defs',\n\t        value: function _defs() {\n\t            var _this4 = this;\n\t\n\t            // Register all child element with an id attribute\n\t            this.tag.element.childNodes.forEach(function (childNode) {\n\t                childNode.id && (_this4.parser.defs[childNode.id] = childNode);\n\t            });\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_use',\n\t        value: function _use() {\n\t            // Get the target id\n\t            var target = this.tag.getAttr('xlink:href').replace(/^#/, '');\n\t\n\t            // Try to get the defined element\n\t            var element = this.parser.defs[target];\n\t\n\t            if (!element) {\n\t                return this.parser._skipTag(this.tag, 'undefined reference [' + target + ']');\n\t            }\n\t\n\t            // Parse the defined element and set new parent from <use> tag parent\n\t            var useTag = this.parser._parseElement(element, this.tag.parent);\n\t\n\t            if (!useTag) {\n\t                return this.parser._skipTag(this.tag, 'empty reference [' + target + ']');\n\t            }\n\t\n\t            // Set matrix from real parent (<use>)\n\t            useTag.setMatrix(this.tag.matrix);\n\t\n\t            // Replace the use tag with new one\n\t            this.tag.parent.addChild(useTag);\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_g',\n\t        value: function _g() {\n\t            // Set the tag layer name\n\t            this.tag.setLayerName();\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_line',\n\t        value: function _line() {\n\t            // Handled tag\n\t            return this._path(['M', this.tag.getAttr('x1'), this.tag.getAttr('y1'), 'L', this.tag.getAttr('x2'), this.tag.getAttr('y2')]);\n\t        }\n\t    }, {\n\t        key: '_polyline',\n\t        value: function _polyline() {\n\t            var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t            var points = this.tag.getAttr('points');\n\t            var path = ['M', points.shift(), points.shift(), 'L'];\n\t\n\t            path = path.concat(points);\n\t            close && path.push('Z');\n\t\n\t            // Handled tag\n\t            return this._path(path);\n\t        }\n\t    }, {\n\t        key: '_polygon',\n\t        value: function _polygon() {\n\t            // Handled like polyline but closed\n\t            return this._polyline(true);\n\t        }\n\t    }, {\n\t        key: '_rect',\n\t        value: function _rect() {\n\t            // Get rectangle attributes\n\t            var w = this.tag.getAttr('width');\n\t            var h = this.tag.getAttr('height');\n\t            var x = this.tag.getAttr('x', 0);\n\t            var y = this.tag.getAttr('y', 0);\n\t            var rx = this.tag.getAttr('rx', null);\n\t            var ry = this.tag.getAttr('ry', null);\n\t\n\t            // Simple rect\n\t            if (!rx && !ry) {\n\t                // Handled tag\n\t                return this._path(['M', x, y, 'h', w, 'v', h, 'h', -w, 'z']);\n\t            }\n\t\n\t            // If a properly specified value is provided for ‘rx’, but not for ‘ry’,\n\t            // then set both rx and ry to the value of ‘rx’ and vis-vera...\n\t            if (rx === null) rx = ry;\n\t            if (ry === null) ry = rx;\n\t\n\t            // A negative value is an error\n\t            if (rx === null || rx === null || rx < 0 || ry < 0) {\n\t                // Skip tag\n\t                return this.parser._skipTag(this.tag, 'negative value for \"rx/ry\" not allowed');\n\t            }\n\t\n\t            // If rx is greater than half of ‘width’, then set rx to half of ‘width’.\n\t            // If ry is greater than half of ‘height’, then set ry to half of ‘height’.\n\t            if (rx > w / 2) rx = w / 2;\n\t            if (ry > h / 2) ry = h / 2;\n\t\n\t            var dx = rx * 2;\n\t            var dy = ry * 2;\n\t\n\t            // Handled tag\n\t            return this._path(['M', x + rx, y, 'h', w - dx, 'c', rx, 0, rx, ry, rx, ry, 'v', h - dy, 'c', 0, ry, -rx, ry, -rx, ry, 'h', -w + dx, 'c', -rx, 0, -rx, -ry, -rx, -ry, 'v', -h + dy, 'c', 0, 0, 0, -ry, rx, -ry, 'z']);\n\t        }\n\t    }, {\n\t        key: '_circle',\n\t        value: function _circle() {\n\t            var r = this.tag.getAttr('r', 0);\n\t\n\t            if (r <= 0) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            var cx = this.tag.getAttr('cx', 0);\n\t            var cy = this.tag.getAttr('cy', 0);\n\t\n\t            // Handled tag\n\t            return this._path(['M', cx - r, cy, 'A', r, r, 0, 0, 0, cx, cy + r, 'A', r, r, 0, 0, 0, cx + r, cy, 'A', r, r, 0, 0, 0, cx, cy - r, 'A', r, r, 0, 0, 0, cx - r, cy, 'Z']);\n\t        }\n\t    }, {\n\t        key: '_ellipse',\n\t        value: function _ellipse() {\n\t            var rx = this.tag.getAttr('rx', 0);\n\t            var ry = this.tag.getAttr('ry', 0);\n\t\n\t            if (rx <= 0 || ry <= 0) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            var cx = this.tag.getAttr('cx', 0);\n\t            var cy = this.tag.getAttr('cy', 0);\n\t\n\t            // Handled tag\n\t            return this._path(['M', cx - rx, cy, 'A', rx, ry, 0, 0, 0, cx, cy + ry, 'A', rx, ry, 0, 0, 0, cx + rx, cy, 'A', rx, ry, 0, 0, 0, cx, cy - ry, 'A', rx, ry, 0, 0, 0, cx - rx, cy, 'Z']);\n\t        }\n\t    }, {\n\t        key: '_paths',\n\t        value: function _paths(type, num, points) {\n\t            if (points.length > num) {\n\t                var handler = void 0,\n\t                    result = true;\n\t\n\t                while (result && points.length) {\n\t                    handler = this['_path' + type];\n\t                    result = handler.call(this, points.splice(0, num));\n\t                }\n\t\n\t                return result;\n\t            }\n\t\n\t            return null;\n\t        }\n\t    }, {\n\t        key: '_path',\n\t        value: function _path(path) {\n\t            var _this5 = this;\n\t\n\t            // Provided path\n\t            if (path && typeof path !== 'string') {\n\t                path = path.join(' ');\n\t            }\n\t\n\t            // Get the paths data attribute value\n\t            var dAttr = path || this.tag.getAttr('d', null);\n\t\n\t            if (!dAttr) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            // Split on each commands\n\t            var commands = dAttr.match(/([M|Z|L|H|V|C|S|Q|T|A]+([^M|Z|L|H|V|C|S|Q|T|A]+)?)/gi);\n\t\n\t            if (!commands) {\n\t                return this.parser._skipTag(this.tag, 'malformed \"d\" attribute');\n\t            }\n\t\n\t            // For each command...\n\t            this.currentCommand = {\n\t                raw: null,\n\t                type: null,\n\t                params: null,\n\t                relative: null\n\t            };\n\t            this.lastCommand = this.currentCommand;\n\t            this.pathData = {};\n\t\n\t            var handler = null;\n\t            var parseError = false;\n\t\n\t            commands.some(function (raw) {\n\t                // Remove trailing whitespaces\n\t                raw = raw.trim();\n\t\n\t                // Extract command char and params\n\t                _this5.currentCommand.raw = raw;\n\t                _this5.currentCommand.type = raw[0].toUpperCase();\n\t                _this5.currentCommand.params = raw.substr(1).trim();\n\t                _this5.currentCommand.relative = _this5.currentCommand.type !== raw[0];\n\t\n\t                // Get path handler from command char\n\t                handler = _this5['_path' + _this5.currentCommand.type];\n\t\n\t                if (!handler || typeof handler !== 'function') {\n\t                    _this5.parser._skipTag(_this5.tag, 'unsupported path command [' + raw[0] + ']');\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Extract all numbers from arguments string\n\t                _this5.currentCommand.params = _this5._parseNumbers(_this5.currentCommand.params);\n\t\n\t                if (_this5.currentCommand.params === false) {\n\t                    _this5.parser._skipTag(_this5.tag, 'only numeric values are allowed in [' + _this5.currentCommand.raw + ']');\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Execute command parser\n\t                if (!handler.call(_this5, _this5.currentCommand.params)) {\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Update last command\n\t                _this5.lastCommand = {};\n\t\n\t                Object.keys(_this5.currentCommand).forEach(function (key) {\n\t                    _this5.lastCommand[key] = _this5.currentCommand[key];\n\t                });\n\t            });\n\t\n\t            // Skip tag\n\t            if (parseError) {\n\t                this._clearPath();\n\t                return false;\n\t            }\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_pathM',\n\t        value: function _pathM(points) {\n\t            // New path\n\t            this._newPath();\n\t\n\t            // Set the current point (start of new path)\n\t            // If is followed by multiple pairs of coordinates,\n\t            // the subsequent pairs are treated as implicit lineto commands.\n\t            return this._addPoints(points);\n\t        }\n\t    }, {\n\t        key: '_pathZ',\n\t        value: function _pathZ() {\n\t            this._closePath();\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_pathL',\n\t        value: function _pathL(points) {\n\t            return this._addPoints(points);\n\t        }\n\t    }, {\n\t        key: '_pathH',\n\t        value: function _pathH(points) {\n\t            var _this6 = this;\n\t\n\t            return points.every(function (x) {\n\t                return _this6._addPoints([x, _this6.currentCommand.relative ? 0 : _this6.tag.point.y]);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_pathV',\n\t        value: function _pathV(points) {\n\t            var _this7 = this;\n\t\n\t            return points.every(function (y) {\n\t                return _this7._addPoints([_this7.currentCommand.relative ? 0 : _this7.tag.point.x, y]);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_pathC',\n\t        value: function _pathC(points) {\n\t            // Multiple paths\n\t            var result = this._paths('C', 6, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = points[0] + (rl ? p1.x : 0);\n\t            var y1 = points[1] + (rl ? p1.y : 0);\n\t            var x2 = points[2] + (rl ? p1.x : 0);\n\t            var y2 = points[3] + (rl ? p1.y : 0);\n\t            var x = points[4] + (rl ? p1.x : 0);\n\t            var y = points[5] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x2 = x2;\n\t            this.pathData.y2 = y2;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x2, y2);\n\t            var p4 = new _path2.Point(x, y);\n\t\n\t            //console.log('C', p1, p2, p3, p4)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : control point\n\t            // p4  : end point\n\t            var tracer = new _trace.CubicBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3, p4: p4 }); // => [x,y, x,y, ...]\n\t            // let tracer = trace(CubicBezier, this.traceSettings)\n\t            // let coords = tracer({ p1, p2, p3, p4 })\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathS',\n\t        value: function _pathS(points) {\n\t            // Multiple paths\n\t            var result = this._paths('S', 4, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = p1.x;\n\t            var y1 = p1.y;\n\t\n\t            if (this.lastCommand.type === 'S' || this.lastCommand.type === 'C') {\n\t                x1 -= this.pathData.x2 - x1;\n\t                y1 -= this.pathData.y2 - y1;\n\t            }\n\t\n\t            var x2 = points[0] + (rl ? p1.x : 0);\n\t            var y2 = points[1] + (rl ? p1.y : 0);\n\t            var x = points[2] + (rl ? p1.x : 0);\n\t            var y = points[3] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x2 = x2;\n\t            this.pathData.y2 = y2;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x2, y2);\n\t            var p4 = new _path2.Point(x, y);\n\t\n\t            //console.log('S', p1, p2, p3, p4)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : control point\n\t            // p4  : end point\n\t            var tracer = new _trace.CubicBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3, p4: p4 }); // => [x,y, x,y, ...]\n\t            // let tracer = trace(CubicBezier, this.traceSettings)\n\t            // let coords = tracer({ p1, p2, p3, p4 })\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathQ',\n\t        value: function _pathQ(points) {\n\t            // Multiple paths\n\t            var result = this._paths('Q', 4, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = points[0] + (rl ? p1.x : 0);\n\t            var y1 = points[1] + (rl ? p1.y : 0);\n\t            var x = points[2] + (rl ? p1.x : 0);\n\t            var y = points[3] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x1 = x1;\n\t            this.pathData.y1 = y1;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x, y);\n\t\n\t            //console.log('Q', p1, p2, p3)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : end point\n\t            var tracer = new _trace.QuadricBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathT',\n\t        value: function _pathT(points) {\n\t            // Multiple paths\n\t            var result = this._paths('T', 2, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = p1.x;\n\t            var y1 = p1.y;\n\t\n\t            if (this.lastCommand.type === 'Q' || this.lastCommand.type === 'T') {\n\t                x1 -= this.pathData.x1 - x1;\n\t                y1 -= this.pathData.y1 - y1;\n\t            }\n\t\n\t            var x = points[0] + (rl ? p1.x : 0);\n\t            var y = points[1] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x1 = x1;\n\t            this.pathData.y1 = y1;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x, y);\n\t\n\t            //console.log('T', p1, p2, p3)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : end point\n\t            var tracer = new _trace.QuadricBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathA',\n\t        value: function _pathA(points) {\n\t            // Multiple paths\n\t            var result = this._paths('A', 7, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var rl = this.currentCommand.relative;\n\t            var p1 = this.tag.point;\n\t            var rx = points[0];\n\t            var ry = points[1];\n\t            var angle = points[2];\n\t            var large = !!points[3];\n\t            var sweep = !!points[4];\n\t            var x = points[5] + (rl ? p1.x : 0);\n\t            var y = points[6] + (rl ? p1.y : 0);\n\t            var p2 = new _path2.Point(x, y);\n\t\n\t            //console.log('A', p1, rx, ry, angle, large, sweep, p2)\n\t\n\t            var tracer = new _trace.Arc(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, rx: rx, ry: ry, angle: angle, large: large, sweep: sweep, p2: p2 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }]);\n\t\n\t    return TagParser;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.TagParser = TagParser;\n\texports.default = TagParser;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.QuadricBezier = exports.CubicBezier = exports.Arc = undefined;\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Base code from : https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js\n\t\n\t\n\tvar _path = __webpack_require__(1);\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar MATH_PI_2 = Math.PI * 2;\n\tvar DEG_TO_RAD = Math.PI / 180;\n\t\n\tfunction mod(x, m) {\n\t    return (x % m + m) % m;\n\t}\n\t\n\tfunction clamp(val, min, max) {\n\t    return Math.min(Math.max(val, min), max);\n\t}\n\t\n\tfunction distance(p0, p1) {\n\t    return Math.sqrt(Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2));\n\t}\n\t\n\tfunction angle(v0, v1) {\n\t    var p = v0.x * v1.x + v0.y * v1.y;\n\t    var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));\n\t    return (v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1) * Math.acos(p / n);\n\t}\n\t\n\t// Abstract class\n\t\n\tvar TraceBase = function () {\n\t    function TraceBase(settings) {\n\t        _classCallCheck(this, TraceBase);\n\t\n\t        // Set defaults properties\n\t        this.path = []; // Points collection [x,y, x,y, ...]\n\t        this.linear = true; // Linear trace mode\n\t        this.step = 0.01; // Step resolution if linear mode = false\n\t        this.resolution = 500; // Number of segments we use to approximate arc length\n\t        this.segmentLength = 0.1; // Segment length\n\t\n\t        // Update properties from user settings\n\t        Object.assign(this, settings || {});\n\t\n\t        // Arc length properties\n\t        this.arcLength = null;\n\t        this.arcLengthMap = null;\n\t    }\n\t\n\t    _createClass(TraceBase, [{\n\t        key: '_clearPath',\n\t        value: function _clearPath() {\n\t            this.path = [];\n\t        }\n\t    }, {\n\t        key: 'getPath',\n\t        value: function getPath() {\n\t            return this.path;\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            return new _path.Point(0, 0);\n\t        }\n\t    }, {\n\t        key: '_addPoint',\n\t        value: function _addPoint(point) {\n\t            this.path.push(point.x, point.y);\n\t        }\n\t    }, {\n\t        key: '_postTrace',\n\t        value: function _postTrace() {\n\t            // Do additional tasks\n\t        }\n\t    }, {\n\t        key: '_approximateLength',\n\t        value: function _approximateLength() {\n\t            var arcLength = 0;\n\t            var arcLengthMap = [];\n\t            var prevPoint = this.getPointAtT(0);\n\t\n\t            var i = void 0,\n\t                t = void 0,\n\t                nextPoint = void 0;\n\t\n\t            for (i = 0; i < this.resolution; i++) {\n\t                t = clamp(i * (1 / this.resolution), 0, 1);\n\t                nextPoint = this.getPointAtT(t);\n\t                arcLength += distance(prevPoint, nextPoint);\n\t\n\t                arcLengthMap.push({ t: t, arcLength: arcLength });\n\t\n\t                prevPoint = nextPoint;\n\t            }\n\t\n\t            // Last stretch to the endpoint\n\t            nextPoint = this.getPointAtT(1);\n\t            arcLength += distance(prevPoint, nextPoint);\n\t\n\t            arcLengthMap.push({ t: 1, arcLength: arcLength });\n\t            Object.assign(this, { arcLength: arcLength, arcLengthMap: arcLengthMap });\n\t        }\n\t    }, {\n\t        key: 'getPointAtU',\n\t        value: function getPointAtU(u) {\n\t            u = clamp(u, 0, 1);\n\t\n\t            var targetDistanceFromStartingPoint = u * this.arcLength;\n\t\n\t            var resultantT = 0;\n\t            var prevArcLength = 0;\n\t            var prevT = 0;\n\t\n\t            this.arcLengthMap.every(function (entry) {\n\t                var t = entry.t;\n\t                var arcLength = entry.arcLength;\n\t\n\t                // Once we go a past our target\n\t                // Lets interpolate from a previous to current\n\t                if (arcLength >= targetDistanceFromStartingPoint) {\n\t                    var endDiff = arcLength - targetDistanceFromStartingPoint;\n\t                    var startDiff = targetDistanceFromStartingPoint - prevArcLength;\n\t                    var linearFactor = startDiff / (endDiff + startDiff) || 0;\n\t\n\t                    resultantT = prevT + (t - prevT) * linearFactor;\n\t\n\t                    // Break\n\t                    return false;\n\t                }\n\t\n\t                prevArcLength = arcLength;\n\t                prevT = t;\n\t\n\t                return true;\n\t            });\n\t\n\t            return this.getPointAtT(resultantT);\n\t        }\n\t    }, {\n\t        key: 'trace',\n\t        value: function trace(settings) {\n\t            // Update properties from user settings\n\t            Object.assign(this, settings || {});\n\t\n\t            // Default getPoint settings\n\t            var getPoint = 'getPointAtT';\n\t            var step = this.step;\n\t\n\t            // Linear mode ?\n\t            if (this.linear) {\n\t                this._approximateLength();\n\t\n\t                var segments = Math.round(this.arcLength / this.segmentLength);\n\t\n\t                getPoint = 'getPointAtU';\n\t                step = 1 / segments;\n\t            }\n\t\n\t            // Clear points list\n\t            this._clearPath();\n\t\n\t            // Trace the path\n\t            for (var t = 0; t <= 1; t += step) {\n\t                this._addPoint(this[getPoint](t));\n\t            }\n\t\n\t            // Do additional tasks\n\t            this._postTrace();\n\t\n\t            // Return the path\n\t            return this.getPath();\n\t        }\n\t    }]);\n\t\n\t    return TraceBase;\n\t}();\n\t\n\t// Rewrite from https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js#L84\n\t\n\t\n\tvar Arc = function (_TraceBase) {\n\t    _inherits(Arc, _TraceBase);\n\t\n\t    function Arc() {\n\t        _classCallCheck(this, Arc);\n\t\n\t        return _possibleConstructorReturn(this, (Arc.__proto__ || Object.getPrototypeOf(Arc)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(Arc, [{\n\t        key: 'init',\n\t        value: function init(settings) {\n\t            // Update properties from user settings\n\t            Object.assign(this, settings || {});\n\t\n\t            // Get angle in radians\n\t            this.radians = mod(this.angle, 360) * DEG_TO_RAD;\n\t\n\t            // If the endpoints are identical, then this is equivalent\n\t            // to omitting the elliptical arc segment entirely.\n\t            if (this.p1.x === this.p2.x && this.p1.y === this.p2.y) {\n\t                return this.path;\n\t            }\n\t\n\t            this.rx = Math.abs(this.rx);\n\t            this.ry = Math.abs(this.ry);\n\t\n\t            // If rx = 0 or ry = 0 then this arc is treated as\n\t            // a straight line segment joining the endpoints.\n\t            if (this.rx === 0 || this.ry === 0) {\n\t                this.__addPoint(this.p1);\n\t                this.__addPoint(this.p2);\n\t                return this.path;\n\t            }\n\t\n\t            // Following \"Conversion from endpoint to center parameterization\"\n\t            // http://www.w3.org/TR/SVG/implnote.html#ArcConversionEndpointToCenter\n\t\n\t            // Step #1: Compute transformedPoint\n\t            var dx = (this.p1.x - this.p2.x) / 2;\n\t            var dy = (this.p1.y - this.p2.y) / 2;\n\t\n\t            var transformedPoint = {\n\t                x: Math.cos(this.radians) * dx + Math.sin(this.radians) * dy,\n\t                y: -Math.sin(this.radians) * dx + Math.cos(this.radians) * dy\n\t            };\n\t\n\t            // Ensure radii are large enough\n\t            var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(this.rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(this.ry, 2);\n\t\n\t            if (radiiCheck > 1) {\n\t                this.rx = Math.sqrt(radiiCheck) * this.rx;\n\t                this.ry = Math.sqrt(radiiCheck) * this.ry;\n\t            }\n\t\n\t            // Step #2: Compute transformedCenter\n\t            var cSquareNumerator = Math.pow(this.rx, 2) * Math.pow(this.ry, 2) - Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2);\n\t            var cSquareRootDenom = Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2);\n\t            var cRadicand = cSquareNumerator / cSquareRootDenom;\n\t\n\t            // Make sure this never drops below zero because of precision\n\t            cRadicand = cRadicand < 0 ? 0 : cRadicand;\n\t            var cCoef = (this.large !== this.sweep ? 1 : -1) * Math.sqrt(cRadicand);\n\t            var transformedCenter = {\n\t                x: cCoef * (this.rx * transformedPoint.y / this.ry),\n\t                y: cCoef * (-(this.ry * transformedPoint.x) / this.rx)\n\t            };\n\t\n\t            // Step #3: Compute center\n\t            this.center = {\n\t                x: Math.cos(this.radians) * transformedCenter.x - Math.sin(this.radians) * transformedCenter.y + (this.p1.x + this.p2.x) / 2,\n\t                y: Math.sin(this.radians) * transformedCenter.x + Math.cos(this.radians) * transformedCenter.y + (this.p1.y + this.p2.y) / 2\n\t            };\n\t\n\t            // Step #4: Compute start/sweep angles\n\t            // Start angle of the elliptical arc prior to the stretch and rotate operations.\n\t            // Difference between the start and end angles\n\t            var startVector = {\n\t                x: (transformedPoint.x - transformedCenter.x) / this.rx,\n\t                y: (transformedPoint.y - transformedCenter.y) / this.ry\n\t            };\n\t\n\t            var endVector = {\n\t                x: (-transformedPoint.x - transformedCenter.x) / this.rx,\n\t                y: (-transformedPoint.y - transformedCenter.y) / this.ry\n\t            };\n\t\n\t            this.startAngle = angle({ x: 1, y: 0 }, startVector);\n\t            this.sweepAngle = angle(startVector, endVector);\n\t\n\t            if (!this.sweep && this.sweepAngle > 0) {\n\t                this.sweepAngle -= MATH_PI_2;\n\t            } else if (this.sweep && this.sweepAngle < 0) {\n\t                this.sweepAngle += MATH_PI_2;\n\t            }\n\t\n\t            // We use % instead of `mod(..)` because we want it to be -360deg to 360deg(but actually in radians)\n\t            this.sweepAngle %= MATH_PI_2;\n\t        }\n\t    }, {\n\t        key: 'trace',\n\t        value: function trace(settings) {\n\t            this.init(settings);\n\t            return _get(Arc.prototype.__proto__ || Object.getPrototypeOf(Arc.prototype), 'trace', this).call(this);\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            var angle = this.startAngle + this.sweepAngle * t;\n\t\n\t            var x = this.rx * Math.cos(angle);\n\t            var y = this.ry * Math.sin(angle);\n\t\n\t            return new _path.Point(Math.cos(this.radians) * x - Math.sin(this.radians) * y + this.center.x, Math.sin(this.radians) * x + Math.cos(this.radians) * y + this.center.y);\n\t        }\n\t    }, {\n\t        key: '_postTrace',\n\t        value: function _postTrace() {\n\t            // Add last point in the path\n\t            this._addPoint(this.p2);\n\t        }\n\t    }]);\n\t\n\t    return Arc;\n\t}(TraceBase);\n\t\n\tvar CubicBezier = function (_TraceBase2) {\n\t    _inherits(CubicBezier, _TraceBase2);\n\t\n\t    function CubicBezier() {\n\t        _classCallCheck(this, CubicBezier);\n\t\n\t        return _possibleConstructorReturn(this, (CubicBezier.__proto__ || Object.getPrototypeOf(CubicBezier)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(CubicBezier, [{\n\t        key: '_B1',\n\t        value: function _B1(t) {\n\t            return t * t * t;\n\t        }\n\t    }, {\n\t        key: '_B2',\n\t        value: function _B2(t) {\n\t            return 3 * t * t * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_B3',\n\t        value: function _B3(t) {\n\t            return 3 * t * (1 - t) * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_B4',\n\t        value: function _B4(t) {\n\t            return (1 - t) * (1 - t) * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_C1',\n\t        value: function _C1(p1, p2, p3, p4, t) {\n\t            return p1 * this._B1(t) + p2 * this._B2(t) + p3 * this._B3(t) + p4 * this._B4(t);\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            return new _path.Point(this._C1(this.p1.x, this.p2.x, this.p3.x, this.p4.x, t), this._C1(this.p1.y, this.p2.y, this.p3.y, this.p4.y, t));\n\t        }\n\t    }, {\n\t        key: '_addPoint',\n\t        value: function _addPoint(point) {\n\t            this.path.unshift(point.x, point.y);\n\t        }\n\t    }]);\n\t\n\t    return CubicBezier;\n\t}(TraceBase);\n\t\n\tvar QuadricBezier = function (_TraceBase3) {\n\t    _inherits(QuadricBezier, _TraceBase3);\n\t\n\t    function QuadricBezier() {\n\t        _classCallCheck(this, QuadricBezier);\n\t\n\t        return _possibleConstructorReturn(this, (QuadricBezier.__proto__ || Object.getPrototypeOf(QuadricBezier)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(QuadricBezier, [{\n\t        key: '_B1',\n\t        value: function _B1(t) {\n\t            return t * t;\n\t        }\n\t    }, {\n\t        key: '_B2',\n\t        value: function _B2(t) {\n\t            return 2 * t * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_B3',\n\t        value: function _B3(t) {\n\t            return (1 - t) * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_C1',\n\t        value: function _C1(p1, p2, p3, t) {\n\t            return p1 * this._B1(t) + p2 * this._B2(t) + p3 * this._B3(t);\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            return new _path.Point(this._C1(this.p1.x, this.p2.x, this.p3.x, t), this._C1(this.p1.y, this.p2.y, this.p3.y, t));\n\t        }\n\t    }, {\n\t        key: '_addPoint',\n\t        value: function _addPoint(point) {\n\t            this.path.unshift(point.x, point.y);\n\t        }\n\t    }]);\n\t\n\t    return QuadricBezier;\n\t}(TraceBase);\n\t\n\t// Exports\n\t\n\t\n\texports.Arc = Arc;\n\texports.CubicBezier = CubicBezier;\n\texports.QuadricBezier = QuadricBezier;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// lw.svg-parser.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 269cb3ebf52074bad7fa","class Point {\n    // Class constructor...\n    constructor(x, y) {\n        // Init properties\n        this.x = parseFloat(x)\n        this.y = parseFloat(y)\n\n        if (isNaN(this.x) || isNaN(this.y)) {\n            console.error('x:', x, 'y:', y)\n            throw new Error('Float value!!!')\n        }\n    }\n\n    isEqual(point) {\n        return this.x === point.x && this.y === point.y\n    }\n}\n\nclass Path {\n    // Class constructor...\n    constructor(element, parent) {\n        // Init properties\n        this.points = []\n        this.length = 0\n    }\n\n    getPoints() {\n        return this.points\n    }\n\n    getFlattenPoints() {\n        let points = []\n        this.points.forEach(point => points.push(point.x, point.y))\n        return points\n    }\n\n    getPoint(i) {\n        return this.points[i < 0 ? this.length + i : i] || null\n    }\n\n    addPoint(x, y) {\n        this.points.push(new Point(x, y))\n        this.length = this.points.length\n    }\n\n    addPoints(points) {\n        // For each couple of points\n        for (let i = 0, il = points.length; i < il; i += 2) {\n            this.addPoint(points[i], points[i + 1])\n        }\n    }\n\n    isClosed() {\n        let firstPoint = this.getPoint(0)\n        return firstPoint && firstPoint.isEqual(this.getPoint(-1))\n    }\n\n    close() {\n        if (! this.isClosed() && this.length > 2) {\n            let firstPoint = this.getPoint(0)\n            this.addPoint(firstPoint.x, firstPoint.y)\n            return true\n        }\n\n        return false\n    }\n\n    transform(matrix) {\n        this.points = this.points.map(point => {\n            return new Point(\n                matrix[0] * point.x + matrix[2] * point.y + matrix[4],\n                matrix[1] * point.x + matrix[3] * point.y + matrix[5]\n            )\n        })\n    }\n}\n\n// Exports\nexport { Path, Point }\nexport default Path\n\n\n\n// WEBPACK FOOTER //\n// ./path.js","// Imports\nimport { Tag } from './tag'\nimport { TagParser } from './tagparser'\n\n// SVG parser class\nclass Parser {\n    // Class constructor...\n    constructor(settings) {\n        // Defaults settings\n        settings = settings || {}\n\n        // Init properties\n        this.element  = null // XML document Element object\n        this.editor   = null // Editor info { name, version, fingerprint }\n        this.document = null // Document info { width, height, viewBox }\n        this.defs     = null // Defined <defs> (DOM) nodes list by id\n        this.tags     = null // Tag objects hierarchy\n\n        // Trace settings (Arc, Bezier)\n        this.traceSettings = Object.assign({\n            linear       : true, // Linear trace mode\n            step         : 0.01, // Step resolution if linear mode = false\n            resolution   : 100,  // Number of segments we use to approximate arc length\n            segmentLength: 1,    // Segment length\n        }, settings.traceSettings || {})\n\n        // Supported tags by this lib\n        this.supportedTags = [\n            'svg', 'g', 'defs', 'use',\n            'line', 'polyline', 'polygon',\n            'rect', 'circle', 'ellipse', 'path',\n            'title', 'desc'\n        ]\n\n        // Tags list to includes/excludes\n        this.parseTags = settings.includes || this.supportedTags\n        this.skipTags  = settings.excludes || ['#text', '#comment']  // silent (no warning)\n\n        // User onTag callback ?\n        settings.onTag && this.onTag(settings.onTag, settings.onTagContext)\n    }\n\n    // Load raw XML string, XMLDocument, Element or File object\n    load(input) {\n        // Load raw XML string\n        if (typeof input === 'string') {\n            return this.loadFromString(input)\n        }\n\n        // Load File object\n        if (input instanceof File) {\n            return this.loadFromFile(input)\n        }\n\n        // Load XMLDocument object\n        if (input instanceof XMLDocument) {\n            return this.loadFromXMLDocument(input)\n        }\n\n        // Load Element object\n        if (input instanceof Element) {\n            return this.loadFromElement(input)\n        }\n\n        // Return rejected promise with an Error object\n        return Promise.reject(new Error('Unsupported input format.'))\n    }\n\n    // Load from Element object\n    loadFromElement(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof Element)) {\n                reject(new Error('Input param must be a Element object.'))\n            }\n\n            // Parser error\n            if (input.nodeName === 'parsererror') { // FF\n                reject(new Error(input.textContent))\n            }\n\n            if (input.nodeName === 'html' && input.getElementsByTagName('parsererror')) { // Chrome\n                reject(new Error(input.getElementsByTagName('parsererror')[0].textContent))\n            }\n\n            // Set document element\n            this.element = input\n\n            // Resolve promise\n            resolve(input)\n        })\n    }\n\n    // Load from XMLDocument object\n    loadFromXMLDocument(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof XMLDocument)) {\n                reject(new Error('Input param must be a XMLDocument object.'))\n            }\n\n            // Load from Element...\n            this.loadFromElement(input.documentElement).then(resolve).catch(reject)\n        })\n    }\n\n    // Load raw XML string\n    loadFromString(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (typeof input !== 'string') {\n                reject(new Error('Input param must be a string.'))\n            }\n\n            // Parse svg editor\n            this._parseEditor(input)\n\n            // Parse string as DOM object\n            let parser = new DOMParser()\n            let XMLDoc = parser.parseFromString(input, 'text/xml')\n\n            // Load from XMLDocument...\n            this.loadFromXMLDocument(XMLDoc).then(resolve).catch(reject)\n        })\n    }\n\n    // Try to get the svg editor from input string\n    _parseEditor(input) {\n        // Reset editor\n        this.editor = {\n            name       : 'unknown',\n            version    : null,\n            fingerprint: null\n        }\n\n        // Fingerprint matches\n        let fingerprint\n\n        // Inkscape\n        fingerprint = input.match(/<!-- Created with Inkscape .*-->/i)\n\n        if (fingerprint) {\n            this.editor.name        = 'inkscape'\n            this.editor.fingerprint = fingerprint[0]\n\n            return this.editor\n        }\n\n        // Illustrator\n        fingerprint = input.match(/<!-- Generator: Adobe Illustrator ([0-9\\.]+), .*-->/i)\n\n        if (fingerprint) {\n            this.editor.name        = 'illustrator'\n            this.editor.version     = fingerprint[1]\n            this.editor.fingerprint = fingerprint[0]\n\n            return this.editor\n        }\n\n        // Return default\n        return this.editor\n    }\n\n    // Load from File object\n    loadFromFile(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof File)) {\n                reject(new Error('Input param must be a File object.'))\n            }\n\n            // Create file reader\n            let reader = new FileReader()\n\n            // Register reader events handlers\n            reader.onload = event => {\n                this.loadFromString(event.target.result).then(resolve).catch(reject)\n            }\n\n            reader.onerror = event => {\n                reject(new Error('Error reading file : ' + input.name))\n            }\n\n            // Finally read input file as text\n            reader.readAsText(input)\n        })\n    }\n\n    // Parse the (loaded) element\n    parse(input) {\n        // Reset properties\n        this.document = null\n        this.defs     = {}\n        this.tags     = null\n\n        // Load input if provided\n        if (input) {\n            return new Promise((resolve, reject) => {\n                this.load(input).then(() => {\n                    resolve(this.parse())\n                }).catch(reject)\n            })\n        }\n\n        // Start parsing element\n        return new Promise((resolve, reject) => {\n            // If no element is loaded\n            if (! this.element) {\n                reject(new Error('No element is loaded, call the load method before.'))\n            }\n\n            // Parse the main Element (recursive)\n            this.tags = this._parseElement(this.element)\n\n            if (! this.tags) {\n                reject(new Error('No supported tags found.'))\n            }\n\n            // Apply matrix (recursive)\n            this.tags.applyMatrix()\n\n            // Resolve the promise\n            resolve(this.tags)\n        })\n    }\n\n    // On tag callback\n    _onTag(tag) {\n        console.info('onTag:', tag)\n    }\n\n    // Register on tag callback\n    onTag(callback, context) {\n        this._onTag = tag => callback.call(context || this, tag)\n    }\n\n    // Parse the provided Element and return an Tag collection (recursive)\n    _parseElement(element, parent) {\n        // Create base tag object\n        let tag = new Tag(element, parent)\n\n        // Exluded tag ?\n        if (this.skipTags.indexOf(tag.name) !== -1) {\n            return null // silent\n        }\n\n        // Supported tag ?\n        if (this.parseTags.indexOf(tag.name) === -1) {\n            return this._skipTag(tag, 'unsupported')\n        }\n\n        // Parse the tag\n        let tagParser = new TagParser(tag, this)\n\n        if (! tagParser.parse()) {\n            return false\n        }\n\n        // Call the on tag callback\n        this._onTag(tag)\n\n        // Parse child nodes\n        let childTag\n\n        element.childNodes.forEach(childNode => {\n            // Parse child element\n            if (childTag = this._parseElement(childNode, tag)) {\n                tag.addChild(childTag)\n            }\n        })\n\n        // Empty group\n        if (['svg', 'g'].indexOf(tag.name) !== -1 && ! tag.children.length) {\n            return this._skipTag(tag, 'empty')\n        }\n\n        // Return tag object\n        return tag\n    }\n\n    // Log skip tag warning message\n    _skipTag(tag, message) {\n        console.warn('Skip tag :', message + ':', tag)\n        return false\n    }\n\n    // Log skip tag attribute warning message\n    _skipTagAttr(tag, attr, message) {\n        console.warn('Skip tag attribute :', message + ':', attr, tag)\n        return false\n    }\n\n}\n\n// Exports\nexport { Parser }\nexport default Parser\n\n\n\n// WEBPACK FOOTER //\n// ./parser.js","import { Path, Point } from './path'\n\nconst DEG_TO_RAD = Math.PI / 180\n\n// SVG tag class\nclass Tag {\n    // Class constructor...\n    constructor(element, parent) {\n        // Init properties\n        this.element  = element\n        this.name     = element.nodeName.toLowerCase()\n        this.parent   = parent || null\n        this.layer    = null\n        this.attrs    = {}\n        this.children = []\n        this.paths    = []\n        this.matrix   = null\n        this.path     = new Path()\n        this.point    = new Point(0, 0)\n\n        // Add first path\n        this.paths.push(this.path)\n\n        // Set the matrix\n        this.setMatrix(this.parent && this.parent.matrix)\n\n        // Clone parent attributes\n        if (this.parent && (this.parent.name === 'g' || this.parent.name === 'svg')) {\n            // Inherit layer name\n            this.layer = this.parent.layer\n\n            // Inherit parent attributes\n            let excludes = ['transform', 'width', 'height']\n\n            Object.keys(this.parent.attrs).forEach(key => {\n                if (excludes.indexOf(key) === -1) {\n                    this.setAttr(key, this.parent.attrs[key])\n                }\n            })\n        }\n    }\n\n    setAttr(name, value) {\n        this.attrs[name] = value\n    }\n\n    getAttr(name, defaultValue) {\n        return this.attrs[name] !== undefined ? this.attrs[name]\n            : (defaultValue !== undefined ? defaultValue : null)\n    }\n\n    getLayerName() {\n        if (this.name === 'g') {\n            return this.getAttr('inkscape:label', this.getAttr('id', null))\n        }\n    }\n\n    setLayerName(name) {\n        if (this.name === 'g') {\n            this.layer = name || this.getLayerName()\n        }\n    }\n\n    addChild(childTag) {\n        this.children.push(childTag)\n    }\n\n    clearPath() {\n        this.path = new Path()\n    }\n\n    newPath() {\n        if (this.path.length > 0) {\n            this.clearPath()\n            this.paths.push(this.path)\n        }\n    }\n\n    closePath() {\n        return this.path.close()\n    }\n\n    addPoint(x, y, relative) {\n        // Relative from the last point\n        if (relative) {\n            x += this.point.x\n            y += this.point.y\n        }\n\n        // Add current point\n        this.path.addPoint(x, y)\n\n        // Update current point\n        this.point = this.path.getPoint(-1)\n    }\n\n    addPoints(points, relative) {\n        // For each couple of points\n        for (let i = 0, il = points.length; i < il; i += 2) {\n            this.addPoint(points[i], points[i + 1], relative)\n        }\n    }\n\n    setMatrix(matrix) {\n        this.matrix = matrix || [1, 0, 0, 1, 0, 0]\n    }\n\n    addMatrix(matrix) {\n        this.matrix = [\n            this.matrix[0] * matrix[0] + this.matrix[2] * matrix[1],\n            this.matrix[1] * matrix[0] + this.matrix[3] * matrix[1],\n            this.matrix[0] * matrix[2] + this.matrix[2] * matrix[3],\n            this.matrix[1] * matrix[2] + this.matrix[3] * matrix[3],\n            this.matrix[0] * matrix[4] + this.matrix[2] * matrix[5] + this.matrix[4],\n            this.matrix[1] * matrix[4] + this.matrix[3] * matrix[5] + this.matrix[5]\n        ]\n    }\n\n    translate(x, y) {\n        y = y === undefined ? 0 : y\n        this.addMatrix([1, 0, 0, 1, x, y])\n    }\n\n    rotate(angle, x, y) {\n        angle = angle * DEG_TO_RAD\n\n        if (arguments.length == 2) {\n            this.addMatrix([1, 0, 0, 1, x, y])\n        }\n\n        this.addMatrix([Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0])\n\n        if (arguments.length == 2) {\n            this.addMatrix([1, 0, 0, 1, -x, -y])\n        }\n    }\n\n    scale(x, y) {\n        y = y === undefined ? x : y\n        this.addMatrix([x, 0, 0, y, 0, 0])\n    }\n\n    skewX(angle) {\n        this.addMatrix([1, 0, Math.tan(angle * DEG_TO_RAD), 1, 0, 0])\n    }\n\n    skewY(angle) {\n        this.addMatrix([1, Math.tan(angle * DEG_TO_RAD), 0, 1, 0, 0])\n    }\n\n    applyMatrix(matrix) {\n        matrix && this.addMatrix(matrix)\n\n        this.paths.forEach(path => {\n            path.transform(this.matrix)\n        })\n\n        this.setMatrix(null)\n\n        this.children.forEach(tag => {\n            tag.applyMatrix(matrix)\n        })\n    }\n}\n\n// Exports\nexport { Tag }\nexport default Tag\n\n\n\n// WEBPACK FOOTER //\n// ./tag.js","import { /*trace,*/ Arc, CubicBezier, QuadricBezier } from './trace'\nimport { Point } from './path'\n\n// SVG tag parser\nclass TagParser {\n    // Class constructor...\n    constructor(tag, parser) {\n        // Init properties\n        this.tag            = tag\n        this.parser         = parser\n        this.currentCommand = null\n        this.lastCommand    = null\n        this.pathData       = null\n        this.traceSettings  = parser.traceSettings\n    }\n\n    parse() {\n        // Get internal parser from node name\n        let handler = this['_' + this.tag.name]\n\n        // Implemented tag handler?\n        if (! handler || typeof handler !== 'function') {\n            return this.parser._skipTag(this.tag, 'not yet implemented')\n        }\n\n        // Parse tag attributes\n        this._parseTagAttrs()\n\n        // Parse tag\n        let result = handler.call(this)\n\n        if (result && this.tag.getAttr('fill') && this.tag.paths[0].length) {\n            let paths = []\n            let debug = []\n\n            this.tag.paths.forEach(path => {\n                this.tag.triangles = null\n                paths.push(path.getFlattenPoints())\n                debug.push('[' + path.getFlattenPoints().join(',') + ']')\n            })\n\n            //console.log(paths.length, debug.join(','))\n        }\n\n        return result\n    }\n\n    // Parse the tag attributes\n    _parseTagAttrs() {\n        // Get tag attributes\n        let attrs = this.tag.element.attributes\n\n        if (! attrs) {\n            return null\n        }\n\n        // For each attribute\n        let attr, value, style\n\n        Object.keys(attrs).some(key => {\n            // Current attribute\n            attr = attrs[key]\n\n            // Normalize attribute value\n            value = this._normalizeTagAttr(attr)\n\n            if (value === false) {\n                return false // continue\n            }\n\n            // Special case\n            if (attr.nodeName === 'style') {\n                style = value\n            }\n            else {\n                // Set new attribute name/value\n                this.tag.setAttr(attr.nodeName, value)\n            }\n        })\n\n        // If style attribute (override tag attributes)\n        // TODO get/parse global style and override this one...\n        style && style.split(';').some(attr => {\n            // Current style\n            attr = attr.split(':')\n            attr = { nodeName: attr[0], nodeValue: attr[1] }\n\n            // Normalize attribute value\n            value = this._normalizeTagAttr(attr)\n\n            if (value === false) {\n                return false // continue\n            }\n\n            // Set new attribute name/value\n            this.tag.setAttr(attr.nodeName, value)\n        })\n\n        // Set inherited color\n        let colorsAttrs = ['fill', 'stroke', 'color']\n\n        colorsAttrs.forEach(attrName => {\n            if (this.tag.getAttr(attrName) === 'inherit') {\n                this.tag.setAttr(attrName, this.tag.parent.getAttr(attrName, 'none'))\n            }\n        })\n\n        // Parse viewBox attribute\n        this._parseViewBoxAttr()\n\n        // Parse transform attribute\n        this._parseTransformAttr()\n    }\n\n    // Normalize tag attribute\n    _normalizeTagAttr(attr) {\n        // Normalize whitespaces\n        let value = attr.nodeValue\n            .replace(/(\\r?\\n|\\r)+/gm, ' ') // Remove all new line chars\n            .replace(/\\s+/gm, ' ')         // Reduce multiple whitespaces\n            .trim()                        // Remove trailing whitespaces\n\n        if (! value.length) {\n            return this.parser._skipTagAttr(this.tag, attr, 'empty')\n        }\n\n        // Filters\n        switch (attr.nodeName) {\n            // Normalize size unit -> to px\n            case 'x':\n            case 'y':\n            case 'x1':\n            case 'y1':\n            case 'x2':\n            case 'y2':\n            case 'r':\n            case 'rx':\n            case 'ry':\n            case 'cx':\n            case 'cy':\n            case 'width':\n            case 'height':\n            case 'fontSize':\n            case 'strokeWidth':\n                value = this._normalizeTagAttrUnit(attr)\n            break\n\n            // Normalize points attribute\n            case 'points':\n            case 'viewBox':\n                value = this._normalizeTagAttrPoints(attr)\n            break\n\n            // Range limit to [0 - 1]\n            case 'opacity':\n            case 'fillOpacity':\n            case 'strokeOpacity':\n                value = this._normalizeTagAttrRange(attr, 0, 1)\n            break\n\n            case 'preserveAspectRatio':\n                value = this._normalizeTagAttrPreserveAspectRatio(attr)\n            break\n        }\n\n        // Return normalized value\n        return value\n    }\n\n    // Normalize attribute unit to px\n    _normalizeTagAttrUnit(attr) {\n        let stringValue = attr.nodeValue.toLowerCase()\n        let floatValue  = parseFloat(stringValue)\n\n        if (isNaN(floatValue)) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric value allowed')\n        }\n\n        if (stringValue.indexOf('mm') !== -1) {\n            return floatValue * 3.5433070869\n        }\n\n        if (stringValue.indexOf('cm') !== -1) {\n            return floatValue * 35.433070869\n        }\n\n        if (stringValue.indexOf('in') !== -1) {\n            return floatValue * 90.0\n        }\n\n        if (stringValue.indexOf('pt') !== -1) {\n            return floatValue * 1.25\n        }\n\n        if (stringValue.indexOf('pc') !== -1) {\n            return floatValue * 15.0\n        }\n\n        return floatValue\n    }\n\n    // Normalize points attribute\n    _normalizeTagAttrPoints(attr) {\n        let points = this._parseNumbers(attr.nodeValue)\n\n        if (points === false) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed')\n        }\n\n        if (! points.length) {\n            return this.parser._skipTagAttr(this.tag, attr, 'empty points list')\n        }\n\n        if (points.length % 0) {\n            return this.parser._skipTagAttr(this.tag, attr, 'the number of points must be even')\n        }\n\n        return points\n    }\n\n    // Normalize range attribute like \"opacity\"\n    _normalizeTagAttrRange(attr, min, max) {\n        let stringValue = attr.nodeValue.trim()\n        let floatValue  = parseFloat(stringValue)\n\n        if (isNaN(floatValue)) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed')\n        }\n\n        if (floatValue < min || floatValue > max) {\n            return this.parser._skipTagAttr(this.tag, attr, 'out of range [' + min + ', ' + max + ']')\n        }\n\n        return floatValue\n    }\n\n    // Parse points string as numbers array\n    _parseNumbers(points) {\n        // http://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly\n        if (typeof points === 'string') {\n            points = points.split(/([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/g)\n            .filter(point => {\n                return point && ['', ','].indexOf(point.trim()) === -1\n            })\n        }\n\n        // Normalize to float values\n        points = points.map(parseFloat)\n\n        // Test if all numbers is valid\n        if (points.some(isNaN)) {\n            return false\n        }\n\n        return points\n    }\n\n    // Normalize the preserveAspectRatio attribute\n    _normalizeTagAttrPreserveAspectRatio(attr) {\n        let params = {\n            defer: false,\n            align: 'none',\n            meet : true,\n            slice: false\n        }\n\n        let rawParams = attr.nodeValue\n\n        if (rawParams.indexOf('defer') === 0) {\n            rawParams    = rawParams.substr(6)\n            params.defer = true\n        }\n\n        rawParams    = rawParams.split(' ')\n        params.align = rawParams[0]\n        params.meet  = rawParams[1] || 'meet'\n        params.meet  = params.meet === 'meet'\n        params.slice = ! params.meet\n\n        return params\n    }\n\n    // Parse viewBox attribute and set transformations\n    _parseViewBoxAttr() {\n        // Get viewBox attribute\n        let viewBox = this.tag.getAttr('viewBox', null)\n\n        // No viewBox...\n        if (viewBox === null) {\n            return null\n        }\n\n        // Update size attributes\n        let width  = this.tag.getAttr('width', viewBox[2])\n        let height = this.tag.getAttr('height', viewBox[3])\n\n        this.tag.setAttr('width' , width)\n        this.tag.setAttr('height', height)\n\n        // Scale to match viewBox\n        // TODO clip path if preserveAspectRatio.slice\n        let scaleX     = width  / viewBox[2]\n        let scaleY     = height / viewBox[3]\n        let translateX = viewBox[0]\n        let translateY = viewBox[1]\n\n        let preserveAspectRatio = this.tag.getAttr('preserveAspectRatio', 'meet xMidYMid')\n\n        if (preserveAspectRatio) {\n            let newWidth, newHeight\n\n            if (preserveAspectRatio.meet) {\n                if (scaleX > scaleY) {\n                    scaleX   = scaleY\n                    newWidth = viewBox[2] * scaleX\n                }\n                else if (scaleX < scaleY) {\n                    scaleY    = scaleX\n                    newHeight = viewBox[3] * scaleY\n                }\n            }\n            else if (preserveAspectRatio.slice) {\n                if (scaleX < scaleY) {\n                    scaleX   = scaleY\n                    newWidth = viewBox[2] * scaleX\n                }\n                else if (scaleX > scaleY) {\n                    scaleY    = scaleX\n                    newHeight = viewBox[3] * scaleY\n                }\n            }\n\n            if (newWidth !== undefined) {\n                if (preserveAspectRatio.align === 'xMidYMid') {\n                    this.tag.translate((width - newWidth) / 2, 0)\n                }\n                else if (preserveAspectRatio.align === 'xMaxYMax') {\n                    this.tag.translate(width - newWidth, 0)\n                }\n            }\n            else if (newHeight !== undefined) {\n                if (preserveAspectRatio.align === 'xMidYMid') {\n                    this.tag.translate(0, (height - newHeight) / 2)\n                }\n                else if (preserveAspectRatio.align === 'xMaxYMax') {\n                    this.tag.translate(0, height - newHeight)\n                }\n            }\n        }\n\n        this.tag.scale(scaleX, scaleY)\n        this.tag.translate(-translateX, -translateY)\n    }\n\n    // Parse transform attribute and set transformations\n    _parseTransformAttr() {\n        // Get transform attribute\n        let transformAttr = this.tag.getAttr('transform', null)\n\n        // No transformation...\n        if (transformAttr === null || ! transformAttr.length) {\n            return null\n        }\n\n        // Parse attribute (split group on closing parenthesis)\n        let transformations = transformAttr.split(')')\n\n        // Remove last entry due to last \")\" found\n        transformations.pop()\n\n        // For each transformation\n        let transform, type, params\n\n        transformations.some(raw => {\n            // Split name and value on opening parenthesis\n            transform = raw.split('(')\n\n            // Invalid parts number\n            if (transform.length !== 2) {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'malformed') // continue\n            }\n\n            type = transform[0].trim()\n\n            // Quik hack 1/2\n            let func = type\n            if (func === 'matrix') {\n                func = 'addMatrix'\n            }\n\n            // Get tag transform method\n            let tagTransform = this.tag[func]\n\n            if (typeof tagTransform !== 'function') {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'unsupported transform type :' + type)\n            }\n\n            params = transform[1].trim()\n            params = this._parseNumbers(params)\n\n            // Skip empty value\n            if (! params.length) {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'malformed transform type :' + type)\n            }\n\n            // Quik hack 2/2\n            if (func == 'addMatrix') {\n                params = [params]\n            }\n\n            // Call tag transform method like \"tag.translate(param1, ..., paramN)\"\n            tagTransform.apply(this.tag, params)\n        })\n    }\n\n    _newPath() {\n        this.tag.newPath()\n    }\n\n    _clearPath() {\n        this.tag.clearPath()\n    }\n\n    _closePath() {\n        return this.tag.closePath()\n    }\n\n    _addPoints(points, relative) {\n        if (! points.length) {\n            return this.parser._skipTag(this.tag, 'empty points list')\n        }\n\n        if (points.length % 0) {\n            return this.parser._skipTag(this.tag, 'the number of points must be even')\n        }\n\n        relative = arguments.length < 2 && this.currentCommand.relative\n\n        this.tag.addPoints(points, relative)\n        return true\n    }\n\n    // SVG specs at https://www.w3.org/TR/SVG11/\n\n    _svg() {\n        // Only parse the root SVG tag as main document\n        if (this.parser.document) {\n            // Handled tag\n            return true\n        }\n\n        // Get the document size\n        let width  = this.tag.getAttr('width')\n        let height = this.tag.getAttr('height')\n\n        // Invalid size\n        if (! width || width < 0 || ! height || height < 0) {\n            throw new Error('Invalid document size: ' + width + ' / ' + height)\n        }\n\n        // Set document size\n        this.parser.document = {\n            width : width,\n            height: height\n        }\n\n        // Get document viewBox or set default to document size\n        let viewBox = this.tag.getAttr('viewBox', [0, 0, width, height])\n\n        this.parser.document.viewBox = {\n            x     : viewBox[0],\n            y     : viewBox[1],\n            width : viewBox[2],\n            height: viewBox[3]\n        }\n\n        // Check inkscape version\n        if (this.parser.editor.name === 'inkscape') {\n            this.parser.editor.version = this.tag.getAttr('inkscape:version')\n        }\n\n        // Handled tag\n        return true\n    }\n\n    _title() {\n        // Register the first encountered title tag as document title\n        if (this.parser.document && ! this.parser.document.title) {\n            this.parser.document.title = this.tag.element.textContent\n        }\n\n        // Skipped tag\n        return false\n    }\n\n    _desc() {\n        // Register the first encountered desc tag as document description\n        if (this.parser.document && ! this.parser.document.description) {\n            this.parser.document.description = this.tag.element.textContent\n        }\n\n        // Skipped tag\n        return false\n    }\n\n    _defs() {\n        // Register all child element with an id attribute\n        this.tag.element.childNodes.forEach(childNode => {\n            childNode.id && (this.parser.defs[childNode.id] = childNode)\n        })\n\n        // Skipped tag\n        return false\n    }\n\n    _use() {\n        // Get the target id\n        let target  = this.tag.getAttr('xlink:href').replace(/^#/, '')\n\n        // Try to get the defined element\n        let element = this.parser.defs[target]\n\n        if (! element) {\n            return this.parser._skipTag(this.tag, 'undefined reference [' + target + ']')\n        }\n\n        // Parse the defined element and set new parent from <use> tag parent\n        let useTag = this.parser._parseElement(element, this.tag.parent)\n\n        if (! useTag) {\n            return this.parser._skipTag(this.tag, 'empty reference [' + target + ']')\n        }\n\n        // Set matrix from real parent (<use>)\n        useTag.setMatrix(this.tag.matrix)\n\n        // Replace the use tag with new one\n        this.tag.parent.addChild(useTag)\n\n        // Skipped tag\n        return false\n    }\n\n    _g() {\n        // Set the tag layer name\n        this.tag.setLayerName()\n\n        // Handled tag\n        return true\n    }\n\n    _line() {\n        // Handled tag\n        return this._path([\n            'M', this.tag.getAttr('x1'), this.tag.getAttr('y1'),\n            'L', this.tag.getAttr('x2'), this.tag.getAttr('y2')\n        ])\n    }\n\n    _polyline(close=false) {\n        let points = this.tag.getAttr('points')\n        let path   = ['M', points.shift(), points.shift(), 'L']\n\n        path = path.concat(points)\n        close && path.push('Z')\n\n        // Handled tag\n        return this._path(path)\n    }\n\n    _polygon() {\n        // Handled like polyline but closed\n        return this._polyline(true)\n    }\n\n    _rect() {\n        // Get rectangle attributes\n        let w  = this.tag.getAttr('width')\n        let h  = this.tag.getAttr('height')\n        let x  = this.tag.getAttr('x', 0)\n        let y  = this.tag.getAttr('y', 0)\n        let rx = this.tag.getAttr('rx', null)\n        let ry = this.tag.getAttr('ry', null)\n\n        // Simple rect\n        if (!rx && !ry) {\n            // Handled tag\n            return this._path(['M', x, y, 'h', w, 'v', h, 'h', -w, 'z'])\n        }\n\n        // If a properly specified value is provided for ‘rx’, but not for ‘ry’,\n        // then set both rx and ry to the value of ‘rx’ and vis-vera...\n        if (rx === null) rx = ry\n        if (ry === null) ry = rx\n\n        // A negative value is an error\n        if (rx === null || rx === null || rx < 0 || ry < 0) {\n            // Skip tag\n            return this.parser._skipTag(this.tag, 'negative value for \"rx/ry\" not allowed')\n        }\n\n        // If rx is greater than half of ‘width’, then set rx to half of ‘width’.\n        // If ry is greater than half of ‘height’, then set ry to half of ‘height’.\n        if (rx > w / 2) rx = w / 2\n        if (ry > h / 2) ry = h / 2\n\n        let dx = rx * 2\n        let dy = ry * 2\n\n        // Handled tag\n        return this._path([\n            'M', x + rx, y,\n            'h', w - dx,\n            'c', rx, 0, rx, ry, rx, ry,\n            'v', h - dy,\n            'c', 0, ry, -rx, ry, -rx, ry,\n            'h', -w + dx,\n            'c', -rx, 0, -rx, -ry, -rx, -ry,\n            'v', -h + dy,\n            'c', 0, 0, 0, -ry, rx, -ry,\n            'z'\n        ])\n    }\n\n    _circle() {\n        let r = this.tag.getAttr('r', 0)\n\n        if (r <= 0) {\n            // Skipped tag\n            return false\n        }\n\n        let cx = this.tag.getAttr('cx', 0)\n        let cy = this.tag.getAttr('cy', 0)\n\n        // Handled tag\n        return this._path([\n            'M', cx-r, cy,\n            'A', r, r, 0, 0, 0, cx, cy+r,\n            'A', r, r, 0, 0, 0, cx+r, cy,\n            'A', r, r, 0, 0, 0, cx, cy-r,\n            'A', r, r, 0, 0, 0, cx-r, cy,\n            'Z'\n        ])\n    }\n\n    _ellipse() {\n        let rx = this.tag.getAttr('rx', 0)\n        let ry = this.tag.getAttr('ry', 0)\n\n        if (rx <= 0 || ry <= 0) {\n            // Skipped tag\n            return false\n        }\n\n        let cx = this.tag.getAttr('cx', 0)\n        let cy = this.tag.getAttr('cy', 0)\n\n        // Handled tag\n        return this._path([\n            'M', cx-rx, cy,\n            'A', rx, ry, 0, 0, 0, cx, cy+ry,\n            'A', rx, ry, 0, 0, 0, cx+rx, cy,\n            'A', rx, ry, 0, 0, 0, cx, cy-ry,\n            'A', rx, ry, 0, 0, 0, cx-rx, cy,\n            'Z'\n        ])\n    }\n\n    _paths(type, num, points) {\n        if (points.length > num) {\n            let handler, result = true\n\n            while(result && points.length) {\n                handler = this['_path' + type]\n                result  = handler.call(this, points.splice(0, num))\n            }\n\n            return result\n        }\n\n        return null\n    }\n\n    _path(path) {\n        // Provided path\n        if (path && typeof path !== 'string') {\n            path = path.join(' ')\n        }\n\n        // Get the paths data attribute value\n        let dAttr = path || this.tag.getAttr('d', null)\n\n        if (! dAttr) {\n            // Skipped tag\n            return false\n        }\n\n        // Split on each commands\n        let commands = dAttr.match(/([M|Z|L|H|V|C|S|Q|T|A]+([^M|Z|L|H|V|C|S|Q|T|A]+)?)/gi)\n\n        if (! commands) {\n            return this.parser._skipTag(this.tag, 'malformed \"d\" attribute')\n        }\n\n        // For each command...\n        this.currentCommand = {\n            raw     : null,\n            type    : null,\n            params  : null,\n            relative: null\n        }\n        this.lastCommand = this.currentCommand\n        this.pathData    = {}\n\n        let handler    = null\n        let parseError = false\n\n        commands.some(raw => {\n            // Remove trailing whitespaces\n            raw = raw.trim()\n\n            // Extract command char and params\n            this.currentCommand.raw      = raw\n            this.currentCommand.type     = raw[0].toUpperCase()\n            this.currentCommand.params   = raw.substr(1).trim()\n            this.currentCommand.relative = this.currentCommand.type !== raw[0]\n\n            // Get path handler from command char\n            handler = this['_path' + this.currentCommand.type]\n\n            if (! handler || typeof handler !== 'function') {\n                this.parser._skipTag(this.tag, 'unsupported path command [' + raw[0] + ']')\n                return parseError = true // break\n            }\n\n            // Extract all numbers from arguments string\n            this.currentCommand.params = this._parseNumbers(this.currentCommand.params)\n\n            if (this.currentCommand.params === false) {\n                this.parser._skipTag(this.tag, 'only numeric values are allowed in [' + this.currentCommand.raw + ']')\n                return parseError = true // break\n            }\n\n            // Execute command parser\n            if (! handler.call(this, this.currentCommand.params)) {\n                return parseError = true // break\n            }\n\n            // Update last command\n            this.lastCommand = {}\n\n            Object.keys(this.currentCommand).forEach(key => {\n                this.lastCommand[key] = this.currentCommand[key]\n            })\n        })\n\n        // Skip tag\n        if (parseError) {\n            this._clearPath()\n            return false\n        }\n\n        // Handled tag\n        return true\n    }\n\n    _pathM(points) {\n        // New path\n        this._newPath()\n\n        // Set the current point (start of new path)\n        // If is followed by multiple pairs of coordinates,\n        // the subsequent pairs are treated as implicit lineto commands.\n        return this._addPoints(points)\n    }\n\n    _pathZ() {\n        this._closePath()\n        return true\n    }\n\n    _pathL(points) {\n        return this._addPoints(points)\n    }\n\n    _pathH(points) {\n        return points.every(x => {\n            return this._addPoints([x, this.currentCommand.relative ? 0 : this.tag.point.y])\n        })\n    }\n\n    _pathV(points) {\n        return points.every(y => {\n            return this._addPoints([this.currentCommand.relative ? 0 : this.tag.point.x, y])\n        })\n    }\n\n    _pathC(points) {\n        // Multiple paths\n        let result = this._paths('C', 6, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = points[0] + (rl ? p1.x : 0)\n        let y1 = points[1] + (rl ? p1.y : 0)\n        let x2 = points[2] + (rl ? p1.x : 0)\n        let y2 = points[3] + (rl ? p1.y : 0)\n        let x  = points[4] + (rl ? p1.x : 0)\n        let y  = points[5] + (rl ? p1.y : 0)\n\n        this.pathData.x2 = x2\n        this.pathData.y2 = y2\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x2, y2)\n        let p4 = new Point(x, y)\n\n        //console.log('C', p1, p2, p3, p4)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : control point\n        // p4  : end point\n        let tracer = new CubicBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3, p4 }) // => [x,y, x,y, ...]\n        // let tracer = trace(CubicBezier, this.traceSettings)\n        // let coords = tracer({ p1, p2, p3, p4 })\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathS(points) {\n        // Multiple paths\n        let result = this._paths('S', 4, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = p1.x\n        let y1 = p1.y\n\n        if (this.lastCommand.type === 'S' || this.lastCommand.type === 'C') {\n            x1 -= this.pathData.x2 - x1\n            y1 -= this.pathData.y2 - y1\n        }\n\n        let x2 = points[0] + (rl ? p1.x : 0)\n        let y2 = points[1] + (rl ? p1.y : 0)\n        let x  = points[2] + (rl ? p1.x : 0)\n        let y  = points[3] + (rl ? p1.y : 0)\n\n        this.pathData.x2 = x2\n        this.pathData.y2 = y2\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x2, y2)\n        let p4 = new Point(x, y)\n\n        //console.log('S', p1, p2, p3, p4)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : control point\n        // p4  : end point\n        let tracer = new CubicBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3, p4 }) // => [x,y, x,y, ...]\n        // let tracer = trace(CubicBezier, this.traceSettings)\n        // let coords = tracer({ p1, p2, p3, p4 })\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathQ(points) {\n        // Multiple paths\n        let result = this._paths('Q', 4, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = points[0] + (rl ? p1.x : 0)\n        let y1 = points[1] + (rl ? p1.y : 0)\n        let x  = points[2] + (rl ? p1.x : 0)\n        let y  = points[3] + (rl ? p1.y : 0)\n\n        this.pathData.x1 = x1\n        this.pathData.y1 = y1\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x, y)\n\n        //console.log('Q', p1, p2, p3)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : end point\n        let tracer = new QuadricBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathT(points) {\n        // Multiple paths\n        let result = this._paths('T', 2, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = p1.x\n        let y1 = p1.y\n\n        if (this.lastCommand.type === 'Q' || this.lastCommand.type === 'T') {\n            x1 -= this.pathData.x1 - x1\n            y1 -= this.pathData.y1 - y1\n        }\n\n        let x = points[0] + (rl ? p1.x : 0)\n        let y = points[1] + (rl ? p1.y : 0)\n\n        this.pathData.x1 = x1\n        this.pathData.y1 = y1\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x, y)\n\n        //console.log('T', p1, p2, p3)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : end point\n        let tracer = new QuadricBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathA(points) {\n        // Multiple paths\n        let result = this._paths('A', 7, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let rl    = this.currentCommand.relative\n        let p1    = this.tag.point\n        let rx    = points[0]\n        let ry    = points[1]\n        let angle = points[2]\n        let large = !!points[3]\n        let sweep = !!points[4]\n        let x     = points[5] + (rl ? p1.x : 0)\n        let y     = points[6] + (rl ? p1.y : 0)\n        let p2    = new Point(x, y)\n\n        //console.log('A', p1, rx, ry, angle, large, sweep, p2)\n\n        let tracer = new Arc(this.traceSettings)\n        let coords = tracer.trace({ p1, rx, ry, angle, large, sweep, p2 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n}\n\n// Exports\nexport { TagParser }\nexport default TagParser\n\n\n\n// WEBPACK FOOTER //\n// ./tagparser.js","// Base code from : https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js\nimport { Point } from './path'\n\nconst MATH_PI_2  = Math.PI * 2\nconst DEG_TO_RAD = Math.PI / 180\n\nfunction mod(x, m) {\n    return (x % m + m) % m\n}\n\nfunction clamp(val, min, max) {\n    return Math.min(Math.max(val, min), max)\n}\n\nfunction distance(p0, p1) {\n    return Math.sqrt(Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2))\n}\n\nfunction angle(v0, v1) {\n    let p = v0.x * v1.x + v0.y * v1.y\n    let n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)))\n    return (v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1) * Math.acos(p / n)\n}\n\n// Abstract class\nclass TraceBase {\n    constructor(settings) {\n        // Set defaults properties\n        this.path          = []   // Points collection [x,y, x,y, ...]\n        this.linear        = true // Linear trace mode\n        this.step          = 0.01 // Step resolution if linear mode = false\n        this.resolution    = 500  // Number of segments we use to approximate arc length\n        this.segmentLength = 0.1  // Segment length\n\n        // Update properties from user settings\n        Object.assign(this, settings || {})\n\n        // Arc length properties\n        this.arcLength    = null\n        this.arcLengthMap = null\n    }\n\n    _clearPath() {\n        this.path = []\n    }\n\n    getPath() {\n        return this.path\n    }\n\n    getPointAtT(t) {\n        return new Point(0, 0)\n    }\n\n    _addPoint(point) {\n        this.path.push(point.x, point.y)\n    }\n\n    _postTrace() {\n        // Do additional tasks\n    }\n\n    _approximateLength() {\n        let arcLength    = 0\n        let arcLengthMap = []\n        let prevPoint    = this.getPointAtT(0)\n\n        let i, t, nextPoint\n\n        for(i = 0; i < this.resolution; i++) {\n            t          = clamp(i * (1 / this.resolution), 0, 1)\n            nextPoint  = this.getPointAtT(t)\n            arcLength += distance(prevPoint, nextPoint)\n\n            arcLengthMap.push({ t: t, arcLength: arcLength })\n\n            prevPoint = nextPoint\n        }\n\n        // Last stretch to the endpoint\n        nextPoint  = this.getPointAtT(1)\n        arcLength += distance(prevPoint, nextPoint)\n\n        arcLengthMap.push({ t: 1, arcLength: arcLength })\n        Object.assign(this, { arcLength, arcLengthMap })\n    }\n\n    getPointAtU(u) {\n        u = clamp(u, 0, 1)\n\n        let targetDistanceFromStartingPoint = u * this.arcLength\n\n        let resultantT    = 0\n        let prevArcLength = 0\n        let prevT         = 0\n\n        this.arcLengthMap.every(entry => {\n            let t         = entry.t\n            let arcLength = entry.arcLength\n\n            // Once we go a past our target\n            // Lets interpolate from a previous to current\n            if (arcLength >= targetDistanceFromStartingPoint) {\n                let endDiff      = arcLength - targetDistanceFromStartingPoint\n                let startDiff    = targetDistanceFromStartingPoint - prevArcLength\n                let linearFactor = (startDiff / (endDiff + startDiff)) || 0\n\n                resultantT = prevT + (t - prevT) * linearFactor\n\n                // Break\n                return false\n            }\n\n            prevArcLength = arcLength\n            prevT = t\n\n            return true\n        })\n\n        return this.getPointAtT(resultantT)\n    }\n\n    trace(settings) {\n        // Update properties from user settings\n        Object.assign(this, settings || {})\n\n        // Default getPoint settings\n        let getPoint = 'getPointAtT'\n        let step     = this.step\n\n        // Linear mode ?\n        if (this.linear) {\n            this._approximateLength()\n\n            let segments = Math.round(this.arcLength / this.segmentLength)\n\n            getPoint = 'getPointAtU'\n            step     = 1 / segments\n        }\n\n        // Clear points list\n        this._clearPath()\n\n        // Trace the path\n        for (let t = 0; t <= 1; t += step) {\n            this._addPoint(this[getPoint](t))\n        }\n\n        // Do additional tasks\n        this._postTrace()\n\n        // Return the path\n        return this.getPath()\n    }\n}\n\n// Rewrite from https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js#L84\nclass Arc extends TraceBase {\n    init(settings) {\n        // Update properties from user settings\n        Object.assign(this, settings || {})\n\n        // Get angle in radians\n        this.radians = mod(this.angle, 360) * DEG_TO_RAD\n\n        // If the endpoints are identical, then this is equivalent\n        // to omitting the elliptical arc segment entirely.\n        if(this.p1.x === this.p2.x && this.p1.y === this.p2.y) {\n            return this.path\n        }\n\n        this.rx = Math.abs(this.rx)\n        this.ry = Math.abs(this.ry)\n\n        // If rx = 0 or ry = 0 then this arc is treated as\n        // a straight line segment joining the endpoints.\n        if (this.rx === 0 || this.ry === 0) {\n            this.__addPoint(this.p1)\n            this.__addPoint(this.p2)\n            return this.path\n        }\n\n        // Following \"Conversion from endpoint to center parameterization\"\n        // http://www.w3.org/TR/SVG/implnote.html#ArcConversionEndpointToCenter\n\n        // Step #1: Compute transformedPoint\n        let dx = (this.p1.x - this.p2.x) / 2\n        let dy = (this.p1.y - this.p2.y) / 2\n\n        let transformedPoint = {\n            x:  Math.cos(this.radians) * dx + Math.sin(this.radians) * dy,\n            y: -Math.sin(this.radians) * dx + Math.cos(this.radians) * dy\n        }\n\n        // Ensure radii are large enough\n        let radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(this.rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(this.ry, 2)\n\n        if (radiiCheck > 1) {\n            this.rx = Math.sqrt(radiiCheck) * this.rx\n            this.ry = Math.sqrt(radiiCheck) * this.ry\n        }\n\n        // Step #2: Compute transformedCenter\n        let cSquareNumerator = Math.pow(this.rx, 2) * Math.pow(this.ry, 2) - Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2)\n        let cSquareRootDenom = Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2)\n        let cRadicand        = cSquareNumerator / cSquareRootDenom\n\n        // Make sure this never drops below zero because of precision\n        cRadicand = cRadicand < 0 ? 0 : cRadicand\n        let cCoef = (this.large !== this.sweep ? 1 : -1) * Math.sqrt(cRadicand)\n        let transformedCenter = {\n            x: cCoef * ( (this.rx * transformedPoint.y) / this.ry),\n            y: cCoef * (-(this.ry * transformedPoint.x) / this.rx)\n        }\n\n        // Step #3: Compute center\n        this.center = {\n            x: Math.cos(this.radians) * transformedCenter.x - Math.sin(this.radians) * transformedCenter.y + ((this.p1.x + this.p2.x) / 2),\n            y: Math.sin(this.radians) * transformedCenter.x + Math.cos(this.radians) * transformedCenter.y + ((this.p1.y + this.p2.y) / 2)\n        }\n\n        // Step #4: Compute start/sweep angles\n        // Start angle of the elliptical arc prior to the stretch and rotate operations.\n        // Difference between the start and end angles\n        let startVector = {\n            x: (transformedPoint.x - transformedCenter.x) / this.rx,\n            y: (transformedPoint.y - transformedCenter.y) / this.ry\n        }\n\n        let endVector = {\n            x: (-transformedPoint.x - transformedCenter.x) / this.rx,\n            y: (-transformedPoint.y - transformedCenter.y) / this.ry\n        }\n\n        this.startAngle = angle({ x: 1, y: 0 }, startVector)\n        this.sweepAngle = angle(startVector, endVector)\n\n        if (! this.sweep && this.sweepAngle > 0) {\n            this.sweepAngle -= MATH_PI_2\n        }\n\n        else if (this.sweep && this.sweepAngle < 0) {\n            this.sweepAngle += MATH_PI_2\n        }\n\n        // We use % instead of `mod(..)` because we want it to be -360deg to 360deg(but actually in radians)\n        this.sweepAngle %= MATH_PI_2\n    }\n\n    trace(settings) {\n        this.init(settings)\n        return super.trace()\n    }\n\n    getPointAtT(t) {\n        let angle = this.startAngle + (this.sweepAngle * t)\n\n        let x = this.rx * Math.cos(angle)\n        let y = this.ry * Math.sin(angle)\n\n        return new Point(\n            Math.cos(this.radians) * x - Math.sin(this.radians) * y + this.center.x,\n            Math.sin(this.radians) * x + Math.cos(this.radians) * y + this.center.y\n        )\n    }\n\n    _postTrace() {\n        // Add last point in the path\n        this._addPoint(this.p2)\n    }\n}\n\nclass CubicBezier extends TraceBase {\n    _B1(t) { return t*t*t }\n    _B2(t) { return 3*t*t*(1-t) }\n    _B3(t) { return 3*t*(1-t)*(1-t) }\n    _B4(t) { return (1-t)*(1-t)*(1-t) }\n\n    _C1(p1, p2, p3, p4, t) {\n        return p1*this._B1(t) + p2*this._B2(t) + p3*this._B3(t) + p4*this._B4(t)\n    }\n\n    getPointAtT(t) {\n        return new Point(\n            this._C1(this.p1.x, this.p2.x, this.p3.x, this.p4.x, t),\n            this._C1(this.p1.y, this.p2.y, this.p3.y, this.p4.y, t)\n        )\n    }\n\n    _addPoint(point) {\n        this.path.unshift(point.x, point.y)\n    }\n}\n\nclass QuadricBezier extends TraceBase {\n    _B1(t) { return t*t }\n    _B2(t) { return 2*t*(1-t) }\n    _B3(t) { return (1-t)*(1-t) }\n\n    _C1(p1, p2, p3, t) {\n        return p1*this._B1(t) + p2*this._B2(t) + p3*this._B3(t)\n    }\n\n    getPointAtT(t) {\n        return new Point(\n            this._C1(this.p1.x, this.p2.x, this.p3.x, t),\n            this._C1(this.p1.y, this.p2.y, this.p3.y, t)\n        )\n    }\n\n    _addPoint(point) {\n        this.path.unshift(point.x, point.y)\n    }\n}\n\n// Exports\nexport { Arc, CubicBezier, QuadricBezier }\n\n\n\n// WEBPACK FOOTER //\n// ./trace.js"],"sourceRoot":""}