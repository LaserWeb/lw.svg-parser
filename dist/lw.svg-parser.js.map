{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lw.svg-parser.js","webpack:///webpack/bootstrap 63d98a286bb5b51cc981","webpack:///./path.js","webpack:///./parser.js","webpack:///./tag.js","webpack:///./tagparser.js","webpack:///./trace.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","Point","x","y","parseFloat","isNaN","console","error","Error","point","Path","element","parent","points","forEach","push","il","addPoint","firstPoint","getPoint","isEqual","isClosed","matrix","map","default","Parser","undefined","_tag","_tagparser","settings","editor","document","defs","tags","traceSettings","assign","linear","step","resolution","minSegmentLength","segments","supportedTags","parseTags","includes","skipTags","excludes","onTag","onTagContext","input","loadFromString","File","loadFromFile","XMLDocument","loadFromXMLDocument","Element","loadFromElement","Promise","reject","_this","resolve","nodeName","textContent","getElementsByTagName","_this2","documentElement","then","catch","_this3","_parseEditor","parser","DOMParser","XMLDoc","parseFromString","name","version","fingerprint","match","_this4","reader","FileReader","onload","event","result","onerror","readAsText","_this5","load","parse","_parseElement","applyMatrix","tag","info","callback","context","_this6","_onTag","_this7","Tag","indexOf","_skipTag","tagParser","TagParser","childTag","childNodes","childNode","addChild","children","message","warn","attr","_path","DEG_TO_RAD","Math","PI","toLowerCase","layer","attrs","paths","path","setMatrix","keys","setAttr","defaultValue","getAttr","getLayerName","clearPath","close","relative","addMatrix","angle","arguments","cos","sin","tan","transform","_trace","_path2","currentCommand","lastCommand","pathData","handler","_parseTagAttrs","debug","triangles","getFlattenPoints","join","log","attributes","style","some","_normalizeTagAttr","split","nodeValue","colorsAttrs","attrName","_parseViewBoxAttr","_parseTransformAttr","replace","trim","_skipTagAttr","_normalizeTagAttrUnit","_normalizeTagAttrPoints","_normalizeTagAttrRange","_normalizeTagAttrPreserveAspectRatio","stringValue","floatValue","_parseNumbers","min","max","filter","params","defer","align","meet","slice","rawParams","substr","viewBox","width","height","scaleX","scaleY","translateX","translateY","preserveAspectRatio","newWidth","newHeight","translate","scale","transformAttr","transformations","pop","type","raw","func","tagTransform","apply","newPath","closePath","addPoints","title","description","useTag","setLayerName","shift","concat","_polyline","w","h","rx","ry","dx","dy","r","cx","cy","num","splice","dAttr","commands","parseError","toUpperCase","_clearPath","_newPath","_addPoints","_closePath","every","_paths","p1","rl","x1","y1","x2","y2","p2","p3","p4","tracer","CubicBezier","coords","trace","QuadricBezier","large","sweep","Arc","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","mod","clamp","val","distance","p0","sqrt","pow","v0","v1","n","acos","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","getPrototypeOf","getter","MATH_PI_2","TraceBase","arcLength","arcLengthMap","t","prevPoint","getPointAtT","nextPoint","u","targetDistanceFromStartingPoint","resultantT","prevArcLength","prevT","entry","endDiff","startDiff","linearFactor","_approximateLength","_addPoint","_postTrace","getPath","_TraceBase","radians","abs","__addPoint","transformedPoint","radiiCheck","cSquareNumerator","cSquareRootDenom","cRadicand","cCoef","transformedCenter","center","startVector","endVector","startAngle","sweepAngle","init","_TraceBase2","_B1","_B2","_B3","_B4","_C1","unshift","_TraceBase3"],"mappings":"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","file":"lw.svg-parser.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGParser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGParser\"] = factory();\n\telse\n\t\troot[\"SVGParser\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGParser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGParser\"] = factory();\n\telse\n\t\troot[\"SVGParser\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Point = function () {\n\t    // Class constructor...\n\t    function Point(x, y) {\n\t        _classCallCheck(this, Point);\n\t\n\t        // Init properties\n\t        this.x = parseFloat(x);\n\t        this.y = parseFloat(y);\n\t\n\t        if (isNaN(this.x) || isNaN(this.y)) {\n\t            console.error('x:', x, 'y:', y);\n\t            throw new Error('Float value!!!');\n\t        }\n\t    }\n\t\n\t    _createClass(Point, [{\n\t        key: 'isEqual',\n\t        value: function isEqual(point) {\n\t            return this.x === point.x && this.y === point.y;\n\t        }\n\t    }]);\n\t\n\t    return Point;\n\t}();\n\t\n\tvar Path = function () {\n\t    // Class constructor...\n\t    function Path(element, parent) {\n\t        _classCallCheck(this, Path);\n\t\n\t        // Init properties\n\t        this.points = [];\n\t        this.length = 0;\n\t    }\n\t\n\t    _createClass(Path, [{\n\t        key: 'getPoints',\n\t        value: function getPoints() {\n\t            return this.points;\n\t        }\n\t    }, {\n\t        key: 'getFlattenPoints',\n\t        value: function getFlattenPoints() {\n\t            var points = [];\n\t            this.points.forEach(function (point) {\n\t                return points.push(point.x, point.y);\n\t            });\n\t            return points;\n\t        }\n\t    }, {\n\t        key: 'getPoint',\n\t        value: function getPoint(i) {\n\t            return this.points[i < 0 ? this.length + i : i] || null;\n\t        }\n\t    }, {\n\t        key: 'addPoint',\n\t        value: function addPoint(x, y) {\n\t            this.points.push(new Point(x, y));\n\t            this.length = this.points.length;\n\t        }\n\t    }, {\n\t        key: 'addPoints',\n\t        value: function addPoints(points) {\n\t            // For each couple of points\n\t            for (var i = 0, il = points.length; i < il; i += 2) {\n\t                this.addPoint(points[i], points[i + 1]);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'isClosed',\n\t        value: function isClosed() {\n\t            var firstPoint = this.getPoint(0);\n\t            return firstPoint && firstPoint.isEqual(this.getPoint(-1));\n\t        }\n\t    }, {\n\t        key: 'close',\n\t        value: function close() {\n\t            if (!this.isClosed() && this.length > 2) {\n\t                var firstPoint = this.getPoint(0);\n\t                this.addPoint(firstPoint.x, firstPoint.y);\n\t                return true;\n\t            }\n\t\n\t            return false;\n\t        }\n\t    }, {\n\t        key: 'transform',\n\t        value: function transform(matrix) {\n\t            this.points = this.points.map(function (point) {\n\t                return new Point(matrix[0] * point.x + matrix[2] * point.y + matrix[4], matrix[1] * point.x + matrix[3] * point.y + matrix[5]);\n\t            });\n\t        }\n\t    }]);\n\t\n\t    return Path;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Path = Path;\n\texports.Point = Point;\n\texports.default = Path;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Parser = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Imports\n\t\n\t\n\tvar _tag = __webpack_require__(3);\n\t\n\tvar _tagparser = __webpack_require__(4);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// SVG parser class\n\tvar Parser = function () {\n\t    // Class constructor...\n\t    function Parser(settings) {\n\t        _classCallCheck(this, Parser);\n\t\n\t        // Defaults settings\n\t        settings = settings || {};\n\t\n\t        // Init properties\n\t        this.element = null; // XML document Element object\n\t        this.editor = null; // Editor info { name, version, fingerprint }\n\t        this.document = null; // Document info { width, height, viewBox }\n\t        this.defs = null; // Defined <defs> (DOM) nodes list by id\n\t        this.tags = null; // Tag objects hierarchy\n\t\n\t        this.traceSettings = Object.assign({\n\t            linear: true, // Linear trace mode\n\t            step: 0.01, // Step resolution if linear mode = false\n\t            resolution: 500, // number of segments we use to approximate arc length\n\t            minSegmentLength: 0.01, // Minimum segemnt length\n\t            segments: 24 // Numbers of segments\n\t        }, settings.traceSettings || {});\n\t\n\t        // Supported tags by this lib\n\t        this.supportedTags = ['svg', 'g', 'defs', 'use', 'line', 'polyline', 'polygon', 'rect', 'circle', 'ellipse', 'path', 'title', 'desc'];\n\t\n\t        // Tags list to includes/excludes\n\t        this.parseTags = settings.includes || this.supportedTags;\n\t        this.skipTags = settings.excludes || ['#text', '#comment']; // silent (no warning)\n\t\n\t        // User onTag callback ?\n\t        settings.onTag && this.onTag(settings.onTag, settings.onTagContext);\n\t    }\n\t\n\t    // Load raw XML string, XMLDocument, Element or File object\n\t\n\t\n\t    _createClass(Parser, [{\n\t        key: 'load',\n\t        value: function load(input) {\n\t            // Load raw XML string\n\t            if (typeof input === 'string') {\n\t                return this.loadFromString(input);\n\t            }\n\t\n\t            // Load File object\n\t            if (input instanceof File) {\n\t                return this.loadFromFile(input);\n\t            }\n\t\n\t            // Load XMLDocument object\n\t            if (input instanceof XMLDocument) {\n\t                return this.loadFromXMLDocument(input);\n\t            }\n\t\n\t            // Load Element object\n\t            if (input instanceof Element) {\n\t                return this.loadFromElement(input);\n\t            }\n\t\n\t            // Return rejected promise with an Error object\n\t            return Promise.reject(new Error('Unsupported input format.'));\n\t        }\n\t\n\t        // Load from Element object\n\t\n\t    }, {\n\t        key: 'loadFromElement',\n\t        value: function loadFromElement(input) {\n\t            var _this = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof Element)) {\n\t                    reject(new Error('Input param must be a Element object.'));\n\t                }\n\t\n\t                // Parser error\n\t                if (input.nodeName === 'parsererror') {\n\t                    // FF\n\t                    reject(new Error(input.textContent));\n\t                }\n\t\n\t                if (input.nodeName === 'html' && input.getElementsByTagName('parsererror')) {\n\t                    // Chrome\n\t                    reject(new Error(input.getElementsByTagName('parsererror')[0].textContent));\n\t                }\n\t\n\t                // Set document element\n\t                _this.element = input;\n\t\n\t                // Resolve promise\n\t                resolve(input);\n\t            });\n\t        }\n\t\n\t        // Load from XMLDocument object\n\t\n\t    }, {\n\t        key: 'loadFromXMLDocument',\n\t        value: function loadFromXMLDocument(input) {\n\t            var _this2 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof XMLDocument)) {\n\t                    reject(new Error('Input param must be a XMLDocument object.'));\n\t                }\n\t\n\t                // Load from Element...\n\t                _this2.loadFromElement(input.documentElement).then(resolve).catch(reject);\n\t            });\n\t        }\n\t\n\t        // Load raw XML string\n\t\n\t    }, {\n\t        key: 'loadFromString',\n\t        value: function loadFromString(input) {\n\t            var _this3 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (typeof input !== 'string') {\n\t                    reject(new Error('Input param must be a string.'));\n\t                }\n\t\n\t                // Parse svg editor\n\t                _this3._parseEditor(input);\n\t\n\t                // Parse string as DOM object\n\t                var parser = new DOMParser();\n\t                var XMLDoc = parser.parseFromString(input, 'text/xml');\n\t\n\t                // Load from XMLDocument...\n\t                _this3.loadFromXMLDocument(XMLDoc).then(resolve).catch(reject);\n\t            });\n\t        }\n\t\n\t        // Try to get the svg editor from input string\n\t\n\t    }, {\n\t        key: '_parseEditor',\n\t        value: function _parseEditor(input) {\n\t            // Reset editor\n\t            this.editor = {\n\t                name: 'unknown',\n\t                version: null,\n\t                fingerprint: null\n\t            };\n\t\n\t            // Fingerprint matches\n\t            var fingerprint = void 0;\n\t\n\t            // Inkscape\n\t            fingerprint = input.match(/<!-- Created with Inkscape .*-->/i);\n\t\n\t            if (fingerprint) {\n\t                this.editor.name = 'inkscape';\n\t                this.editor.fingerprint = fingerprint[0];\n\t\n\t                return this.editor;\n\t            }\n\t\n\t            // Illustrator\n\t            fingerprint = input.match(/<!-- Generator: Adobe Illustrator ([0-9\\.]+), .*-->/i);\n\t\n\t            if (fingerprint) {\n\t                this.editor.name = 'illustrator';\n\t                this.editor.version = fingerprint[1];\n\t                this.editor.fingerprint = fingerprint[0];\n\t\n\t                return this.editor;\n\t            }\n\t\n\t            // Return default\n\t            return this.editor;\n\t        }\n\t\n\t        // Load from File object\n\t\n\t    }, {\n\t        key: 'loadFromFile',\n\t        value: function loadFromFile(input) {\n\t            var _this4 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof File)) {\n\t                    reject(new Error('Input param must be a File object.'));\n\t                }\n\t\n\t                // Create file reader\n\t                var reader = new FileReader();\n\t\n\t                // Register reader events handlers\n\t                reader.onload = function (event) {\n\t                    _this4.loadFromString(event.target.result).then(resolve).catch(reject);\n\t                };\n\t\n\t                reader.onerror = function (event) {\n\t                    reject(new Error('Error reading file : ' + input.name));\n\t                };\n\t\n\t                // Finally read input file as text\n\t                reader.readAsText(input);\n\t            });\n\t        }\n\t\n\t        // Parse the (loaded) element\n\t\n\t    }, {\n\t        key: 'parse',\n\t        value: function parse(input) {\n\t            var _this5 = this;\n\t\n\t            // Reset properties\n\t            this.document = null;\n\t            this.defs = {};\n\t            this.tags = null;\n\t\n\t            // Load input if provided\n\t            if (input) {\n\t                return new Promise(function (resolve, reject) {\n\t                    _this5.load(input).then(function () {\n\t                        resolve(_this5.parse());\n\t                    }).catch(reject);\n\t                });\n\t            }\n\t\n\t            // Start parsing element\n\t            return new Promise(function (resolve, reject) {\n\t                // If no element is loaded\n\t                if (!_this5.element) {\n\t                    reject(new Error('No element is loaded, call the load method before.'));\n\t                }\n\t\n\t                // Parse the main Element (recursive)\n\t                _this5.tags = _this5._parseElement(_this5.element);\n\t\n\t                if (!_this5.tags) {\n\t                    reject(new Error('No supported tags found.'));\n\t                }\n\t\n\t                // Apply matrix (recursive)\n\t                _this5.tags.applyMatrix();\n\t\n\t                // Resolve the promise\n\t                resolve(_this5.tags);\n\t            });\n\t        }\n\t\n\t        // On tag callback\n\t\n\t    }, {\n\t        key: '_onTag',\n\t        value: function _onTag(tag) {\n\t            console.info('onTag:', tag);\n\t        }\n\t\n\t        // Register on tag callback\n\t\n\t    }, {\n\t        key: 'onTag',\n\t        value: function onTag(callback, context) {\n\t            var _this6 = this;\n\t\n\t            this._onTag = function (tag) {\n\t                return callback.call(context || _this6, tag);\n\t            };\n\t        }\n\t\n\t        // Parse the provided Element and return an Tag collection (recursive)\n\t\n\t    }, {\n\t        key: '_parseElement',\n\t        value: function _parseElement(element, parent) {\n\t            var _this7 = this;\n\t\n\t            // Create base tag object\n\t            var tag = new _tag.Tag(element, parent);\n\t\n\t            // Exluded tag ?\n\t            if (this.skipTags.indexOf(tag.name) !== -1) {\n\t                return null; // silent\n\t            }\n\t\n\t            // Supported tag ?\n\t            if (this.parseTags.indexOf(tag.name) === -1) {\n\t                return this._skipTag(tag, 'unsupported');\n\t            }\n\t\n\t            // Parse the tag\n\t            var tagParser = new _tagparser.TagParser(tag, this);\n\t\n\t            if (!tagParser.parse()) {\n\t                return false;\n\t            }\n\t\n\t            // Call the on tag callback\n\t            this._onTag(tag);\n\t\n\t            // Parse child nodes\n\t            var childTag = void 0;\n\t\n\t            element.childNodes.forEach(function (childNode) {\n\t                // Parse child element\n\t                if (childTag = _this7._parseElement(childNode, tag)) {\n\t                    tag.addChild(childTag);\n\t                }\n\t            });\n\t\n\t            // Empty group\n\t            if (['svg', 'g'].indexOf(tag.name) !== -1 && !tag.children.length) {\n\t                return this._skipTag(tag, 'empty');\n\t            }\n\t\n\t            // Return tag object\n\t            return tag;\n\t        }\n\t\n\t        // Log skip tag warning message\n\t\n\t    }, {\n\t        key: '_skipTag',\n\t        value: function _skipTag(tag, message) {\n\t            console.warn('Skip tag :', message + ':', tag);\n\t            return false;\n\t        }\n\t\n\t        // Log skip tag attribute warning message\n\t\n\t    }, {\n\t        key: '_skipTagAttr',\n\t        value: function _skipTagAttr(tag, attr, message) {\n\t            console.warn('Skip tag attribute :', message + ':', attr, tag);\n\t            return false;\n\t        }\n\t    }]);\n\t\n\t    return Parser;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Parser = Parser;\n\texports.default = Parser;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Tag = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _path = __webpack_require__(1);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar DEG_TO_RAD = Math.PI / 180;\n\t\n\t// SVG tag class\n\t\n\tvar Tag = function () {\n\t    // Class constructor...\n\t    function Tag(element, parent) {\n\t        var _this = this;\n\t\n\t        _classCallCheck(this, Tag);\n\t\n\t        // Init properties\n\t        this.element = element;\n\t        this.name = element.nodeName.toLowerCase();\n\t        this.parent = parent || null;\n\t        this.layer = null;\n\t        this.attrs = {};\n\t        this.children = [];\n\t        this.paths = [];\n\t        this.matrix = null;\n\t        this.path = new _path.Path();\n\t        this.point = new _path.Point(0, 0);\n\t\n\t        // Add first path\n\t        this.paths.push(this.path);\n\t\n\t        // Set the matrix\n\t        this.setMatrix(this.parent && this.parent.matrix);\n\t\n\t        // Clone parent attributes\n\t        if (this.parent && (this.parent.name === 'g' || this.parent.name === 'svg')) {\n\t            (function () {\n\t                // Inherit layer name\n\t                _this.layer = _this.parent.layer;\n\t\n\t                // Inherit parent attributes\n\t                var excludes = ['transform', 'width', 'height'];\n\t\n\t                Object.keys(_this.parent.attrs).forEach(function (key) {\n\t                    if (excludes.indexOf(key) === -1) {\n\t                        _this.setAttr(key, _this.parent.attrs[key]);\n\t                    }\n\t                });\n\t            })();\n\t        }\n\t    }\n\t\n\t    _createClass(Tag, [{\n\t        key: 'setAttr',\n\t        value: function setAttr(name, value) {\n\t            this.attrs[name] = value;\n\t        }\n\t    }, {\n\t        key: 'getAttr',\n\t        value: function getAttr(name, defaultValue) {\n\t            return this.attrs[name] !== undefined ? this.attrs[name] : defaultValue !== undefined ? defaultValue : null;\n\t        }\n\t    }, {\n\t        key: 'getLayerName',\n\t        value: function getLayerName() {\n\t            if (this.name === 'g') {\n\t                return this.getAttr('inkscape:label', this.getAttr('id', null));\n\t            }\n\t        }\n\t    }, {\n\t        key: 'setLayerName',\n\t        value: function setLayerName(name) {\n\t            if (this.name === 'g') {\n\t                this.layer = name || this.getLayerName();\n\t            }\n\t        }\n\t    }, {\n\t        key: 'addChild',\n\t        value: function addChild(childTag) {\n\t            this.children.push(childTag);\n\t        }\n\t    }, {\n\t        key: 'clearPath',\n\t        value: function clearPath() {\n\t            this.path = new _path.Path();\n\t        }\n\t    }, {\n\t        key: 'newPath',\n\t        value: function newPath() {\n\t            if (this.path.length > 0) {\n\t                this.clearPath();\n\t                this.paths.push(this.path);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'closePath',\n\t        value: function closePath() {\n\t            return this.path.close();\n\t        }\n\t    }, {\n\t        key: 'addPoint',\n\t        value: function addPoint(x, y, relative) {\n\t            // Relative from the last point\n\t            if (relative) {\n\t                x += this.point.x;\n\t                y += this.point.y;\n\t            }\n\t\n\t            // Add current point\n\t            this.path.addPoint(x, y);\n\t\n\t            // Update current point\n\t            this.point = this.path.getPoint(-1);\n\t        }\n\t    }, {\n\t        key: 'addPoints',\n\t        value: function addPoints(points, relative) {\n\t            // For each couple of points\n\t            for (var i = 0, il = points.length; i < il; i += 2) {\n\t                this.addPoint(points[i], points[i + 1], relative);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'setMatrix',\n\t        value: function setMatrix(matrix) {\n\t            this.matrix = matrix || [1, 0, 0, 1, 0, 0];\n\t        }\n\t    }, {\n\t        key: 'addMatrix',\n\t        value: function addMatrix(matrix) {\n\t            this.matrix = [this.matrix[0] * matrix[0] + this.matrix[2] * matrix[1], this.matrix[1] * matrix[0] + this.matrix[3] * matrix[1], this.matrix[0] * matrix[2] + this.matrix[2] * matrix[3], this.matrix[1] * matrix[2] + this.matrix[3] * matrix[3], this.matrix[0] * matrix[4] + this.matrix[2] * matrix[5] + this.matrix[4], this.matrix[1] * matrix[4] + this.matrix[3] * matrix[5] + this.matrix[5]];\n\t        }\n\t    }, {\n\t        key: 'translate',\n\t        value: function translate(x, y) {\n\t            y = y === undefined ? 0 : y;\n\t            this.addMatrix([1, 0, 0, 1, x, y]);\n\t        }\n\t    }, {\n\t        key: 'rotate',\n\t        value: function rotate(angle, x, y) {\n\t            angle = angle * DEG_TO_RAD;\n\t\n\t            if (arguments.length == 2) {\n\t                this.addMatrix([1, 0, 0, 1, x, y]);\n\t            }\n\t\n\t            this.addMatrix([Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0]);\n\t\n\t            if (arguments.length == 2) {\n\t                this.addMatrix([1, 0, 0, 1, -x, -y]);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'scale',\n\t        value: function scale(x, y) {\n\t            y = y === undefined ? x : y;\n\t            this.addMatrix([x, 0, 0, y, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'skewX',\n\t        value: function skewX(angle) {\n\t            this.addMatrix([1, 0, Math.tan(angle * DEG_TO_RAD), 1, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'skewY',\n\t        value: function skewY(angle) {\n\t            this.addMatrix([1, Math.tan(angle * DEG_TO_RAD), 0, 1, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'applyMatrix',\n\t        value: function applyMatrix(matrix) {\n\t            var _this2 = this;\n\t\n\t            matrix && this.addMatrix(matrix);\n\t\n\t            this.paths.forEach(function (path) {\n\t                path.transform(_this2.matrix);\n\t            });\n\t\n\t            this.setMatrix(null);\n\t\n\t            this.children.forEach(function (tag) {\n\t                tag.applyMatrix(matrix);\n\t            });\n\t        }\n\t    }]);\n\t\n\t    return Tag;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Tag = Tag;\n\texports.default = Tag;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.TagParser = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _trace = __webpack_require__(5);\n\t\n\tvar _path2 = __webpack_require__(1);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// SVG tag parser\n\tvar TagParser = function () {\n\t    // Class constructor...\n\t    function TagParser(tag, parser) {\n\t        _classCallCheck(this, TagParser);\n\t\n\t        // Init properties\n\t        this.tag = tag;\n\t        this.parser = parser;\n\t        this.currentCommand = null;\n\t        this.lastCommand = null;\n\t        this.pathData = null;\n\t        this.traceSettings = parser.traceSettings;\n\t    }\n\t\n\t    _createClass(TagParser, [{\n\t        key: 'parse',\n\t        value: function parse() {\n\t            var _this = this;\n\t\n\t            // Get internal parser from node name\n\t            var handler = this['_' + this.tag.name];\n\t\n\t            // Implemented tag handler?\n\t            if (!handler || typeof handler !== 'function') {\n\t                return this.parser._skipTag(this.tag, 'not yet implemented');\n\t            }\n\t\n\t            // Parse tag attributes\n\t            this._parseTagAttrs();\n\t\n\t            // Parse tag\n\t            var result = handler.call(this);\n\t\n\t            if (result && this.tag.getAttr('fill') && this.tag.paths[0].length) {\n\t                (function () {\n\t                    var paths = [];\n\t                    var debug = [];\n\t\n\t                    _this.tag.paths.forEach(function (path) {\n\t                        _this.tag.triangles = null;\n\t                        paths.push(path.getFlattenPoints());\n\t                        debug.push('[' + path.getFlattenPoints().join(',') + ']');\n\t                    });\n\t\n\t                    console.log(paths.length, debug.join(','));\n\t                })();\n\t            }\n\t\n\t            return result;\n\t        }\n\t\n\t        // Parse the tag attributes\n\t\n\t    }, {\n\t        key: '_parseTagAttrs',\n\t        value: function _parseTagAttrs() {\n\t            var _this2 = this;\n\t\n\t            // Get tag attributes\n\t            var attrs = this.tag.element.attributes;\n\t\n\t            if (!attrs) {\n\t                return null;\n\t            }\n\t\n\t            // For each attribute\n\t            var attr = void 0,\n\t                value = void 0,\n\t                style = void 0;\n\t\n\t            Object.keys(attrs).some(function (key) {\n\t                // Current attribute\n\t                attr = attrs[key];\n\t\n\t                // Normalize attribute value\n\t                value = _this2._normalizeTagAttr(attr);\n\t\n\t                if (value === false) {\n\t                    return false; // continue\n\t                }\n\t\n\t                // Special case\n\t                if (attr.nodeName === 'style') {\n\t                    style = value;\n\t                } else {\n\t                    // Set new attribute name/value\n\t                    _this2.tag.setAttr(attr.nodeName, value);\n\t                }\n\t            });\n\t\n\t            // If style attribute (override tag attributes)\n\t            // TODO get/parse global style and override this one...\n\t            style && style.split(';').some(function (attr) {\n\t                // Current style\n\t                attr = attr.split(':');\n\t                attr = { nodeName: attr[0], nodeValue: attr[1] };\n\t\n\t                // Normalize attribute value\n\t                value = _this2._normalizeTagAttr(attr);\n\t\n\t                if (value === false) {\n\t                    return false; // continue\n\t                }\n\t\n\t                // Set new attribute name/value\n\t                _this2.tag.setAttr(attr.nodeName, value);\n\t            });\n\t\n\t            // Set inherited color\n\t            var colorsAttrs = ['fill', 'stroke', 'color'];\n\t\n\t            colorsAttrs.forEach(function (attrName) {\n\t                if (_this2.tag.getAttr(attrName) === 'inherit') {\n\t                    _this2.tag.setAttr(attrName, _this2.tag.parent.getAttr(attrName, 'none'));\n\t                }\n\t            });\n\t\n\t            // Parse viewBox attribute\n\t            this._parseViewBoxAttr();\n\t\n\t            // Parse transform attribute\n\t            this._parseTransformAttr();\n\t        }\n\t\n\t        // Normalize tag attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttr',\n\t        value: function _normalizeTagAttr(attr) {\n\t            // Normalize whitespaces\n\t            var value = attr.nodeValue.replace(/(\\r?\\n|\\r)+/gm, ' ') // Remove all new line chars\n\t            .replace(/\\s+/gm, ' ') // Reduce multiple whitespaces\n\t            .trim(); // Remove trailing whitespaces\n\t\n\t            if (!value.length) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'empty');\n\t            }\n\t\n\t            // Filters\n\t            switch (attr.nodeName) {\n\t                // Normalize size unit -> to px\n\t                case 'x':\n\t                case 'y':\n\t                case 'x1':\n\t                case 'y1':\n\t                case 'x2':\n\t                case 'y2':\n\t                case 'r':\n\t                case 'rx':\n\t                case 'ry':\n\t                case 'cx':\n\t                case 'cy':\n\t                case 'width':\n\t                case 'height':\n\t                case 'fontSize':\n\t                case 'strokeWidth':\n\t                    value = this._normalizeTagAttrUnit(attr);\n\t                    break;\n\t\n\t                // Normalize points attribute\n\t                case 'points':\n\t                case 'viewBox':\n\t                    value = this._normalizeTagAttrPoints(attr);\n\t                    break;\n\t\n\t                // Range limit to [0 - 1]\n\t                case 'opacity':\n\t                case 'fillOpacity':\n\t                case 'strokeOpacity':\n\t                    value = this._normalizeTagAttrRange(attr, 0, 1);\n\t                    break;\n\t\n\t                case 'preserveAspectRatio':\n\t                    value = this._normalizeTagAttrPreserveAspectRatio(attr);\n\t                    break;\n\t            }\n\t\n\t            // Return normalized value\n\t            return value;\n\t        }\n\t\n\t        // Normalize attribute unit to px\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrUnit',\n\t        value: function _normalizeTagAttrUnit(attr) {\n\t            var stringValue = attr.nodeValue.toLowerCase();\n\t            var floatValue = parseFloat(stringValue);\n\t\n\t            if (isNaN(floatValue)) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric value allowed');\n\t            }\n\t\n\t            if (stringValue.indexOf('mm') !== -1) {\n\t                return floatValue * 3.5433070869;\n\t            }\n\t\n\t            if (stringValue.indexOf('cm') !== -1) {\n\t                return floatValue * 35.433070869;\n\t            }\n\t\n\t            if (stringValue.indexOf('in') !== -1) {\n\t                return floatValue * 90.0;\n\t            }\n\t\n\t            if (stringValue.indexOf('pt') !== -1) {\n\t                return floatValue * 1.25;\n\t            }\n\t\n\t            if (stringValue.indexOf('pc') !== -1) {\n\t                return floatValue * 15.0;\n\t            }\n\t\n\t            return floatValue;\n\t        }\n\t\n\t        // Normalize points attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrPoints',\n\t        value: function _normalizeTagAttrPoints(attr) {\n\t            var points = this._parseNumbers(attr.nodeValue);\n\t\n\t            if (points === false) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed');\n\t            }\n\t\n\t            if (!points.length) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'empty points list');\n\t            }\n\t\n\t            if (points.length % 0) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'the number of points must be even');\n\t            }\n\t\n\t            return points;\n\t        }\n\t\n\t        // Normalize range attribute like \"opacity\"\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrRange',\n\t        value: function _normalizeTagAttrRange(attr, min, max) {\n\t            var stringValue = attr.nodeValue.trim();\n\t            var floatValue = parseFloat(stringValue);\n\t\n\t            if (isNaN(floatValue)) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed');\n\t            }\n\t\n\t            if (floatValue < min || floatValue > max) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'out of range [' + min + ', ' + max + ']');\n\t            }\n\t\n\t            return floatValue;\n\t        }\n\t\n\t        // Parse points string as numbers array\n\t\n\t    }, {\n\t        key: '_parseNumbers',\n\t        value: function _parseNumbers(points) {\n\t            // http://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly\n\t            if (typeof points === 'string') {\n\t                points = points.split(/([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/g).filter(function (point) {\n\t                    return point && ['', ','].indexOf(point.trim()) === -1;\n\t                });\n\t            }\n\t\n\t            // Normalize to float values\n\t            points = points.map(parseFloat);\n\t\n\t            // Test if all numbers is valid\n\t            if (points.some(isNaN)) {\n\t                return false;\n\t            }\n\t\n\t            return points;\n\t        }\n\t\n\t        // Normalize the preserveAspectRatio attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrPreserveAspectRatio',\n\t        value: function _normalizeTagAttrPreserveAspectRatio(attr) {\n\t            var params = {\n\t                defer: false,\n\t                align: 'none',\n\t                meet: true,\n\t                slice: false\n\t            };\n\t\n\t            var rawParams = attr.nodeValue;\n\t\n\t            if (rawParams.indexOf('defer') === 0) {\n\t                rawParams = rawParams.substr(6);\n\t                params.defer = true;\n\t            }\n\t\n\t            rawParams = rawParams.split(' ');\n\t            params.align = rawParams[0];\n\t            params.meet = rawParams[1] || 'meet';\n\t            params.meet = params.meet === 'meet';\n\t            params.slice = !params.meet;\n\t\n\t            return params;\n\t        }\n\t\n\t        // Parse viewBox attribute and set transformations\n\t\n\t    }, {\n\t        key: '_parseViewBoxAttr',\n\t        value: function _parseViewBoxAttr() {\n\t            // Get viewBox attribute\n\t            var viewBox = this.tag.getAttr('viewBox', null);\n\t\n\t            // No viewBox...\n\t            if (viewBox === null) {\n\t                return null;\n\t            }\n\t\n\t            // Update size attributes\n\t            var width = this.tag.getAttr('width', viewBox[2]);\n\t            var height = this.tag.getAttr('height', viewBox[3]);\n\t\n\t            this.tag.setAttr('width', width);\n\t            this.tag.setAttr('height', height);\n\t\n\t            // Scale to match viewBox\n\t            // TODO clip path if preserveAspectRatio.slice\n\t            var scaleX = width / viewBox[2];\n\t            var scaleY = height / viewBox[3];\n\t            var translateX = viewBox[0];\n\t            var translateY = viewBox[1];\n\t\n\t            var preserveAspectRatio = this.tag.getAttr('preserveAspectRatio', 'meet xMidYMid');\n\t\n\t            if (preserveAspectRatio) {\n\t                var newWidth = void 0,\n\t                    newHeight = void 0;\n\t\n\t                if (preserveAspectRatio.meet) {\n\t                    if (scaleX > scaleY) {\n\t                        scaleX = scaleY;\n\t                        newWidth = viewBox[2] * scaleX;\n\t                    } else if (scaleX < scaleY) {\n\t                        scaleY = scaleX;\n\t                        newHeight = viewBox[3] * scaleY;\n\t                    }\n\t                } else if (preserveAspectRatio.slice) {\n\t                    if (scaleX < scaleY) {\n\t                        scaleX = scaleY;\n\t                        newWidth = viewBox[2] * scaleX;\n\t                    } else if (scaleX > scaleY) {\n\t                        scaleY = scaleX;\n\t                        newHeight = viewBox[3] * scaleY;\n\t                    }\n\t                }\n\t\n\t                if (newWidth !== undefined) {\n\t                    if (preserveAspectRatio.align === 'xMidYMid') {\n\t                        this.tag.translate((width - newWidth) / 2, 0);\n\t                    } else if (preserveAspectRatio.align === 'xMaxYMax') {\n\t                        this.tag.translate(width - newWidth, 0);\n\t                    }\n\t                } else if (newHeight !== undefined) {\n\t                    if (preserveAspectRatio.align === 'xMidYMid') {\n\t                        this.tag.translate(0, (height - newHeight) / 2);\n\t                    } else if (preserveAspectRatio.align === 'xMaxYMax') {\n\t                        this.tag.translate(0, height - newHeight);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.tag.scale(scaleX, scaleY);\n\t            this.tag.translate(-translateX, -translateY);\n\t        }\n\t\n\t        // Parse transform attribute and set transformations\n\t\n\t    }, {\n\t        key: '_parseTransformAttr',\n\t        value: function _parseTransformAttr() {\n\t            var _this3 = this;\n\t\n\t            // Get transform attribute\n\t            var transformAttr = this.tag.getAttr('transform', null);\n\t\n\t            // No transformation...\n\t            if (transformAttr === null || !transformAttr.length) {\n\t                return null;\n\t            }\n\t\n\t            // Parse attribute (split group on closing parenthesis)\n\t            var transformations = transformAttr.split(')');\n\t\n\t            // Remove last entry due to last \")\" found\n\t            transformations.pop();\n\t\n\t            // For each transformation\n\t            var transform = void 0,\n\t                type = void 0,\n\t                params = void 0;\n\t\n\t            transformations.some(function (raw) {\n\t                // Split name and value on opening parenthesis\n\t                transform = raw.split('(');\n\t\n\t                // Invalid parts number\n\t                if (transform.length !== 2) {\n\t                    return _this3.parser._skipTagAttr(_this3.tag, transformAttr, 'malformed'); // continue\n\t                }\n\t\n\t                type = transform[0].trim();\n\t\n\t                // Quik hack 1/2\n\t                var func = type;\n\t                if (func === 'matrix') {\n\t                    func = 'addMatrix';\n\t                }\n\t\n\t                // Get tag transform method\n\t                var tagTransform = _this3.tag[func];\n\t\n\t                if (typeof tagTransform !== 'function') {\n\t                    return _this3.parser._skipTagAttr(_this3.tag, transformAttr, 'unsupported transform type :' + type);\n\t                }\n\t\n\t                params = transform[1].trim();\n\t                params = _this3._parseNumbers(params);\n\t\n\t                // Skip empty value\n\t                if (!params.length) {\n\t                    return _this3.parser._skipTagAttr(_this3.tag, transformAttr, 'malformed transform type :' + type);\n\t                }\n\t\n\t                // Quik hack 2/2\n\t                if (func == 'addMatrix') {\n\t                    params = [params];\n\t                }\n\t\n\t                // Call tag transform method like \"tag.translate(param1, ..., paramN)\"\n\t                tagTransform.apply(_this3.tag, params);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_newPath',\n\t        value: function _newPath() {\n\t            this.tag.newPath();\n\t        }\n\t    }, {\n\t        key: '_clearPath',\n\t        value: function _clearPath() {\n\t            this.tag.clearPath();\n\t        }\n\t    }, {\n\t        key: '_closePath',\n\t        value: function _closePath() {\n\t            return this.tag.closePath();\n\t        }\n\t    }, {\n\t        key: '_addPoints',\n\t        value: function _addPoints(points, relative) {\n\t            if (!points.length) {\n\t                return this.parser._skipTag(this.tag, 'empty points list');\n\t            }\n\t\n\t            if (points.length % 0) {\n\t                return this.parser._skipTag(this.tag, 'the number of points must be even');\n\t            }\n\t\n\t            relative = arguments.length < 2 && this.currentCommand.relative;\n\t\n\t            this.tag.addPoints(points, relative);\n\t            return true;\n\t        }\n\t\n\t        // SVG specs at https://www.w3.org/TR/SVG11/\n\t\n\t    }, {\n\t        key: '_svg',\n\t        value: function _svg() {\n\t            // Only parse the root SVG tag as main document\n\t            if (this.parser.document) {\n\t                // Handled tag\n\t                return true;\n\t            }\n\t\n\t            // Get the document size\n\t            var width = this.tag.getAttr('width');\n\t            var height = this.tag.getAttr('height');\n\t\n\t            // Invalid size\n\t            if (!width || width < 0 || !height || height < 0) {\n\t                throw new Error('Invalid document size: ' + width + ' / ' + height);\n\t            }\n\t\n\t            // Set document size\n\t            this.parser.document = {\n\t                width: width,\n\t                height: height\n\t            };\n\t\n\t            // Get document viewBox or set default to document size\n\t            var viewBox = this.tag.getAttr('viewBox', [0, 0, width, height]);\n\t\n\t            this.parser.document.viewBox = {\n\t                x: viewBox[0],\n\t                y: viewBox[1],\n\t                width: viewBox[2],\n\t                height: viewBox[3]\n\t            };\n\t\n\t            // Check inkscape version\n\t            if (this.parser.editor.name === 'inkscape') {\n\t                this.parser.editor.version = this.tag.getAttr('inkscape:version');\n\t            }\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_title',\n\t        value: function _title() {\n\t            // Register the first encountered title tag as document title\n\t            if (this.parser.document && !this.parser.document.title) {\n\t                this.parser.document.title = this.tag.element.textContent;\n\t            }\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_desc',\n\t        value: function _desc() {\n\t            // Register the first encountered desc tag as document description\n\t            if (this.parser.document && !this.parser.document.description) {\n\t                this.parser.document.description = this.tag.element.textContent;\n\t            }\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_defs',\n\t        value: function _defs() {\n\t            var _this4 = this;\n\t\n\t            // Register all child element with an id attribute\n\t            this.tag.element.childNodes.forEach(function (childNode) {\n\t                childNode.id && (_this4.parser.defs[childNode.id] = childNode);\n\t            });\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_use',\n\t        value: function _use() {\n\t            // Get the target id\n\t            var target = this.tag.getAttr('xlink:href').replace(/^#/, '');\n\t\n\t            // Try to get the defined element\n\t            var element = this.parser.defs[target];\n\t\n\t            if (!element) {\n\t                return this.parser._skipTag(this.tag, 'undefined reference [' + target + ']');\n\t            }\n\t\n\t            // Parse the defined element and set new parent from <use> tag parent\n\t            var useTag = this.parser._parseElement(element, this.tag.parent);\n\t\n\t            if (!useTag) {\n\t                return this.parser._skipTag(this.tag, 'empty reference [' + target + ']');\n\t            }\n\t\n\t            // Set matrix from real parent (<use>)\n\t            useTag.setMatrix(this.tag.matrix);\n\t\n\t            // Replace the use tag with new one\n\t            this.tag.parent.addChild(useTag);\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_g',\n\t        value: function _g() {\n\t            // Set the tag layer name\n\t            this.tag.setLayerName();\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_line',\n\t        value: function _line() {\n\t            // Handled tag\n\t            return this._path(['M', this.tag.getAttr('x1'), this.tag.getAttr('y1'), 'L', this.tag.getAttr('x2'), this.tag.getAttr('y2')]);\n\t        }\n\t    }, {\n\t        key: '_polyline',\n\t        value: function _polyline() {\n\t            var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t            var points = this.tag.getAttr('points');\n\t            var path = ['M', points.shift(), points.shift(), 'L'];\n\t\n\t            path = path.concat(points);\n\t            close && path.push('Z');\n\t\n\t            // Handled tag\n\t            return this._path(path);\n\t        }\n\t    }, {\n\t        key: '_polygon',\n\t        value: function _polygon() {\n\t            // Handled like polyline but closed\n\t            return this._polyline(true);\n\t        }\n\t    }, {\n\t        key: '_rect',\n\t        value: function _rect() {\n\t            // Get rectangle attributes\n\t            var w = this.tag.getAttr('width');\n\t            var h = this.tag.getAttr('height');\n\t            var x = this.tag.getAttr('x', 0);\n\t            var y = this.tag.getAttr('y', 0);\n\t            var rx = this.tag.getAttr('rx', null);\n\t            var ry = this.tag.getAttr('ry', null);\n\t\n\t            // Simple rect\n\t            if (!rx && !ry) {\n\t                // Handled tag\n\t                return this._path(['M', x, y, 'h', w, 'v', h, 'h', -w, 'z']);\n\t            }\n\t\n\t            // If a properly specified value is provided for ‘rx’, but not for ‘ry’,\n\t            // then set both rx and ry to the value of ‘rx’ and vis-vera...\n\t            if (rx === null) rx = ry;\n\t            if (ry === null) ry = rx;\n\t\n\t            // A negative value is an error\n\t            if (rx === null || rx === null || rx < 0 || ry < 0) {\n\t                // Skip tag\n\t                return this.parser._skipTag(this.tag, 'negative value for \"rx/ry\" not allowed');\n\t            }\n\t\n\t            // If rx is greater than half of ‘width’, then set rx to half of ‘width’.\n\t            // If ry is greater than half of ‘height’, then set ry to half of ‘height’.\n\t            if (rx > w / 2) rx = w / 2;\n\t            if (ry > h / 2) ry = h / 2;\n\t\n\t            var dx = rx * 2;\n\t            var dy = ry * 2;\n\t\n\t            // Handled tag\n\t            return this._path(['M', x + rx, y, 'h', w - dx, 'c', rx, 0, rx, ry, rx, ry, 'v', h - dy, 'c', 0, ry, -rx, ry, -rx, ry, 'h', -w + dx, 'c', -rx, 0, -rx, -ry, -rx, -ry, 'v', -h + dy, 'c', 0, 0, 0, -ry, rx, -ry, 'z']);\n\t        }\n\t    }, {\n\t        key: '_circle',\n\t        value: function _circle() {\n\t            var r = this.tag.getAttr('r', 0);\n\t\n\t            if (r <= 0) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            var cx = this.tag.getAttr('cx', 0);\n\t            var cy = this.tag.getAttr('cy', 0);\n\t\n\t            // Handled tag\n\t            return this._path(['M', cx - r, cy, 'A', r, r, 0, 0, 0, cx, cy + r, 'A', r, r, 0, 0, 0, cx + r, cy, 'A', r, r, 0, 0, 0, cx, cy - r, 'A', r, r, 0, 0, 0, cx - r, cy, 'Z']);\n\t        }\n\t    }, {\n\t        key: '_ellipse',\n\t        value: function _ellipse() {\n\t            var rx = this.tag.getAttr('rx', 0);\n\t            var ry = this.tag.getAttr('ry', 0);\n\t\n\t            if (rx <= 0 || ry <= 0) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            var cx = this.tag.getAttr('cx', 0);\n\t            var cy = this.tag.getAttr('cy', 0);\n\t\n\t            // Handled tag\n\t            return this._path(['M', cx - rx, cy, 'A', rx, ry, 0, 0, 0, cx, cy + ry, 'A', rx, ry, 0, 0, 0, cx + rx, cy, 'A', rx, ry, 0, 0, 0, cx, cy - ry, 'A', rx, ry, 0, 0, 0, cx - rx, cy, 'Z']);\n\t        }\n\t    }, {\n\t        key: '_paths',\n\t        value: function _paths(type, num, points) {\n\t            if (points.length > num) {\n\t                var handler = void 0,\n\t                    result = true;\n\t\n\t                while (result && points.length) {\n\t                    handler = this['_path' + type];\n\t                    result = handler.call(this, points.splice(0, num));\n\t                }\n\t\n\t                return result;\n\t            }\n\t\n\t            return null;\n\t        }\n\t    }, {\n\t        key: '_path',\n\t        value: function _path(path) {\n\t            var _this5 = this;\n\t\n\t            // Provided path\n\t            if (path && typeof path !== 'string') {\n\t                path = path.join(' ');\n\t            }\n\t\n\t            // Get the paths data attribute value\n\t            var dAttr = path || this.tag.getAttr('d', null);\n\t\n\t            if (!dAttr) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            // Split on each commands\n\t            var commands = dAttr.match(/([M|Z|L|H|V|C|S|Q|T|A]+([^M|Z|L|H|V|C|S|Q|T|A]+)?)/gi);\n\t\n\t            if (!commands) {\n\t                return this.parser._skipTag(this.tag, 'malformed \"d\" attribute');\n\t            }\n\t\n\t            // For each command...\n\t            this.currentCommand = {\n\t                raw: null,\n\t                type: null,\n\t                params: null,\n\t                relative: null\n\t            };\n\t            this.lastCommand = this.currentCommand;\n\t            this.pathData = {};\n\t\n\t            var handler = null;\n\t            var parseError = false;\n\t\n\t            commands.some(function (raw) {\n\t                // Remove trailing whitespaces\n\t                raw = raw.trim();\n\t\n\t                // Extract command char and params\n\t                _this5.currentCommand.raw = raw;\n\t                _this5.currentCommand.type = raw[0].toUpperCase();\n\t                _this5.currentCommand.params = raw.substr(1).trim();\n\t                _this5.currentCommand.relative = _this5.currentCommand.type !== raw[0];\n\t\n\t                // Get path handler from command char\n\t                handler = _this5['_path' + _this5.currentCommand.type];\n\t\n\t                if (!handler || typeof handler !== 'function') {\n\t                    _this5.parser._skipTag(_this5.tag, 'unsupported path command [' + raw[0] + ']');\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Extract all numbers from arguments string\n\t                _this5.currentCommand.params = _this5._parseNumbers(_this5.currentCommand.params);\n\t\n\t                if (_this5.currentCommand.params === false) {\n\t                    _this5.parser._skipTag(_this5.tag, 'only numeric values are allowed in [' + _this5.currentCommand.raw + ']');\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Execute command parser\n\t                if (!handler.call(_this5, _this5.currentCommand.params)) {\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Update last command\n\t                _this5.lastCommand = {};\n\t\n\t                Object.keys(_this5.currentCommand).forEach(function (key) {\n\t                    _this5.lastCommand[key] = _this5.currentCommand[key];\n\t                });\n\t            });\n\t\n\t            // Skip tag\n\t            if (parseError) {\n\t                this._clearPath();\n\t                return false;\n\t            }\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_pathM',\n\t        value: function _pathM(points) {\n\t            // New path\n\t            this._newPath();\n\t\n\t            // Set the current point (start of new path)\n\t            // If is followed by multiple pairs of coordinates,\n\t            // the subsequent pairs are treated as implicit lineto commands.\n\t            return this._addPoints(points);\n\t        }\n\t    }, {\n\t        key: '_pathZ',\n\t        value: function _pathZ() {\n\t            this._closePath();\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_pathL',\n\t        value: function _pathL(points) {\n\t            return this._addPoints(points);\n\t        }\n\t    }, {\n\t        key: '_pathH',\n\t        value: function _pathH(points) {\n\t            var _this6 = this;\n\t\n\t            return points.every(function (x) {\n\t                return _this6._addPoints([x, _this6.currentCommand.relative ? 0 : _this6.tag.point.y]);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_pathV',\n\t        value: function _pathV(points) {\n\t            var _this7 = this;\n\t\n\t            return points.every(function (y) {\n\t                return _this7._addPoints([_this7.currentCommand.relative ? 0 : _this7.tag.point.x, y]);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_pathC',\n\t        value: function _pathC(points) {\n\t            // Multiple paths\n\t            var result = this._paths('C', 6, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = points[0] + (rl ? p1.x : 0);\n\t            var y1 = points[1] + (rl ? p1.y : 0);\n\t            var x2 = points[2] + (rl ? p1.x : 0);\n\t            var y2 = points[3] + (rl ? p1.y : 0);\n\t            var x = points[4] + (rl ? p1.x : 0);\n\t            var y = points[5] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x2 = x2;\n\t            this.pathData.y2 = y2;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x2, y2);\n\t            var p4 = new _path2.Point(x, y);\n\t\n\t            //console.log('C', p1, p2, p3, p4)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : control point\n\t            // p4  : end point\n\t            var tracer = new _trace.CubicBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3, p4: p4 }); // => [x,y, x,y, ...]\n\t            // let tracer = trace(CubicBezier, this.traceSettings)\n\t            // let coords = tracer({ p1, p2, p3, p4 })\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathS',\n\t        value: function _pathS(points) {\n\t            // Multiple paths\n\t            var result = this._paths('S', 4, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = p1.x;\n\t            var y1 = p1.y;\n\t\n\t            if (this.lastCommand.type === 'S' || this.lastCommand.type === 'C') {\n\t                x1 -= this.pathData.x2 - x1;\n\t                y1 -= this.pathData.y2 - y1;\n\t            }\n\t\n\t            var x2 = points[0] + (rl ? p1.x : 0);\n\t            var y2 = points[1] + (rl ? p1.y : 0);\n\t            var x = points[2] + (rl ? p1.x : 0);\n\t            var y = points[3] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x2 = x2;\n\t            this.pathData.y2 = y2;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x2, y2);\n\t            var p4 = new _path2.Point(x, y);\n\t\n\t            //console.log('S', p1, p2, p3, p4)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : control point\n\t            // p4  : end point\n\t            var tracer = new _trace.CubicBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3, p4: p4 }); // => [x,y, x,y, ...]\n\t            // let tracer = trace(CubicBezier, this.traceSettings)\n\t            // let coords = tracer({ p1, p2, p3, p4 })\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathQ',\n\t        value: function _pathQ(points) {\n\t            // Multiple paths\n\t            var result = this._paths('Q', 4, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = points[0] + (rl ? p1.x : 0);\n\t            var y1 = points[1] + (rl ? p1.y : 0);\n\t            var x = points[2] + (rl ? p1.x : 0);\n\t            var y = points[3] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x1 = x1;\n\t            this.pathData.y1 = y1;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x, y);\n\t\n\t            //console.log('Q', p1, p2, p3)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : end point\n\t            var tracer = new _trace.QuadricBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathT',\n\t        value: function _pathT(points) {\n\t            // Multiple paths\n\t            var result = this._paths('T', 2, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = p1.x;\n\t            var y1 = p1.y;\n\t\n\t            if (this.lastCommand.type === 'Q' || this.lastCommand.type === 'T') {\n\t                x1 -= this.pathData.x1 - x1;\n\t                y1 -= this.pathData.y1 - y1;\n\t            }\n\t\n\t            var x = points[0] + (rl ? p1.x : 0);\n\t            var y = points[1] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x1 = x1;\n\t            this.pathData.y1 = y1;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x, y);\n\t\n\t            //console.log('T', p1, p2, p3)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : end point\n\t            var tracer = new _trace.QuadricBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathA',\n\t        value: function _pathA(points) {\n\t            // Multiple paths\n\t            var result = this._paths('A', 7, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var rl = this.currentCommand.relative;\n\t            var p1 = this.tag.point;\n\t            var rx = points[0];\n\t            var ry = points[1];\n\t            var angle = points[2];\n\t            var large = !!points[3];\n\t            var sweep = !!points[4];\n\t            var x = points[5] + (rl ? p1.x : 0);\n\t            var y = points[6] + (rl ? p1.y : 0);\n\t            var p2 = new _path2.Point(x, y);\n\t\n\t            //console.log('A', p1, rx, ry, angle, large, sweep, p2)\n\t\n\t            var tracer = new _trace.Arc(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, rx: rx, ry: ry, angle: angle, large: large, sweep: sweep, p2: p2 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }]);\n\t\n\t    return TagParser;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.TagParser = TagParser;\n\texports.default = TagParser;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.QuadricBezier = exports.CubicBezier = exports.Arc = undefined;\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Base code from : https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js\n\t\n\t\n\tvar _path = __webpack_require__(1);\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar MATH_PI_2 = Math.PI * 2;\n\tvar DEG_TO_RAD = Math.PI / 180;\n\t\n\tfunction mod(x, m) {\n\t    return (x % m + m) % m;\n\t}\n\t\n\tfunction clamp(val, min, max) {\n\t    return Math.min(Math.max(val, min), max);\n\t}\n\t\n\tfunction distance(p0, p1) {\n\t    return Math.sqrt(Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2));\n\t}\n\t\n\tfunction angle(v0, v1) {\n\t    var p = v0.x * v1.x + v0.y * v1.y;\n\t    var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));\n\t    return (v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1) * Math.acos(p / n);\n\t}\n\t\n\t// Abstract class\n\t\n\tvar TraceBase = function () {\n\t    function TraceBase(settings) {\n\t        _classCallCheck(this, TraceBase);\n\t\n\t        // Set defaults properties\n\t        this.path = []; // Points collection [x,y, x,y, ...]\n\t        this.linear = true; // Linear trace mode\n\t        this.step = 0.01; // Step resolution if linear mode = false\n\t        this.resolution = 500; // number of segments we use to approximate arc length\n\t        this.minSegmentLength = 0.01; // Minimum segemnt length\n\t        this.segments = 24; // Numbers of segments\n\t\n\t        // Update properties from user settings\n\t        Object.assign(this, settings || {});\n\t\n\t        // Arc length properties\n\t        this.arcLength = null;\n\t        this.arcLengthMap = null;\n\t    }\n\t\n\t    _createClass(TraceBase, [{\n\t        key: '_clearPath',\n\t        value: function _clearPath() {\n\t            this.path = [];\n\t        }\n\t    }, {\n\t        key: 'getPath',\n\t        value: function getPath() {\n\t            return this.path;\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            return new _path.Point(0, 0);\n\t        }\n\t    }, {\n\t        key: '_addPoint',\n\t        value: function _addPoint(point) {\n\t            this.path.push(point.x, point.y);\n\t        }\n\t    }, {\n\t        key: '_postTrace',\n\t        value: function _postTrace() {\n\t            // Do additional tasks\n\t        }\n\t    }, {\n\t        key: '_approximateLength',\n\t        value: function _approximateLength() {\n\t            var arcLength = 0;\n\t            var arcLengthMap = [];\n\t            var prevPoint = this.getPointAtT(0);\n\t\n\t            var i = void 0,\n\t                t = void 0,\n\t                nextPoint = void 0;\n\t\n\t            for (i = 0; i < this.resolution; i++) {\n\t                t = clamp(i * (1 / this.resolution), 0, 1);\n\t                nextPoint = this.getPointAtT(t);\n\t                arcLength += distance(prevPoint, nextPoint);\n\t\n\t                arcLengthMap.push({ t: t, arcLength: arcLength });\n\t\n\t                prevPoint = nextPoint;\n\t            }\n\t\n\t            // Last stretch to the endpoint\n\t            nextPoint = this.getPointAtT(1);\n\t            arcLength += distance(prevPoint, nextPoint);\n\t\n\t            arcLengthMap.push({ t: 1, arcLength: arcLength });\n\t            Object.assign(this, { arcLength: arcLength, arcLengthMap: arcLengthMap });\n\t        }\n\t    }, {\n\t        key: 'getPointAtU',\n\t        value: function getPointAtU(u) {\n\t            u = clamp(u, 0, 1);\n\t\n\t            var targetDistanceFromStartingPoint = u * this.arcLength;\n\t\n\t            var resultantT = 0;\n\t            var prevArcLength = 0;\n\t            var prevT = 0;\n\t\n\t            this.arcLengthMap.every(function (entry) {\n\t                var t = entry.t;\n\t                var arcLength = entry.arcLength;\n\t\n\t                // Once we go a past our target\n\t                // Lets interpolate from a previous to current\n\t                if (arcLength >= targetDistanceFromStartingPoint) {\n\t                    var endDiff = arcLength - targetDistanceFromStartingPoint;\n\t                    var startDiff = targetDistanceFromStartingPoint - prevArcLength;\n\t                    var linearFactor = startDiff / (endDiff + startDiff) || 0;\n\t\n\t                    resultantT = prevT + (t - prevT) * linearFactor;\n\t\n\t                    // Break\n\t                    return false;\n\t                }\n\t\n\t                prevArcLength = arcLength;\n\t                prevT = t;\n\t\n\t                return true;\n\t            });\n\t\n\t            return this.getPointAtT(resultantT);\n\t        }\n\t    }, {\n\t        key: 'trace',\n\t        value: function trace(settings) {\n\t            // Update properties from user settings\n\t            Object.assign(this, settings || {});\n\t\n\t            // Create default getPoint wrapper\n\t            var getPoint = 'getPointAtT';\n\t            var step = this.step;\n\t\n\t            // Linear mode ?\n\t            if (this.linear) {\n\t                getPoint = 'getPointAtU';\n\t                var segments = this.segments;\n\t\n\t                this._approximateLength();\n\t\n\t                if (this.arcLength / segments < this.minSegmentLength) {\n\t                    segments = this.arcLength / this.minSegmentLength;\n\t                }\n\t\n\t                step = 1 / segments;\n\t            }\n\t\n\t            // Clear points list\n\t            this._clearPath();\n\t\n\t            // Trace the path\n\t            for (var t = 0; t <= 1; t += step) {\n\t                this._addPoint(this[getPoint](t));\n\t            }\n\t\n\t            // Do additional tasks\n\t            this._postTrace();\n\t\n\t            // Return the path\n\t            return this.getPath();\n\t        }\n\t    }]);\n\t\n\t    return TraceBase;\n\t}();\n\t\n\t// Rewrite from https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js#L84\n\t\n\t\n\tvar Arc = function (_TraceBase) {\n\t    _inherits(Arc, _TraceBase);\n\t\n\t    function Arc() {\n\t        _classCallCheck(this, Arc);\n\t\n\t        return _possibleConstructorReturn(this, (Arc.__proto__ || Object.getPrototypeOf(Arc)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(Arc, [{\n\t        key: 'init',\n\t        value: function init(settings) {\n\t            // Update properties from user settings\n\t            Object.assign(this, settings || {});\n\t\n\t            // Get angle in radians\n\t            this.radians = mod(this.angle, 360) * DEG_TO_RAD;\n\t\n\t            // If the endpoints are identical, then this is equivalent\n\t            // to omitting the elliptical arc segment entirely.\n\t            if (this.p1.x === this.p2.x && this.p1.y === this.p2.y) {\n\t                return this.path;\n\t            }\n\t\n\t            this.rx = Math.abs(this.rx);\n\t            this.ry = Math.abs(this.ry);\n\t\n\t            // If rx = 0 or ry = 0 then this arc is treated as\n\t            // a straight line segment joining the endpoints.\n\t            if (this.rx === 0 || this.ry === 0) {\n\t                this.__addPoint(this.p1);\n\t                this.__addPoint(this.p2);\n\t                return this.path;\n\t            }\n\t\n\t            // Following \"Conversion from endpoint to center parameterization\"\n\t            // http://www.w3.org/TR/SVG/implnote.html#ArcConversionEndpointToCenter\n\t\n\t            // Step #1: Compute transformedPoint\n\t            var dx = (this.p1.x - this.p2.x) / 2;\n\t            var dy = (this.p1.y - this.p2.y) / 2;\n\t\n\t            var transformedPoint = {\n\t                x: Math.cos(this.radians) * dx + Math.sin(this.radians) * dy,\n\t                y: -Math.sin(this.radians) * dx + Math.cos(this.radians) * dy\n\t            };\n\t\n\t            // Ensure radii are large enough\n\t            var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(this.rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(this.ry, 2);\n\t\n\t            if (radiiCheck > 1) {\n\t                this.rx = Math.sqrt(radiiCheck) * this.rx;\n\t                this.ry = Math.sqrt(radiiCheck) * this.ry;\n\t            }\n\t\n\t            // Step #2: Compute transformedCenter\n\t            var cSquareNumerator = Math.pow(this.rx, 2) * Math.pow(this.ry, 2) - Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2);\n\t            var cSquareRootDenom = Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2);\n\t            var cRadicand = cSquareNumerator / cSquareRootDenom;\n\t\n\t            // Make sure this never drops below zero because of precision\n\t            cRadicand = cRadicand < 0 ? 0 : cRadicand;\n\t            var cCoef = (this.large !== this.sweep ? 1 : -1) * Math.sqrt(cRadicand);\n\t            var transformedCenter = {\n\t                x: cCoef * (this.rx * transformedPoint.y / this.ry),\n\t                y: cCoef * (-(this.ry * transformedPoint.x) / this.rx)\n\t            };\n\t\n\t            // Step #3: Compute center\n\t            this.center = {\n\t                x: Math.cos(this.radians) * transformedCenter.x - Math.sin(this.radians) * transformedCenter.y + (this.p1.x + this.p2.x) / 2,\n\t                y: Math.sin(this.radians) * transformedCenter.x + Math.cos(this.radians) * transformedCenter.y + (this.p1.y + this.p2.y) / 2\n\t            };\n\t\n\t            // Step #4: Compute start/sweep angles\n\t            // Start angle of the elliptical arc prior to the stretch and rotate operations.\n\t            // Difference between the start and end angles\n\t            var startVector = {\n\t                x: (transformedPoint.x - transformedCenter.x) / this.rx,\n\t                y: (transformedPoint.y - transformedCenter.y) / this.ry\n\t            };\n\t\n\t            var endVector = {\n\t                x: (-transformedPoint.x - transformedCenter.x) / this.rx,\n\t                y: (-transformedPoint.y - transformedCenter.y) / this.ry\n\t            };\n\t\n\t            this.startAngle = angle({ x: 1, y: 0 }, startVector);\n\t            this.sweepAngle = angle(startVector, endVector);\n\t\n\t            if (!this.sweep && this.sweepAngle > 0) {\n\t                this.sweepAngle -= MATH_PI_2;\n\t            } else if (this.sweep && this.sweepAngle < 0) {\n\t                this.sweepAngle += MATH_PI_2;\n\t            }\n\t\n\t            // We use % instead of `mod(..)` because we want it to be -360deg to 360deg(but actually in radians)\n\t            this.sweepAngle %= MATH_PI_2;\n\t        }\n\t    }, {\n\t        key: 'trace',\n\t        value: function trace(settings) {\n\t            this.init(settings);\n\t            return _get(Arc.prototype.__proto__ || Object.getPrototypeOf(Arc.prototype), 'trace', this).call(this);\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            var angle = this.startAngle + this.sweepAngle * t;\n\t\n\t            var x = this.rx * Math.cos(angle);\n\t            var y = this.ry * Math.sin(angle);\n\t\n\t            return new _path.Point(Math.cos(this.radians) * x - Math.sin(this.radians) * y + this.center.x, Math.sin(this.radians) * x + Math.cos(this.radians) * y + this.center.y);\n\t        }\n\t    }, {\n\t        key: '_postTrace',\n\t        value: function _postTrace() {\n\t            // Add last point in the path\n\t            this._addPoint(this.p2);\n\t        }\n\t    }]);\n\t\n\t    return Arc;\n\t}(TraceBase);\n\t\n\tvar CubicBezier = function (_TraceBase2) {\n\t    _inherits(CubicBezier, _TraceBase2);\n\t\n\t    function CubicBezier() {\n\t        _classCallCheck(this, CubicBezier);\n\t\n\t        return _possibleConstructorReturn(this, (CubicBezier.__proto__ || Object.getPrototypeOf(CubicBezier)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(CubicBezier, [{\n\t        key: '_B1',\n\t        value: function _B1(t) {\n\t            return t * t * t;\n\t        }\n\t    }, {\n\t        key: '_B2',\n\t        value: function _B2(t) {\n\t            return 3 * t * t * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_B3',\n\t        value: function _B3(t) {\n\t            return 3 * t * (1 - t) * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_B4',\n\t        value: function _B4(t) {\n\t            return (1 - t) * (1 - t) * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_C1',\n\t        value: function _C1(p1, p2, p3, p4, t) {\n\t            return p1 * this._B1(t) + p2 * this._B2(t) + p3 * this._B3(t) + p4 * this._B4(t);\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            return new _path.Point(this._C1(this.p1.x, this.p2.x, this.p3.x, this.p4.x, t), this._C1(this.p1.y, this.p2.y, this.p3.y, this.p4.y, t));\n\t        }\n\t    }, {\n\t        key: '_addPoint',\n\t        value: function _addPoint(point) {\n\t            this.path.unshift(point.x, point.y);\n\t        }\n\t    }]);\n\t\n\t    return CubicBezier;\n\t}(TraceBase);\n\t\n\tvar QuadricBezier = function (_TraceBase3) {\n\t    _inherits(QuadricBezier, _TraceBase3);\n\t\n\t    function QuadricBezier() {\n\t        _classCallCheck(this, QuadricBezier);\n\t\n\t        return _possibleConstructorReturn(this, (QuadricBezier.__proto__ || Object.getPrototypeOf(QuadricBezier)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(QuadricBezier, [{\n\t        key: '_B1',\n\t        value: function _B1(t) {\n\t            return t * t;\n\t        }\n\t    }, {\n\t        key: '_B2',\n\t        value: function _B2(t) {\n\t            return 2 * t * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_B3',\n\t        value: function _B3(t) {\n\t            return (1 - t) * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_C1',\n\t        value: function _C1(p1, p2, p3, t) {\n\t            return p1 * this._B1(t) + p2 * this._B2(t) + p3 * this._B3(t);\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            return new _path.Point(this._C1(this.p1.x, this.p2.x, this.p3.x, t), this._C1(this.p1.y, this.p2.y, this.p3.y, t));\n\t        }\n\t    }, {\n\t        key: '_addPoint',\n\t        value: function _addPoint(point) {\n\t            this.path.unshift(point.x, point.y);\n\t        }\n\t    }]);\n\t\n\t    return QuadricBezier;\n\t}(TraceBase);\n\t\n\t// Exports\n\t\n\t\n\texports.Arc = Arc;\n\texports.CubicBezier = CubicBezier;\n\texports.QuadricBezier = QuadricBezier;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// lw.svg-parser.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 63d98a286bb5b51cc981","class Point {\n    // Class constructor...\n    constructor(x, y) {\n        // Init properties\n        this.x = parseFloat(x)\n        this.y = parseFloat(y)\n\n        if (isNaN(this.x) || isNaN(this.y)) {\n            console.error('x:', x, 'y:', y)\n            throw new Error('Float value!!!')\n        }\n    }\n\n    isEqual(point) {\n        return this.x === point.x && this.y === point.y\n    }\n}\n\nclass Path {\n    // Class constructor...\n    constructor(element, parent) {\n        // Init properties\n        this.points = []\n        this.length = 0\n    }\n\n    getPoints() {\n        return this.points\n    }\n\n    getFlattenPoints() {\n        let points = []\n        this.points.forEach(point => points.push(point.x, point.y))\n        return points\n    }\n\n    getPoint(i) {\n        return this.points[i < 0 ? this.length + i : i] || null\n    }\n\n    addPoint(x, y) {\n        this.points.push(new Point(x, y))\n        this.length = this.points.length\n    }\n\n    addPoints(points) {\n        // For each couple of points\n        for (let i = 0, il = points.length; i < il; i += 2) {\n            this.addPoint(points[i], points[i + 1])\n        }\n    }\n\n    isClosed() {\n        let firstPoint = this.getPoint(0)\n        return firstPoint && firstPoint.isEqual(this.getPoint(-1))\n    }\n\n    close() {\n        if (! this.isClosed() && this.length > 2) {\n            let firstPoint = this.getPoint(0)\n            this.addPoint(firstPoint.x, firstPoint.y)\n            return true\n        }\n\n        return false\n    }\n\n    transform(matrix) {\n        this.points = this.points.map(point => {\n            return new Point(\n                matrix[0] * point.x + matrix[2] * point.y + matrix[4],\n                matrix[1] * point.x + matrix[3] * point.y + matrix[5]\n            )\n        })\n    }\n}\n\n// Exports\nexport { Path, Point }\nexport default Path\n\n\n\n// WEBPACK FOOTER //\n// ./path.js","// Imports\nimport { Tag } from './tag'\nimport { TagParser } from './tagparser'\n\n// SVG parser class\nclass Parser {\n    // Class constructor...\n    constructor(settings) {\n        // Defaults settings\n        settings = settings || {}\n\n        // Init properties\n        this.element  = null // XML document Element object\n        this.editor   = null // Editor info { name, version, fingerprint }\n        this.document = null // Document info { width, height, viewBox }\n        this.defs     = null // Defined <defs> (DOM) nodes list by id\n        this.tags     = null // Tag objects hierarchy\n\n        this.traceSettings = Object.assign({\n            linear          : true, // Linear trace mode\n            step            : 0.01, // Step resolution if linear mode = false\n            resolution      : 500,  // number of segments we use to approximate arc length\n            minSegmentLength: 0.01, // Minimum segemnt length\n            segments        : 24    // Numbers of segments\n        }, settings.traceSettings || {})\n\n        // Supported tags by this lib\n        this.supportedTags = [\n            'svg', 'g', 'defs', 'use',\n            'line', 'polyline', 'polygon',\n            'rect', 'circle', 'ellipse', 'path',\n            'title', 'desc'\n        ]\n\n        // Tags list to includes/excludes\n        this.parseTags = settings.includes || this.supportedTags\n        this.skipTags  = settings.excludes || ['#text', '#comment']  // silent (no warning)\n\n        // User onTag callback ?\n        settings.onTag && this.onTag(settings.onTag, settings.onTagContext)\n    }\n\n    // Load raw XML string, XMLDocument, Element or File object\n    load(input) {\n        // Load raw XML string\n        if (typeof input === 'string') {\n            return this.loadFromString(input)\n        }\n\n        // Load File object\n        if (input instanceof File) {\n            return this.loadFromFile(input)\n        }\n\n        // Load XMLDocument object\n        if (input instanceof XMLDocument) {\n            return this.loadFromXMLDocument(input)\n        }\n\n        // Load Element object\n        if (input instanceof Element) {\n            return this.loadFromElement(input)\n        }\n\n        // Return rejected promise with an Error object\n        return Promise.reject(new Error('Unsupported input format.'))\n    }\n\n    // Load from Element object\n    loadFromElement(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof Element)) {\n                reject(new Error('Input param must be a Element object.'))\n            }\n\n            // Parser error\n            if (input.nodeName === 'parsererror') { // FF\n                reject(new Error(input.textContent))\n            }\n\n            if (input.nodeName === 'html' && input.getElementsByTagName('parsererror')) { // Chrome\n                reject(new Error(input.getElementsByTagName('parsererror')[0].textContent))\n            }\n\n            // Set document element\n            this.element = input\n\n            // Resolve promise\n            resolve(input)\n        })\n    }\n\n    // Load from XMLDocument object\n    loadFromXMLDocument(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof XMLDocument)) {\n                reject(new Error('Input param must be a XMLDocument object.'))\n            }\n\n            // Load from Element...\n            this.loadFromElement(input.documentElement).then(resolve).catch(reject)\n        })\n    }\n\n    // Load raw XML string\n    loadFromString(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (typeof input !== 'string') {\n                reject(new Error('Input param must be a string.'))\n            }\n\n            // Parse svg editor\n            this._parseEditor(input)\n\n            // Parse string as DOM object\n            let parser = new DOMParser()\n            let XMLDoc = parser.parseFromString(input, 'text/xml')\n\n            // Load from XMLDocument...\n            this.loadFromXMLDocument(XMLDoc).then(resolve).catch(reject)\n        })\n    }\n\n    // Try to get the svg editor from input string\n    _parseEditor(input) {\n        // Reset editor\n        this.editor = {\n            name       : 'unknown',\n            version    : null,\n            fingerprint: null\n        }\n\n        // Fingerprint matches\n        let fingerprint\n\n        // Inkscape\n        fingerprint = input.match(/<!-- Created with Inkscape .*-->/i)\n\n        if (fingerprint) {\n            this.editor.name        = 'inkscape'\n            this.editor.fingerprint = fingerprint[0]\n\n            return this.editor\n        }\n\n        // Illustrator\n        fingerprint = input.match(/<!-- Generator: Adobe Illustrator ([0-9\\.]+), .*-->/i)\n\n        if (fingerprint) {\n            this.editor.name        = 'illustrator'\n            this.editor.version     = fingerprint[1]\n            this.editor.fingerprint = fingerprint[0]\n\n            return this.editor\n        }\n\n        // Return default\n        return this.editor\n    }\n\n    // Load from File object\n    loadFromFile(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof File)) {\n                reject(new Error('Input param must be a File object.'))\n            }\n\n            // Create file reader\n            let reader = new FileReader()\n\n            // Register reader events handlers\n            reader.onload = event => {\n                this.loadFromString(event.target.result).then(resolve).catch(reject)\n            }\n\n            reader.onerror = event => {\n                reject(new Error('Error reading file : ' + input.name))\n            }\n\n            // Finally read input file as text\n            reader.readAsText(input)\n        })\n    }\n\n    // Parse the (loaded) element\n    parse(input) {\n        // Reset properties\n        this.document = null\n        this.defs     = {}\n        this.tags     = null\n\n        // Load input if provided\n        if (input) {\n            return new Promise((resolve, reject) => {\n                this.load(input).then(() => {\n                    resolve(this.parse())\n                }).catch(reject)\n            })\n        }\n\n        // Start parsing element\n        return new Promise((resolve, reject) => {\n            // If no element is loaded\n            if (! this.element) {\n                reject(new Error('No element is loaded, call the load method before.'))\n            }\n\n            // Parse the main Element (recursive)\n            this.tags = this._parseElement(this.element)\n\n            if (! this.tags) {\n                reject(new Error('No supported tags found.'))\n            }\n\n            // Apply matrix (recursive)\n            this.tags.applyMatrix()\n\n            // Resolve the promise\n            resolve(this.tags)\n        })\n    }\n\n    // On tag callback\n    _onTag(tag) {\n        console.info('onTag:', tag)\n    }\n\n    // Register on tag callback\n    onTag(callback, context) {\n        this._onTag = tag => callback.call(context || this, tag)\n    }\n\n    // Parse the provided Element and return an Tag collection (recursive)\n    _parseElement(element, parent) {\n        // Create base tag object\n        let tag = new Tag(element, parent)\n\n        // Exluded tag ?\n        if (this.skipTags.indexOf(tag.name) !== -1) {\n            return null // silent\n        }\n\n        // Supported tag ?\n        if (this.parseTags.indexOf(tag.name) === -1) {\n            return this._skipTag(tag, 'unsupported')\n        }\n\n        // Parse the tag\n        let tagParser = new TagParser(tag, this)\n\n        if (! tagParser.parse()) {\n            return false\n        }\n\n        // Call the on tag callback\n        this._onTag(tag)\n\n        // Parse child nodes\n        let childTag\n\n        element.childNodes.forEach(childNode => {\n            // Parse child element\n            if (childTag = this._parseElement(childNode, tag)) {\n                tag.addChild(childTag)\n            }\n        })\n\n        // Empty group\n        if (['svg', 'g'].indexOf(tag.name) !== -1 && ! tag.children.length) {\n            return this._skipTag(tag, 'empty')\n        }\n\n        // Return tag object\n        return tag\n    }\n\n    // Log skip tag warning message\n    _skipTag(tag, message) {\n        console.warn('Skip tag :', message + ':', tag)\n        return false\n    }\n\n    // Log skip tag attribute warning message\n    _skipTagAttr(tag, attr, message) {\n        console.warn('Skip tag attribute :', message + ':', attr, tag)\n        return false\n    }\n\n}\n\n// Exports\nexport { Parser }\nexport default Parser\n\n\n\n// WEBPACK FOOTER //\n// ./parser.js","import { Path, Point } from './path'\n\nconst DEG_TO_RAD = Math.PI / 180\n\n// SVG tag class\nclass Tag {\n    // Class constructor...\n    constructor(element, parent) {\n        // Init properties\n        this.element  = element\n        this.name     = element.nodeName.toLowerCase()\n        this.parent   = parent || null\n        this.layer    = null\n        this.attrs    = {}\n        this.children = []\n        this.paths    = []\n        this.matrix   = null\n        this.path     = new Path()\n        this.point    = new Point(0, 0)\n\n        // Add first path\n        this.paths.push(this.path)\n\n        // Set the matrix\n        this.setMatrix(this.parent && this.parent.matrix)\n\n        // Clone parent attributes\n        if (this.parent && (this.parent.name === 'g' || this.parent.name === 'svg')) {\n            // Inherit layer name\n            this.layer = this.parent.layer\n\n            // Inherit parent attributes\n            let excludes = ['transform', 'width', 'height']\n\n            Object.keys(this.parent.attrs).forEach(key => {\n                if (excludes.indexOf(key) === -1) {\n                    this.setAttr(key, this.parent.attrs[key])\n                }\n            })\n        }\n    }\n\n    setAttr(name, value) {\n        this.attrs[name] = value\n    }\n\n    getAttr(name, defaultValue) {\n        return this.attrs[name] !== undefined ? this.attrs[name]\n            : (defaultValue !== undefined ? defaultValue : null)\n    }\n\n    getLayerName() {\n        if (this.name === 'g') {\n            return this.getAttr('inkscape:label', this.getAttr('id', null))\n        }\n    }\n\n    setLayerName(name) {\n        if (this.name === 'g') {\n            this.layer = name || this.getLayerName()\n        }\n    }\n\n    addChild(childTag) {\n        this.children.push(childTag)\n    }\n\n    clearPath() {\n        this.path = new Path()\n    }\n\n    newPath() {\n        if (this.path.length > 0) {\n            this.clearPath()\n            this.paths.push(this.path)\n        }\n    }\n\n    closePath() {\n        return this.path.close()\n    }\n\n    addPoint(x, y, relative) {\n        // Relative from the last point\n        if (relative) {\n            x += this.point.x\n            y += this.point.y\n        }\n\n        // Add current point\n        this.path.addPoint(x, y)\n\n        // Update current point\n        this.point = this.path.getPoint(-1)\n    }\n\n    addPoints(points, relative) {\n        // For each couple of points\n        for (let i = 0, il = points.length; i < il; i += 2) {\n            this.addPoint(points[i], points[i + 1], relative)\n        }\n    }\n\n    setMatrix(matrix) {\n        this.matrix = matrix || [1, 0, 0, 1, 0, 0]\n    }\n\n    addMatrix(matrix) {\n        this.matrix = [\n            this.matrix[0] * matrix[0] + this.matrix[2] * matrix[1],\n            this.matrix[1] * matrix[0] + this.matrix[3] * matrix[1],\n            this.matrix[0] * matrix[2] + this.matrix[2] * matrix[3],\n            this.matrix[1] * matrix[2] + this.matrix[3] * matrix[3],\n            this.matrix[0] * matrix[4] + this.matrix[2] * matrix[5] + this.matrix[4],\n            this.matrix[1] * matrix[4] + this.matrix[3] * matrix[5] + this.matrix[5]\n        ]\n    }\n\n    translate(x, y) {\n        y = y === undefined ? 0 : y\n        this.addMatrix([1, 0, 0, 1, x, y])\n    }\n\n    rotate(angle, x, y) {\n        angle = angle * DEG_TO_RAD\n\n        if (arguments.length == 2) {\n            this.addMatrix([1, 0, 0, 1, x, y])\n        }\n\n        this.addMatrix([Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0])\n\n        if (arguments.length == 2) {\n            this.addMatrix([1, 0, 0, 1, -x, -y])\n        }\n    }\n\n    scale(x, y) {\n        y = y === undefined ? x : y\n        this.addMatrix([x, 0, 0, y, 0, 0])\n    }\n\n    skewX(angle) {\n        this.addMatrix([1, 0, Math.tan(angle * DEG_TO_RAD), 1, 0, 0])\n    }\n\n    skewY(angle) {\n        this.addMatrix([1, Math.tan(angle * DEG_TO_RAD), 0, 1, 0, 0])\n    }\n\n    applyMatrix(matrix) {\n        matrix && this.addMatrix(matrix)\n\n        this.paths.forEach(path => {\n            path.transform(this.matrix)\n        })\n\n        this.setMatrix(null)\n\n        this.children.forEach(tag => {\n            tag.applyMatrix(matrix)\n        })\n    }\n}\n\n// Exports\nexport { Tag }\nexport default Tag\n\n\n\n// WEBPACK FOOTER //\n// ./tag.js","import { /*trace,*/ Arc, CubicBezier, QuadricBezier } from './trace'\nimport { Point } from './path'\n\n// SVG tag parser\nclass TagParser {\n    // Class constructor...\n    constructor(tag, parser) {\n        // Init properties\n        this.tag            = tag\n        this.parser         = parser\n        this.currentCommand = null\n        this.lastCommand    = null\n        this.pathData       = null\n        this.traceSettings  = parser.traceSettings\n    }\n\n    parse() {\n        // Get internal parser from node name\n        let handler = this['_' + this.tag.name]\n\n        // Implemented tag handler?\n        if (! handler || typeof handler !== 'function') {\n            return this.parser._skipTag(this.tag, 'not yet implemented')\n        }\n\n        // Parse tag attributes\n        this._parseTagAttrs()\n\n        // Parse tag\n        let result = handler.call(this)\n\n        if (result && this.tag.getAttr('fill') && this.tag.paths[0].length) {\n            let paths = []\n            let debug = []\n\n            this.tag.paths.forEach(path => {\n                this.tag.triangles = null\n                paths.push(path.getFlattenPoints())\n                debug.push('[' + path.getFlattenPoints().join(',') + ']')\n            })\n\n            console.log(paths.length, debug.join(','))\n        }\n\n        return result\n    }\n\n    // Parse the tag attributes\n    _parseTagAttrs() {\n        // Get tag attributes\n        let attrs = this.tag.element.attributes\n\n        if (! attrs) {\n            return null\n        }\n\n        // For each attribute\n        let attr, value, style\n\n        Object.keys(attrs).some(key => {\n            // Current attribute\n            attr = attrs[key]\n\n            // Normalize attribute value\n            value = this._normalizeTagAttr(attr)\n\n            if (value === false) {\n                return false // continue\n            }\n\n            // Special case\n            if (attr.nodeName === 'style') {\n                style = value\n            }\n            else {\n                // Set new attribute name/value\n                this.tag.setAttr(attr.nodeName, value)\n            }\n        })\n\n        // If style attribute (override tag attributes)\n        // TODO get/parse global style and override this one...\n        style && style.split(';').some(attr => {\n            // Current style\n            attr = attr.split(':')\n            attr = { nodeName: attr[0], nodeValue: attr[1] }\n\n            // Normalize attribute value\n            value = this._normalizeTagAttr(attr)\n\n            if (value === false) {\n                return false // continue\n            }\n\n            // Set new attribute name/value\n            this.tag.setAttr(attr.nodeName, value)\n        })\n\n        // Set inherited color\n        let colorsAttrs = ['fill', 'stroke', 'color']\n\n        colorsAttrs.forEach(attrName => {\n            if (this.tag.getAttr(attrName) === 'inherit') {\n                this.tag.setAttr(attrName, this.tag.parent.getAttr(attrName, 'none'))\n            }\n        })\n\n        // Parse viewBox attribute\n        this._parseViewBoxAttr()\n\n        // Parse transform attribute\n        this._parseTransformAttr()\n    }\n\n    // Normalize tag attribute\n    _normalizeTagAttr(attr) {\n        // Normalize whitespaces\n        let value = attr.nodeValue\n            .replace(/(\\r?\\n|\\r)+/gm, ' ') // Remove all new line chars\n            .replace(/\\s+/gm, ' ')         // Reduce multiple whitespaces\n            .trim()                        // Remove trailing whitespaces\n\n        if (! value.length) {\n            return this.parser._skipTagAttr(this.tag, attr, 'empty')\n        }\n\n        // Filters\n        switch (attr.nodeName) {\n            // Normalize size unit -> to px\n            case 'x':\n            case 'y':\n            case 'x1':\n            case 'y1':\n            case 'x2':\n            case 'y2':\n            case 'r':\n            case 'rx':\n            case 'ry':\n            case 'cx':\n            case 'cy':\n            case 'width':\n            case 'height':\n            case 'fontSize':\n            case 'strokeWidth':\n                value = this._normalizeTagAttrUnit(attr)\n            break\n\n            // Normalize points attribute\n            case 'points':\n            case 'viewBox':\n                value = this._normalizeTagAttrPoints(attr)\n            break\n\n            // Range limit to [0 - 1]\n            case 'opacity':\n            case 'fillOpacity':\n            case 'strokeOpacity':\n                value = this._normalizeTagAttrRange(attr, 0, 1)\n            break\n\n            case 'preserveAspectRatio':\n                value = this._normalizeTagAttrPreserveAspectRatio(attr)\n            break\n        }\n\n        // Return normalized value\n        return value\n    }\n\n    // Normalize attribute unit to px\n    _normalizeTagAttrUnit(attr) {\n        let stringValue = attr.nodeValue.toLowerCase()\n        let floatValue  = parseFloat(stringValue)\n\n        if (isNaN(floatValue)) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric value allowed')\n        }\n\n        if (stringValue.indexOf('mm') !== -1) {\n            return floatValue * 3.5433070869\n        }\n\n        if (stringValue.indexOf('cm') !== -1) {\n            return floatValue * 35.433070869\n        }\n\n        if (stringValue.indexOf('in') !== -1) {\n            return floatValue * 90.0\n        }\n\n        if (stringValue.indexOf('pt') !== -1) {\n            return floatValue * 1.25\n        }\n\n        if (stringValue.indexOf('pc') !== -1) {\n            return floatValue * 15.0\n        }\n\n        return floatValue\n    }\n\n    // Normalize points attribute\n    _normalizeTagAttrPoints(attr) {\n        let points = this._parseNumbers(attr.nodeValue)\n\n        if (points === false) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed')\n        }\n\n        if (! points.length) {\n            return this.parser._skipTagAttr(this.tag, attr, 'empty points list')\n        }\n\n        if (points.length % 0) {\n            return this.parser._skipTagAttr(this.tag, attr, 'the number of points must be even')\n        }\n\n        return points\n    }\n\n    // Normalize range attribute like \"opacity\"\n    _normalizeTagAttrRange(attr, min, max) {\n        let stringValue = attr.nodeValue.trim()\n        let floatValue  = parseFloat(stringValue)\n\n        if (isNaN(floatValue)) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed')\n        }\n\n        if (floatValue < min || floatValue > max) {\n            return this.parser._skipTagAttr(this.tag, attr, 'out of range [' + min + ', ' + max + ']')\n        }\n\n        return floatValue\n    }\n\n    // Parse points string as numbers array\n    _parseNumbers(points) {\n        // http://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly\n        if (typeof points === 'string') {\n            points = points.split(/([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/g)\n            .filter(point => {\n                return point && ['', ','].indexOf(point.trim()) === -1\n            })\n        }\n\n        // Normalize to float values\n        points = points.map(parseFloat)\n\n        // Test if all numbers is valid\n        if (points.some(isNaN)) {\n            return false\n        }\n\n        return points\n    }\n\n    // Normalize the preserveAspectRatio attribute\n    _normalizeTagAttrPreserveAspectRatio(attr) {\n        let params = {\n            defer: false,\n            align: 'none',\n            meet : true,\n            slice: false\n        }\n\n        let rawParams = attr.nodeValue\n\n        if (rawParams.indexOf('defer') === 0) {\n            rawParams    = rawParams.substr(6)\n            params.defer = true\n        }\n\n        rawParams    = rawParams.split(' ')\n        params.align = rawParams[0]\n        params.meet  = rawParams[1] || 'meet'\n        params.meet  = params.meet === 'meet'\n        params.slice = ! params.meet\n\n        return params\n    }\n\n    // Parse viewBox attribute and set transformations\n    _parseViewBoxAttr() {\n        // Get viewBox attribute\n        let viewBox = this.tag.getAttr('viewBox', null)\n\n        // No viewBox...\n        if (viewBox === null) {\n            return null\n        }\n\n        // Update size attributes\n        let width  = this.tag.getAttr('width', viewBox[2])\n        let height = this.tag.getAttr('height', viewBox[3])\n\n        this.tag.setAttr('width' , width)\n        this.tag.setAttr('height', height)\n\n        // Scale to match viewBox\n        // TODO clip path if preserveAspectRatio.slice\n        let scaleX     = width  / viewBox[2]\n        let scaleY     = height / viewBox[3]\n        let translateX = viewBox[0]\n        let translateY = viewBox[1]\n\n        let preserveAspectRatio = this.tag.getAttr('preserveAspectRatio', 'meet xMidYMid')\n\n        if (preserveAspectRatio) {\n            let newWidth, newHeight\n\n            if (preserveAspectRatio.meet) {\n                if (scaleX > scaleY) {\n                    scaleX   = scaleY\n                    newWidth = viewBox[2] * scaleX\n                }\n                else if (scaleX < scaleY) {\n                    scaleY    = scaleX\n                    newHeight = viewBox[3] * scaleY\n                }\n            }\n            else if (preserveAspectRatio.slice) {\n                if (scaleX < scaleY) {\n                    scaleX   = scaleY\n                    newWidth = viewBox[2] * scaleX\n                }\n                else if (scaleX > scaleY) {\n                    scaleY    = scaleX\n                    newHeight = viewBox[3] * scaleY\n                }\n            }\n\n            if (newWidth !== undefined) {\n                if (preserveAspectRatio.align === 'xMidYMid') {\n                    this.tag.translate((width - newWidth) / 2, 0)\n                }\n                else if (preserveAspectRatio.align === 'xMaxYMax') {\n                    this.tag.translate(width - newWidth, 0)\n                }\n            }\n            else if (newHeight !== undefined) {\n                if (preserveAspectRatio.align === 'xMidYMid') {\n                    this.tag.translate(0, (height - newHeight) / 2)\n                }\n                else if (preserveAspectRatio.align === 'xMaxYMax') {\n                    this.tag.translate(0, height - newHeight)\n                }\n            }\n        }\n\n        this.tag.scale(scaleX, scaleY)\n        this.tag.translate(-translateX, -translateY)\n    }\n\n    // Parse transform attribute and set transformations\n    _parseTransformAttr() {\n        // Get transform attribute\n        let transformAttr = this.tag.getAttr('transform', null)\n\n        // No transformation...\n        if (transformAttr === null || ! transformAttr.length) {\n            return null\n        }\n\n        // Parse attribute (split group on closing parenthesis)\n        let transformations = transformAttr.split(')')\n\n        // Remove last entry due to last \")\" found\n        transformations.pop()\n\n        // For each transformation\n        let transform, type, params\n\n        transformations.some(raw => {\n            // Split name and value on opening parenthesis\n            transform = raw.split('(')\n\n            // Invalid parts number\n            if (transform.length !== 2) {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'malformed') // continue\n            }\n\n            type = transform[0].trim()\n\n            // Quik hack 1/2\n            let func = type\n            if (func === 'matrix') {\n                func = 'addMatrix'\n            }\n\n            // Get tag transform method\n            let tagTransform = this.tag[func]\n\n            if (typeof tagTransform !== 'function') {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'unsupported transform type :' + type)\n            }\n\n            params = transform[1].trim()\n            params = this._parseNumbers(params)\n\n            // Skip empty value\n            if (! params.length) {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'malformed transform type :' + type)\n            }\n\n            // Quik hack 2/2\n            if (func == 'addMatrix') {\n                params = [params]\n            }\n\n            // Call tag transform method like \"tag.translate(param1, ..., paramN)\"\n            tagTransform.apply(this.tag, params)\n        })\n    }\n\n    _newPath() {\n        this.tag.newPath()\n    }\n\n    _clearPath() {\n        this.tag.clearPath()\n    }\n\n    _closePath() {\n        return this.tag.closePath()\n    }\n\n    _addPoints(points, relative) {\n        if (! points.length) {\n            return this.parser._skipTag(this.tag, 'empty points list')\n        }\n\n        if (points.length % 0) {\n            return this.parser._skipTag(this.tag, 'the number of points must be even')\n        }\n\n        relative = arguments.length < 2 && this.currentCommand.relative\n\n        this.tag.addPoints(points, relative)\n        return true\n    }\n\n    // SVG specs at https://www.w3.org/TR/SVG11/\n\n    _svg() {\n        // Only parse the root SVG tag as main document\n        if (this.parser.document) {\n            // Handled tag\n            return true\n        }\n\n        // Get the document size\n        let width  = this.tag.getAttr('width')\n        let height = this.tag.getAttr('height')\n\n        // Invalid size\n        if (! width || width < 0 || ! height || height < 0) {\n            throw new Error('Invalid document size: ' + width + ' / ' + height)\n        }\n\n        // Set document size\n        this.parser.document = {\n            width : width,\n            height: height\n        }\n\n        // Get document viewBox or set default to document size\n        let viewBox = this.tag.getAttr('viewBox', [0, 0, width, height])\n\n        this.parser.document.viewBox = {\n            x     : viewBox[0],\n            y     : viewBox[1],\n            width : viewBox[2],\n            height: viewBox[3]\n        }\n\n        // Check inkscape version\n        if (this.parser.editor.name === 'inkscape') {\n            this.parser.editor.version = this.tag.getAttr('inkscape:version')\n        }\n\n        // Handled tag\n        return true\n    }\n\n    _title() {\n        // Register the first encountered title tag as document title\n        if (this.parser.document && ! this.parser.document.title) {\n            this.parser.document.title = this.tag.element.textContent\n        }\n\n        // Skipped tag\n        return false\n    }\n\n    _desc() {\n        // Register the first encountered desc tag as document description\n        if (this.parser.document && ! this.parser.document.description) {\n            this.parser.document.description = this.tag.element.textContent\n        }\n\n        // Skipped tag\n        return false\n    }\n\n    _defs() {\n        // Register all child element with an id attribute\n        this.tag.element.childNodes.forEach(childNode => {\n            childNode.id && (this.parser.defs[childNode.id] = childNode)\n        })\n\n        // Skipped tag\n        return false\n    }\n\n    _use() {\n        // Get the target id\n        let target  = this.tag.getAttr('xlink:href').replace(/^#/, '')\n\n        // Try to get the defined element\n        let element = this.parser.defs[target]\n\n        if (! element) {\n            return this.parser._skipTag(this.tag, 'undefined reference [' + target + ']')\n        }\n\n        // Parse the defined element and set new parent from <use> tag parent\n        let useTag = this.parser._parseElement(element, this.tag.parent)\n\n        if (! useTag) {\n            return this.parser._skipTag(this.tag, 'empty reference [' + target + ']')\n        }\n\n        // Set matrix from real parent (<use>)\n        useTag.setMatrix(this.tag.matrix)\n\n        // Replace the use tag with new one\n        this.tag.parent.addChild(useTag)\n\n        // Skipped tag\n        return false\n    }\n\n    _g() {\n        // Set the tag layer name\n        this.tag.setLayerName()\n\n        // Handled tag\n        return true\n    }\n\n    _line() {\n        // Handled tag\n        return this._path([\n            'M', this.tag.getAttr('x1'), this.tag.getAttr('y1'),\n            'L', this.tag.getAttr('x2'), this.tag.getAttr('y2')\n        ])\n    }\n\n    _polyline(close=false) {\n        let points = this.tag.getAttr('points')\n        let path   = ['M', points.shift(), points.shift(), 'L']\n\n        path = path.concat(points)\n        close && path.push('Z')\n\n        // Handled tag\n        return this._path(path)\n    }\n\n    _polygon() {\n        // Handled like polyline but closed\n        return this._polyline(true)\n    }\n\n    _rect() {\n        // Get rectangle attributes\n        let w  = this.tag.getAttr('width')\n        let h  = this.tag.getAttr('height')\n        let x  = this.tag.getAttr('x', 0)\n        let y  = this.tag.getAttr('y', 0)\n        let rx = this.tag.getAttr('rx', null)\n        let ry = this.tag.getAttr('ry', null)\n\n        // Simple rect\n        if (!rx && !ry) {\n            // Handled tag\n            return this._path(['M', x, y, 'h', w, 'v', h, 'h', -w, 'z'])\n        }\n\n        // If a properly specified value is provided for ‘rx’, but not for ‘ry’,\n        // then set both rx and ry to the value of ‘rx’ and vis-vera...\n        if (rx === null) rx = ry\n        if (ry === null) ry = rx\n\n        // A negative value is an error\n        if (rx === null || rx === null || rx < 0 || ry < 0) {\n            // Skip tag\n            return this.parser._skipTag(this.tag, 'negative value for \"rx/ry\" not allowed')\n        }\n\n        // If rx is greater than half of ‘width’, then set rx to half of ‘width’.\n        // If ry is greater than half of ‘height’, then set ry to half of ‘height’.\n        if (rx > w / 2) rx = w / 2\n        if (ry > h / 2) ry = h / 2\n\n        let dx = rx * 2\n        let dy = ry * 2\n\n        // Handled tag\n        return this._path([\n            'M', x + rx, y,\n            'h', w - dx,\n            'c', rx, 0, rx, ry, rx, ry,\n            'v', h - dy,\n            'c', 0, ry, -rx, ry, -rx, ry,\n            'h', -w + dx,\n            'c', -rx, 0, -rx, -ry, -rx, -ry,\n            'v', -h + dy,\n            'c', 0, 0, 0, -ry, rx, -ry,\n            'z'\n        ])\n    }\n\n    _circle() {\n        let r = this.tag.getAttr('r', 0)\n\n        if (r <= 0) {\n            // Skipped tag\n            return false\n        }\n\n        let cx = this.tag.getAttr('cx', 0)\n        let cy = this.tag.getAttr('cy', 0)\n\n        // Handled tag\n        return this._path([\n            'M', cx-r, cy,\n            'A', r, r, 0, 0, 0, cx, cy+r,\n            'A', r, r, 0, 0, 0, cx+r, cy,\n            'A', r, r, 0, 0, 0, cx, cy-r,\n            'A', r, r, 0, 0, 0, cx-r, cy,\n            'Z'\n        ])\n    }\n\n    _ellipse() {\n        let rx = this.tag.getAttr('rx', 0)\n        let ry = this.tag.getAttr('ry', 0)\n\n        if (rx <= 0 || ry <= 0) {\n            // Skipped tag\n            return false\n        }\n\n        let cx = this.tag.getAttr('cx', 0)\n        let cy = this.tag.getAttr('cy', 0)\n\n        // Handled tag\n        return this._path([\n            'M', cx-rx, cy,\n            'A', rx, ry, 0, 0, 0, cx, cy+ry,\n            'A', rx, ry, 0, 0, 0, cx+rx, cy,\n            'A', rx, ry, 0, 0, 0, cx, cy-ry,\n            'A', rx, ry, 0, 0, 0, cx-rx, cy,\n            'Z'\n        ])\n    }\n\n    _paths(type, num, points) {\n        if (points.length > num) {\n            let handler, result = true\n\n            while(result && points.length) {\n                handler = this['_path' + type]\n                result  = handler.call(this, points.splice(0, num))\n            }\n\n            return result\n        }\n\n        return null\n    }\n\n    _path(path) {\n        // Provided path\n        if (path && typeof path !== 'string') {\n            path = path.join(' ')\n        }\n\n        // Get the paths data attribute value\n        let dAttr = path || this.tag.getAttr('d', null)\n\n        if (! dAttr) {\n            // Skipped tag\n            return false\n        }\n\n        // Split on each commands\n        let commands = dAttr.match(/([M|Z|L|H|V|C|S|Q|T|A]+([^M|Z|L|H|V|C|S|Q|T|A]+)?)/gi)\n\n        if (! commands) {\n            return this.parser._skipTag(this.tag, 'malformed \"d\" attribute')\n        }\n\n        // For each command...\n        this.currentCommand = {\n            raw     : null,\n            type    : null,\n            params  : null,\n            relative: null\n        }\n        this.lastCommand = this.currentCommand\n        this.pathData    = {}\n\n        let handler    = null\n        let parseError = false\n\n        commands.some(raw => {\n            // Remove trailing whitespaces\n            raw = raw.trim()\n\n            // Extract command char and params\n            this.currentCommand.raw      = raw\n            this.currentCommand.type     = raw[0].toUpperCase()\n            this.currentCommand.params   = raw.substr(1).trim()\n            this.currentCommand.relative = this.currentCommand.type !== raw[0]\n\n            // Get path handler from command char\n            handler = this['_path' + this.currentCommand.type]\n\n            if (! handler || typeof handler !== 'function') {\n                this.parser._skipTag(this.tag, 'unsupported path command [' + raw[0] + ']')\n                return parseError = true // break\n            }\n\n            // Extract all numbers from arguments string\n            this.currentCommand.params = this._parseNumbers(this.currentCommand.params)\n\n            if (this.currentCommand.params === false) {\n                this.parser._skipTag(this.tag, 'only numeric values are allowed in [' + this.currentCommand.raw + ']')\n                return parseError = true // break\n            }\n\n            // Execute command parser\n            if (! handler.call(this, this.currentCommand.params)) {\n                return parseError = true // break\n            }\n\n            // Update last command\n            this.lastCommand = {}\n\n            Object.keys(this.currentCommand).forEach(key => {\n                this.lastCommand[key] = this.currentCommand[key]\n            })\n        })\n\n        // Skip tag\n        if (parseError) {\n            this._clearPath()\n            return false\n        }\n\n        // Handled tag\n        return true\n    }\n\n    _pathM(points) {\n        // New path\n        this._newPath()\n\n        // Set the current point (start of new path)\n        // If is followed by multiple pairs of coordinates,\n        // the subsequent pairs are treated as implicit lineto commands.\n        return this._addPoints(points)\n    }\n\n    _pathZ() {\n        this._closePath()\n        return true\n    }\n\n    _pathL(points) {\n        return this._addPoints(points)\n    }\n\n    _pathH(points) {\n        return points.every(x => {\n            return this._addPoints([x, this.currentCommand.relative ? 0 : this.tag.point.y])\n        })\n    }\n\n    _pathV(points) {\n        return points.every(y => {\n            return this._addPoints([this.currentCommand.relative ? 0 : this.tag.point.x, y])\n        })\n    }\n\n    _pathC(points) {\n        // Multiple paths\n        let result = this._paths('C', 6, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = points[0] + (rl ? p1.x : 0)\n        let y1 = points[1] + (rl ? p1.y : 0)\n        let x2 = points[2] + (rl ? p1.x : 0)\n        let y2 = points[3] + (rl ? p1.y : 0)\n        let x  = points[4] + (rl ? p1.x : 0)\n        let y  = points[5] + (rl ? p1.y : 0)\n\n        this.pathData.x2 = x2\n        this.pathData.y2 = y2\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x2, y2)\n        let p4 = new Point(x, y)\n\n        //console.log('C', p1, p2, p3, p4)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : control point\n        // p4  : end point\n        let tracer = new CubicBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3, p4 }) // => [x,y, x,y, ...]\n        // let tracer = trace(CubicBezier, this.traceSettings)\n        // let coords = tracer({ p1, p2, p3, p4 })\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathS(points) {\n        // Multiple paths\n        let result = this._paths('S', 4, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = p1.x\n        let y1 = p1.y\n\n        if (this.lastCommand.type === 'S' || this.lastCommand.type === 'C') {\n            x1 -= this.pathData.x2 - x1\n            y1 -= this.pathData.y2 - y1\n        }\n\n        let x2 = points[0] + (rl ? p1.x : 0)\n        let y2 = points[1] + (rl ? p1.y : 0)\n        let x  = points[2] + (rl ? p1.x : 0)\n        let y  = points[3] + (rl ? p1.y : 0)\n\n        this.pathData.x2 = x2\n        this.pathData.y2 = y2\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x2, y2)\n        let p4 = new Point(x, y)\n\n        //console.log('S', p1, p2, p3, p4)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : control point\n        // p4  : end point\n        let tracer = new CubicBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3, p4 }) // => [x,y, x,y, ...]\n        // let tracer = trace(CubicBezier, this.traceSettings)\n        // let coords = tracer({ p1, p2, p3, p4 })\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathQ(points) {\n        // Multiple paths\n        let result = this._paths('Q', 4, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = points[0] + (rl ? p1.x : 0)\n        let y1 = points[1] + (rl ? p1.y : 0)\n        let x  = points[2] + (rl ? p1.x : 0)\n        let y  = points[3] + (rl ? p1.y : 0)\n\n        this.pathData.x1 = x1\n        this.pathData.y1 = y1\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x, y)\n\n        //console.log('Q', p1, p2, p3)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : end point\n        let tracer = new QuadricBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathT(points) {\n        // Multiple paths\n        let result = this._paths('T', 2, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = p1.x\n        let y1 = p1.y\n\n        if (this.lastCommand.type === 'Q' || this.lastCommand.type === 'T') {\n            x1 -= this.pathData.x1 - x1\n            y1 -= this.pathData.y1 - y1\n        }\n\n        let x = points[0] + (rl ? p1.x : 0)\n        let y = points[1] + (rl ? p1.y : 0)\n\n        this.pathData.x1 = x1\n        this.pathData.y1 = y1\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x, y)\n\n        //console.log('T', p1, p2, p3)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : end point\n        let tracer = new QuadricBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathA(points) {\n        // Multiple paths\n        let result = this._paths('A', 7, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let rl    = this.currentCommand.relative\n        let p1    = this.tag.point\n        let rx    = points[0]\n        let ry    = points[1]\n        let angle = points[2]\n        let large = !!points[3]\n        let sweep = !!points[4]\n        let x     = points[5] + (rl ? p1.x : 0)\n        let y     = points[6] + (rl ? p1.y : 0)\n        let p2    = new Point(x, y)\n\n        //console.log('A', p1, rx, ry, angle, large, sweep, p2)\n\n        let tracer = new Arc(this.traceSettings)\n        let coords = tracer.trace({ p1, rx, ry, angle, large, sweep, p2 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n}\n\n// Exports\nexport { TagParser }\nexport default TagParser\n\n\n\n// WEBPACK FOOTER //\n// ./tagparser.js","// Base code from : https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js\nimport { Point } from './path'\n\nconst MATH_PI_2  = Math.PI * 2\nconst DEG_TO_RAD = Math.PI / 180\n\nfunction mod(x, m) {\n    return (x % m + m) % m\n}\n\nfunction clamp(val, min, max) {\n    return Math.min(Math.max(val, min), max)\n}\n\nfunction distance(p0, p1) {\n    return Math.sqrt(Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2))\n}\n\nfunction angle(v0, v1) {\n    let p = v0.x * v1.x + v0.y * v1.y\n    let n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)))\n    return (v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1) * Math.acos(p / n)\n}\n\n// Abstract class\nclass TraceBase {\n    constructor(settings) {\n        // Set defaults properties\n        this.path             = []   // Points collection [x,y, x,y, ...]\n        this.linear           = true // Linear trace mode\n        this.step             = 0.01 // Step resolution if linear mode = false\n        this.resolution       = 500  // number of segments we use to approximate arc length\n        this.minSegmentLength = 0.01 // Minimum segemnt length\n        this.segments         = 24   // Numbers of segments\n\n        // Update properties from user settings\n        Object.assign(this, settings || {})\n\n        // Arc length properties\n        this.arcLength    = null\n        this.arcLengthMap = null\n    }\n\n    _clearPath() {\n        this.path = []\n    }\n\n    getPath() {\n        return this.path\n    }\n\n    getPointAtT(t) {\n        return new Point(0, 0)\n    }\n\n    _addPoint(point) {\n        this.path.push(point.x, point.y)\n    }\n\n    _postTrace() {\n        // Do additional tasks\n    }\n\n    _approximateLength() {\n        let arcLength    = 0\n        let arcLengthMap = []\n        let prevPoint    = this.getPointAtT(0)\n\n        let i, t, nextPoint\n\n        for(i = 0; i < this.resolution; i++) {\n            t          = clamp(i * (1 / this.resolution), 0, 1)\n            nextPoint  = this.getPointAtT(t)\n            arcLength += distance(prevPoint, nextPoint)\n\n            arcLengthMap.push({ t: t, arcLength: arcLength })\n\n            prevPoint = nextPoint\n        }\n\n        // Last stretch to the endpoint\n        nextPoint  = this.getPointAtT(1)\n        arcLength += distance(prevPoint, nextPoint)\n\n        arcLengthMap.push({ t: 1, arcLength: arcLength })\n        Object.assign(this, { arcLength, arcLengthMap })\n    }\n\n    getPointAtU(u) {\n        u = clamp(u, 0, 1)\n\n        let targetDistanceFromStartingPoint = u * this.arcLength\n\n        let resultantT    = 0\n        let prevArcLength = 0\n        let prevT         = 0\n\n        this.arcLengthMap.every(entry => {\n            let t         = entry.t\n            let arcLength = entry.arcLength\n\n            // Once we go a past our target\n            // Lets interpolate from a previous to current\n            if (arcLength >= targetDistanceFromStartingPoint) {\n                let endDiff      = arcLength - targetDistanceFromStartingPoint\n                let startDiff    = targetDistanceFromStartingPoint - prevArcLength\n                let linearFactor = (startDiff / (endDiff + startDiff)) || 0\n\n                resultantT = prevT + (t - prevT) * linearFactor\n\n                // Break\n                return false\n            }\n\n            prevArcLength = arcLength\n            prevT = t\n\n            return true\n        })\n\n        return this.getPointAtT(resultantT)\n    }\n\n    trace(settings) {\n        // Update properties from user settings\n        Object.assign(this, settings || {})\n\n        // Create default getPoint wrapper\n        let getPoint = 'getPointAtT'\n        let step     = this.step\n\n        // Linear mode ?\n        if (this.linear) {\n            getPoint     = 'getPointAtU'\n            let segments = this.segments\n\n            this._approximateLength()\n\n            if (this.arcLength / segments < this.minSegmentLength) {\n                segments = this.arcLength / this.minSegmentLength\n            }\n\n            step = 1 / segments\n        }\n\n        // Clear points list\n        this._clearPath()\n\n        // Trace the path\n        for (let t = 0; t <= 1; t += step) {\n            this._addPoint(this[getPoint](t))\n        }\n\n        // Do additional tasks\n        this._postTrace()\n\n        // Return the path\n        return this.getPath()\n    }\n}\n\n// Rewrite from https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js#L84\nclass Arc extends TraceBase {\n    init(settings) {\n        // Update properties from user settings\n        Object.assign(this, settings || {})\n\n        // Get angle in radians\n        this.radians = mod(this.angle, 360) * DEG_TO_RAD\n\n        // If the endpoints are identical, then this is equivalent\n        // to omitting the elliptical arc segment entirely.\n        if(this.p1.x === this.p2.x && this.p1.y === this.p2.y) {\n            return this.path\n        }\n\n        this.rx = Math.abs(this.rx)\n        this.ry = Math.abs(this.ry)\n\n        // If rx = 0 or ry = 0 then this arc is treated as\n        // a straight line segment joining the endpoints.\n        if (this.rx === 0 || this.ry === 0) {\n            this.__addPoint(this.p1)\n            this.__addPoint(this.p2)\n            return this.path\n        }\n\n        // Following \"Conversion from endpoint to center parameterization\"\n        // http://www.w3.org/TR/SVG/implnote.html#ArcConversionEndpointToCenter\n\n        // Step #1: Compute transformedPoint\n        let dx = (this.p1.x - this.p2.x) / 2\n        let dy = (this.p1.y - this.p2.y) / 2\n\n        let transformedPoint = {\n            x:  Math.cos(this.radians) * dx + Math.sin(this.radians) * dy,\n            y: -Math.sin(this.radians) * dx + Math.cos(this.radians) * dy\n        }\n\n        // Ensure radii are large enough\n        let radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(this.rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(this.ry, 2)\n\n        if (radiiCheck > 1) {\n            this.rx = Math.sqrt(radiiCheck) * this.rx\n            this.ry = Math.sqrt(radiiCheck) * this.ry\n        }\n\n        // Step #2: Compute transformedCenter\n        let cSquareNumerator = Math.pow(this.rx, 2) * Math.pow(this.ry, 2) - Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2)\n        let cSquareRootDenom = Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2)\n        let cRadicand        = cSquareNumerator / cSquareRootDenom\n\n        // Make sure this never drops below zero because of precision\n        cRadicand = cRadicand < 0 ? 0 : cRadicand\n        let cCoef = (this.large !== this.sweep ? 1 : -1) * Math.sqrt(cRadicand)\n        let transformedCenter = {\n            x: cCoef * ( (this.rx * transformedPoint.y) / this.ry),\n            y: cCoef * (-(this.ry * transformedPoint.x) / this.rx)\n        }\n\n        // Step #3: Compute center\n        this.center = {\n            x: Math.cos(this.radians) * transformedCenter.x - Math.sin(this.radians) * transformedCenter.y + ((this.p1.x + this.p2.x) / 2),\n            y: Math.sin(this.radians) * transformedCenter.x + Math.cos(this.radians) * transformedCenter.y + ((this.p1.y + this.p2.y) / 2)\n        }\n\n        // Step #4: Compute start/sweep angles\n        // Start angle of the elliptical arc prior to the stretch and rotate operations.\n        // Difference between the start and end angles\n        let startVector = {\n            x: (transformedPoint.x - transformedCenter.x) / this.rx,\n            y: (transformedPoint.y - transformedCenter.y) / this.ry\n        }\n\n        let endVector = {\n            x: (-transformedPoint.x - transformedCenter.x) / this.rx,\n            y: (-transformedPoint.y - transformedCenter.y) / this.ry\n        }\n\n        this.startAngle = angle({ x: 1, y: 0 }, startVector)\n        this.sweepAngle = angle(startVector, endVector)\n\n        if (! this.sweep && this.sweepAngle > 0) {\n            this.sweepAngle -= MATH_PI_2\n        }\n\n        else if (this.sweep && this.sweepAngle < 0) {\n            this.sweepAngle += MATH_PI_2\n        }\n\n        // We use % instead of `mod(..)` because we want it to be -360deg to 360deg(but actually in radians)\n        this.sweepAngle %= MATH_PI_2\n    }\n\n    trace(settings) {\n        this.init(settings)\n        return super.trace()\n    }\n\n    getPointAtT(t) {\n        let angle = this.startAngle + (this.sweepAngle * t)\n\n        let x = this.rx * Math.cos(angle)\n        let y = this.ry * Math.sin(angle)\n\n        return new Point(\n            Math.cos(this.radians) * x - Math.sin(this.radians) * y + this.center.x,\n            Math.sin(this.radians) * x + Math.cos(this.radians) * y + this.center.y\n        )\n    }\n\n    _postTrace() {\n        // Add last point in the path\n        this._addPoint(this.p2)\n    }\n}\n\nclass CubicBezier extends TraceBase {\n    _B1(t) { return t*t*t }\n    _B2(t) { return 3*t*t*(1-t) }\n    _B3(t) { return 3*t*(1-t)*(1-t) }\n    _B4(t) { return (1-t)*(1-t)*(1-t) }\n\n    _C1(p1, p2, p3, p4, t) {\n        return p1*this._B1(t) + p2*this._B2(t) + p3*this._B3(t) + p4*this._B4(t)\n    }\n\n    getPointAtT(t) {\n        return new Point(\n            this._C1(this.p1.x, this.p2.x, this.p3.x, this.p4.x, t),\n            this._C1(this.p1.y, this.p2.y, this.p3.y, this.p4.y, t)\n        )\n    }\n\n    _addPoint(point) {\n        this.path.unshift(point.x, point.y)\n    }\n}\n\nclass QuadricBezier extends TraceBase {\n    _B1(t) { return t*t }\n    _B2(t) { return 2*t*(1-t) }\n    _B3(t) { return (1-t)*(1-t) }\n\n    _C1(p1, p2, p3, t) {\n        return p1*this._B1(t) + p2*this._B2(t) + p3*this._B3(t)\n    }\n\n    getPointAtT(t) {\n        return new Point(\n            this._C1(this.p1.x, this.p2.x, this.p3.x, t),\n            this._C1(this.p1.y, this.p2.y, this.p3.y, t)\n        )\n    }\n\n    _addPoint(point) {\n        this.path.unshift(point.x, point.y)\n    }\n}\n\n// Exports\nexport { Arc, CubicBezier, QuadricBezier }\n\n\n\n// WEBPACK FOOTER //\n// ./trace.js"],"sourceRoot":""}